% Created 2021-02-15 Mon 18:18
% Intended LaTeX compiler: xelatex
\documentclass[letterspacing]{tufte-book}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{ucs}
\usepackage{xeCJK}
\setCJKmainfont{STXihei}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
\usepackage{booktabs} % book-quality tables
\usepackage{units}    % non-stacked fractions and better unit spacing
\usepackage{multicol} % multiple column layout facilities
\usepackage{fancyvrb} % extended verbatim environments
\fvset{fontsize=\normalsize}% default font size for fancy-verbatim environments
\usepackage{listings}
\lstset{basicstyle=\ttfamily\normalsize,breaklines=false,frame=l}
\setcounter{secnumdepth}{3}
\author{æ¬§é˜³ç»§è¶…}
\date{\textit{<2017-02-10 Fri>}}
\title{Grokking Monad\\\medskip
\large å‡½æ•°å¼è£…é€¼æ‰‹å†Œ}
\hypersetup{
 pdfauthor={æ¬§é˜³ç»§è¶…},
 pdftitle={Grokking Monad},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\newpage
\begin{fullwidth}
~\vfill
\thispagestyle{empty}
\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}
Copyright \copyright\ 2015-\the\year\ Jichao Ouyang

Printable is generated from free softwares: GNU Emacs, orgmode, Tex, Graphivz DOT...
\par\url{github.com/jcouyang/grokking-monad}

\par\textit{First printing, 2020}
\end{fullwidth}

\chapter*{å‰è¨€}
æœ¬ä¹¦çš„ä¸»è¦ç›®çš„æ˜¯ä¸ºäº†è§£é‡Š \textbf{ä¸ºä»€ä¹ˆéœ€è¦*ï¼Œ *å¦‚ä½•ç†è§£} ä»¥åŠ \textbf{å¦‚ä½•ä½¿ç”¨} Monadï¼Œ
åˆ†ä¸ºä¸‰å¤§ä¸ªéƒ¨åˆ†ï¼ŒçŒ«è®º/Catergory Theoryï¼Œé£Ÿç”¨çŒ«å‘¢/Practical Monadså’ŒæåŸºçŒ«å‘¢/Advanced Monadsã€‚\footnote{ä»€ä¹ˆï¼Ÿä½ ä¸å–œæ¬¢è°éŸ³æ¢—ï¼Ÿæˆ‘ä¹Ÿä¸å–œæ¬¢ï¼Œå¯æ˜¯ï¼Œè¿™ä¹Ÿä¸æ˜¯è®²è„±å£ç§€çš„ä¹¦å•Šã€‚ \sout{å†è¯´ä½ ä¹Ÿå°±èŠ±äº†å…­ç¾å…ƒï¼Œååˆ†é€‚åˆè¿™ç§å»‰ä»·æ¢—}}

\begin{quote}
\textbf{çŒ«è®º/Catergory Theory} æ˜¯ç†è®ºåŸºç¡€ï¼Œè§£é‡Šå•å­ç”±ä½•è€Œæ¥ï¼Œè‹¥æ˜¯ \sout{ä¸æƒ³è£…é€¼è£…å¾—æœ‰ç†æœ‰æ®} è§‰å¾—å¤ªæ— èŠå…¶å®å¯è·³è¿‡ï¼Œæ¯”è¾ƒé€‚åˆå¥½å¥‡å¿ƒå¤§çš„çŒ«ã€‚

\textbf{é£Ÿç”¨çŒ«å‘¢/Practical Monads} æä¾›å¾ˆå¤šæ—¥å¸¸ä¼šé‡åˆ°çš„å•å­ä¾›å¤§å®¶é£Ÿç”¨ã€‚

\textbf{æåŸºçŒ«å‘¢/Advanced Monads} é€‚åˆè°ä½ è‡ªç„¶æ‡‚å¾—ã€‚
\end{quote}

å…¶ä¸­æ‰€æœ‰ä¾‹å­éƒ½æœ‰åŒè¯­ \sout{ä¸­æ–‡å’Œè‹±è¯­} \emph{Haskell} å’Œ \emph{Scala} è§£é‡Šï¼ŒåŒè¯­ä¾‹å­éƒ½æˆå¯¹å‡ºç°ï¼Œå…ˆ Haskell å Scalaã€‚

è‡³äºä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸¤ç§è¯­è¨€ï¼Ÿå…¶å®ä»£è¡¨ä¸¤å¤§æ´¾ç³»ï¼Œä¸€ä¸ªMLç³»ä¸€ä¸ªJava/C++ç³»ï¼Œè‹¥æ˜¯çœ‹ä¸æ‡‚ Haskellï¼ŒScala å¯èƒ½
ä¼šæ›´å¥½æ‡‚äº›ã€‚

å½“æŒæ¡äº†è¿™ç§æ€ç»´æ–¹å¼ï¼Œä¸å±€é™äº Haskell æˆ–è€… Scalaï¼Œå…¶å®å¯ä»¥æ‰©å±•åˆ°ä»»ä½•è¯­è¨€çš„ç¼–ç¨‹ä¸­ï¼Œå³ä½¿æ˜¯æ²¡æœ‰ç±»å‹ç³»ç»Ÿçš„è¯­è¨€ï¼ŒJSï¼Œè¯´ä½ å‘¢ï¼Œä¸è¦çœ‹äººå®¶PHPã€‚

\begin{quote}
é‚£ä¹ˆï¼Œä¸ºå•¥è¦èŠ±é’±ä¹°ä¸€æœ¬ä¸æ˜¯æ­£è§„å‡ºç‰ˆç¤¾çš„ä¹¦ï¼Ÿ
\end{quote}

è®¸å¤šå¹´å‰ï¼Œå½“æˆ‘è¿˜æ˜¯å¹´å°‘ \sout{æœ‰ä¸º} æ— çŸ¥çš„æ—¶å€™ï¼Œæœ‰ä¸ªå¾ˆæ­£è§„çš„å‡ºç‰ˆç¤¾å«æˆ‘å†™è¿‡ä¸€æœ¬ä¹¦\footnote{\url{https://book.douban.com/subject/26883736/}}ã€‚

å½“æˆ‘å¬è¯´å†™ä¹¦æ˜¯æŒ‰å­—æ•°ç»™é’±çš„æ—¶å€™ï¼Œæˆ‘çš„ç¨‹åºå‘˜ä¸–ç•Œè§‚å´©å¡Œäº†é‚£ä¹ˆä¸€ä¼šã€‚
ä»€ä¹ˆ DRY\footnote{ä¸è¦é‡å¤(Don't Repeat Yourself) \url{https://en.wikipedia.org/wiki/Don\%27t\_repeat\_yourself}}ï¼Œä»€ä¹ˆ YAGNI\footnote{ä½ å¯èƒ½ä¸ä¼šéœ€è¦çš„(You Aren't Gonna Need It) \url{https://en.wikipedia.org/wiki/You\_aren\%27t\_gonna\_need\_it}}ï¼Œæˆ‘ç»Ÿç»Ÿéƒ½éœ€è¦ï¼Œè€Œä¸”èƒ½é‡å¤è¯´çš„æ¦‚å¿µç»å¯¹ä¸èƒ½ä¸€æ¬¡è¯´æ¸…æ¥šäº†ã€‚

é‚£æ®µæ—¶å…‰é‡Œ Emacs é‚£ç†Ÿç»ƒçš„å¿«æ·é”® \texttt{Ctrl y} ç®€ç›´å°±æ˜¯æˆ‘çš„äººæ°‘å¸å°é’æœºã€‚

äºæ˜¯æˆ‘ä¸œæ‹¼è¥¿å‡‘ï¼Œä»æˆ‘çš„åšå®¢æŠ„äº†å¥½å¤šå­—ã€‚ç»“æœè±†ç“£æ‰6.6åˆ†ï¼Œå±…ç„¶åªæœ‰å‡ ä¸ªäººè¯´æˆ‘æ˜¯æŠ„çš„ï¼Œ \sout{çœŸæ˜¯çš„ï¼Œè¯»ä¹¦äººï¼Œæ€ä¹ˆèƒ½è¯´æŠ„å‘¢ï¼Ÿ} æ˜¾ç„¶è¯»è€…éƒ½ä¸æ€ä¹ˆçœ‹æˆ‘çš„åšå®¢ã€‚

å†è¯´äº†, \sout{æˆ‘æŠ„ä½ å®¶ä¹¦äº†å—ï¼Ÿ} å…¶å®ä¹¦ä¸Šå¯æ¯”æˆ‘çš„åšå®¢ç²¾è‡´å¤šäº†ï¼Œçœ‹ï¼Œæˆ‘è¿˜åŠ äº†å¥½å¤šèŒèŒçš„æ’ç”»å‘¢ã€‚å­—ä¸ç®—é’±ï¼Œç”»ä¹Ÿå¤šå°‘ç®—ç‚¹å§ã€‚è€Œä¸”ï¼Œè€å­å†™åšå®¢çš„æ—¶é—´ä¸è¦é’±å—ï¼Ÿ

å‘µå‘µï¼Œç¡®å®ä¸è¦ã€‚

æ˜¾ç„¶ç¬¬ä¸€ç‰ˆè¿˜æ»é”€ï¼Œå‡ºç‰ˆç¤¾ä¹Ÿå†æ²¡è”ç³»æˆ‘ç¬¬äºŒç‰ˆçš„ç‰ˆç¨ğŸ’°çš„äº‹æƒ…ã€‚å°±è¿™ä¹ˆæŠ•å…¥ä¸€å¹´çš„æ—¶é—´åŠ å·¥ç²¾ç¾åšå®¢ä»¥è·å¾—åˆ©æ¶¦çš„å®Œç¾èµšé’±è®¡åˆ’ï¼Œç»“æœè¿˜ä¸å¦‚æˆ‘æ‰“å·¥ä¸€å¤©èµšçš„é’±å¤šã€‚

ä¸è¿‡ä¸å«ç¡®å®å¥½æ€ªæˆ‘ï¼Œç›®æ ‡è¯»è€…æ˜¯å‰ç«¯ï¼Œå†…å®¹æ˜¾ç„¶è¿‡äº \sout{è¶…å‰} ä¹å‘³äº†äº›ã€‚ä½†æ˜¯å–ä¸æ‰æˆ‘è¿˜çœŸæ˜¯ä¸¥é‡æ€€ç–‘æ˜¯å› ä¸ºå‡ºç‰ˆç¤¾è®¾è®¡çš„ä¹¦çš®å¤ªéš¾çœ‹ã€‚

ä½ çœ‹çœ‹é‚£æ©˜è‰²çš„å°é¢ï¼Œè·Ÿ Emmet\footnote{Emmet Brickowskiï¼šä¹é«˜å¤§ç”µå½±é‡Œçš„ä¸€åæ™®é€šå»ºç­‘å·¥äººã€‚å’¦ï¼Œæ™®é€šå·¥äººæ€ä¹ˆæœ‰wikiï¼Ÿæˆ‘éƒ½æ²¡æœ‰ \url{https://thelegomovie.fandom.com/wiki/Emmet\_Brickowski}} çš„å·¥æœä¸€ä¸ªé¢œè‰²ï¼Œä½ å¾ˆéš¾æƒ³è±¡è¿™ä¸æ˜¯ä¸€æœ¬å»ºç­‘å·¥ç¨‹å¸ˆçš„ä¹¦ã€‚
æˆ‘è¦æ˜¯åœ¨å›¾ä¹¦é¦†çœ‹è§è¿™æœ¬ä¹¦ï¼Œæˆ‘éƒ½æ€€ç–‘è‡ªå·±èµ°é”™äº†åˆ°äº†å»ºç­‘è£…æ½¢åŒºï¼Œå¯¹å•Šæˆ‘æœ¬æ¥æ˜¯æ¥å€Ÿå•¥ä¹¦æ¥ç€ï¼Ÿæˆ‘åœ¨å“ªï¼Ÿæˆ‘æ˜¯è°ï¼Ÿ

ä½ çœ‹ï¼Œè¿™ç§æ°´å¹³çš„å‰è¨€ï¼Œå‡ºç‰ˆç¤¾è‚¯å®šä¸ä¹æ„è¦è®©æˆ‘æ”¹ï¼Œä½†æ˜¯æˆ‘ä¹æ„å•Šï¼Œå•Šå“ˆå“ˆå“ˆå“ˆã€‚

å“¦ï¼Œå¯¹ï¼Œè¿˜æ²¡è¯´è¿™æœ¬ä¹¦æ˜¯å•¥æƒ…å†µå‘¢ã€‚å…¶å®è¿™æœ¬ä¹¦ï¼Œå®ƒâ€¦ä¹Ÿæ˜¯ä»æˆ‘çš„åŒååšå®¢\footnote{\url{https://blog.oyanglul.us/grokking-monad/part1}}æŠ„çš„â€¦

ä½†å…¶\ldots{}å®æˆ‘è¿˜æ˜¯æœ‰åŠ å…¥æ›´å¤šçš„å†…å®¹\footnote{æ¯”å¦‚ï¼Œä½ çœ‹ï¼Œåšå®¢é‡Œå°±æ²¡æœ‰è¿™ç¯‡å‰è¨€ã€‚}ï¼Œæ›´é‡è¦çš„æ˜¯è¿™ä¸ªè¶…æœ‰è®¾è®¡æ„Ÿçš„å°é¢ã€‚

ä½ æƒ³æƒ³ï¼Œå…­ç¾å…ƒ\footnote{å•Šï¼Œé‚£ä¸ºå•¥æ˜¯ä»¥ç¾å…ƒä¸ºå•ä½ï¼Ÿé‚£æ˜¯å› ä¸º Gumroad æ˜¯æŒ‰ç¾å…ƒç»™æˆ‘ç»“ç®—ï¼Œè¿™æ ·æˆ‘å¯ä»¥æŒ‘é€‰åˆé€‚çš„çš„æ—¶å€™æ¢ç®—æˆæ¾³å…ƒæˆ–è€…äººæ°‘å¸èŠ±ï¼Œå•Šå“ˆå“ˆå“ˆã€‚}å¯ä»¥ä¹°ä¸¤ç“¶å¯ä¹ï¼Œå…­ç¾å…ƒèƒ½ä¹°ä¸€æœ¬å„¿ç«¥æ¶‚è‰²ä¹¦ï¼Œå…­ç¾å…ƒèƒ½ä¹°äºŒåˆ†ä¹‹ä¸€é¡¿é¥­ã€‚
ä½ å°‘å–ä¸¤ç“¶å¯ä¹ï¼Œè®©ä½ å¨ƒå°‘æ¶‚ä¸€æœ¬æ¶‚è‰²ä¹¦ï¼Œä½ å°‘åƒåŠé¡¿é¥­ï¼Œä¹°äº†è¿™æœ¬ä¹¦ï¼ŒæŠŠé‡Œé¢çš„è¯æ±‡éƒ½èƒŒä¸‹æ¥ï¼Œåœ¨åŒäº‹é¢†å¯¼é¢å‰æ—¶ä¸æ—¶å†’å‡ºä¸€ä¸¤ä¸ªæ¥è£…é€¼ï¼Œå‡å€¼åŠ è–ªä¸æ˜¯æ¢¦ã€‚

æˆ–è€…ï¼Œæ‰“å°å‡ºæ¥ä½†åƒä¸‡ä¸è¦è£…è®¢ï¼ŒæŠ±åœ¨æ€€é‡Œä»å¥³ç¥ç”·ç¥é¢å‰èµ°è¿‡æ—¶ä¸å°å¿ƒæ’ä¸€ä¸‹é¡ºåŠ¿å¾€å¤©ä¸Šè¿™ä¹ˆä¸€æ’’ï¼Œå¥³ç¥ç”·ç¥åœ¨æ…Œä¹±ä¸­ä¸€èµ·å¸®ä½ æ¡åœ°ä¸Šæ•£è½çš„ä¹¦æ—¶ï¼Œè‚¯å®šä¼šæƒŠå¹ï¼šå“‡ï¼Œè¿™äººå¥½å‰å®³å±…ç„¶çŸ¥é“Monadæ˜¯ä»€ä¹ˆï¼Ÿ
å†åŠ ä¸Šåˆšæ‰æ’ä¸€ä¸‹å¼•èµ·çš„å¿ƒè·³åŠ é€Ÿï¼Œå¯¹ä½ çš„å¥½æ„Ÿæ²¹ç„¶è€Œç”Ÿã€‚

åªæ˜¯å°‘å–ä¸¤ç“¶å¯ä¹ï¼Œå°‘æ¶‚ä¸€æœ¬æ¶‚è‰²ä¹¦ï¼Œå°‘åƒåŠé¡¿é¥­çœä¸‹æ¥çš„å…­ç¾å…ƒ\footnote{ä½ çœ‹æˆ‘è¿™å†™ä¸Šæœ¬ä¹¦è½ä¸‹çš„ \texttt{Ctrl y} æ¯›ç—…ã€‚}ï¼Œå°±èƒ½æå‰åŠ©ä½ èµ°ä¸Šäººç”Ÿå·…å³°çš„æ„Ÿè§‰ï¼Œéš¾é“ä¸å…­å—ï¼Ÿ


\part{çŒ«è®º/Catergory Theory}
\label{sec:orga332599}

\begin{center}
\includegraphics[width=.9\linewidth]{./images/Cheshire_Cat.png}
\end{center} \footnote{\url{https://en.wikipedia.org/wiki/Cheshire\_Cat}}

\begin{quote}
`But I donâ€™t want to go among mad people,â€™ Alice remarked.

`Oh, you canâ€™t help that,â€™ said the Cat: `weâ€™re all mad here. Iâ€™m mad. Youâ€™re mad.â€™

`How do you know Iâ€™m mad?â€™ said Alice.
`You must be,â€™ said the Cat, `or you wouldnâ€™t have come here.â€™

Alice didnâ€™t think that proved it at all; however, she went on `And how do you know that youâ€™re mad?â€™

-- Alice's Adventures in Wonderland
\end{quote}

\begin{quote}
å•å­/Monadæ˜¯ä»€ä¹ˆ? ä½ ä¹Ÿä¸æ‡‚, æˆ‘ä¹Ÿä¸æ‡‚, æˆ‘ä»¬éƒ½ä¸æ‡‚.

è¯è¯´, æˆ‘åˆæ€ä¹ˆçŸ¥é“ä½ ä¸æ‡‚å‘¢?

å½“ç„¶ä¸æ‡‚, ä¸ç„¶, ä½ æ€ä¹ˆä¼šæ¥åˆ°è¿™é‡Œ?

æˆ‘åˆæ˜¯æ€ä¹ˆçŸ¥é“è‡ªå·±ä¸æ‡‚å‘¢?

å› ä¸ºï¼Œæˆ‘çŸ¥é“æ‡‚çš„äººæ˜¯ä»€ä¹ˆæ ·å­. æ˜¾ç„¶, æˆ‘ä¸æ˜¯.

å› ä¸ºï¼Œæ‡‚çš„äººä¸€å®šçŸ¥é“çŒ«è®º/Category Theory.
\end{quote}

è¿™ä¸€éƒ¨åˆ†ä¸»è¦æ˜¯çº¯ç†è®ºï¼Œè¿™é‡Œé¢æœ‰å¾ˆå¤šå¾ˆè£…çš„å•è¯ï¼Œæ¯”å¦‚ \emph{å•å­/Monad/ï¼Œå®ƒä»¬éƒ½æ˜¯ /æ–œä½“}
ï¼Œå°±ç®—ä¸€éæ²¡çœ‹æ‡‚\footnote{å¯ä»¥ç»§ç»­çœ‹ç¬¬äºŒéƒ¨åˆ†ï¼Œçœ‹å®Œæ¦‚å¿µæ˜¯å¦‚ä½•åœ¨ç°å®ä¸­å®ç°çš„ï¼Œå†å›æ¥çœ‹ä¸€éï¼Œä¼šæ„Ÿè§‰å¥½å¾ˆå¤šã€‚}ï¼ŒæŠŠè¿™äº›è¯èƒŒä¸‹æ¥ä¹Ÿè¶³å¤Ÿè£…å¥½é•¿ä¸€é˜µå­é€¼äº†ã€‚

è¿™é‡Œè¿˜æœ‰å¾ˆå¤šä»£ç , å®ƒä»¬éƒ½æˆå¯¹å‡ºç°, é€šå¸¸ç¬¬ä¸€æ®µæ˜¯ Haskell, ç¬¬äºŒæ®µæ˜¯ Scala 3.\footnote{ä¸ºä»€ä¹ˆç”¨ä¸¤ç§è¯­è¨€å‘¢ï¼Ÿç¬¬ä¸€ï¼š \sout{è¿™æ ·ä»£ç é‡ä¼šç¿»å€ï¼Œå¯ä»¥å‡‘ç¯‡å¹…å­—æ•°ã€‚} è¿™æ ·å¤§å®¶ä¼šç†Ÿæ‚‰å¤šç§è¯­è¨€å¯¹åŒä¸€æ¦‚å¿µçš„è¯ é‡Šï¼Œä»è€Œä¸¾ä¸€åä¸‰ã€‚
ç¬¬äºŒï¼šè¯»è€…å—ä¼—ä¼šå¤§ä¸€ç‚¹ï¼Œå› ä¸ºæ¯•ç«ŸHaskellçš„è¡¨è¿°æ¯”è¾ƒç®€æ´ï¼Œæœ‰å¯èƒ½å¾ˆå®¹æ˜“ç†è§£ï¼Œä½†æ˜¯è·Ÿä¸»æµè¯­è¨€çš„è¡¨è¾¾æ–¹å¼å¤§ä¸ºä¸åŒï¼Œä¹Ÿæœ‰å¯èƒ½å¾ˆéš¾é€‚åº”ï¼ŒåŠ ä¸Šè¡¨è¾¾æ–¹å¼æ›´ä¸ºå…·ä½“çš„ Scalaï¼Œä¾¿äºåŠ æ·±ç†è§£ã€‚}

\chapter{èŒƒç•´/Category}
\label{sec:orge141111}
\index{Catergory}
\index{èŒƒç•´}

å¯¹äºè®¡ç®—æœºç§‘å­¦çš„å­¦ç”Ÿï¼ŒèŒƒç•´å¹¶ä¸æ˜¯ä¸€ä¸ªæ–°çš„æ¦‚å¿µï¼Œåœ¨æœ¬ç§‘å¤§çº²é‡Œï¼Œå¤§å®¶éƒ½åº”è¯¥å­¦è¿‡ \emph{ç¦»æ•£æ•°å­¦ï¼ˆDiscrete Mathematicsï¼‰} ï¼Œå…¶ä¸­ä¼šè®²å¾ˆå¤š \emph{é›†åˆè®ºï¼ˆSet Theoryï¼‰} å›¾è®ºï¼ŒæŠ½è±¡ä»£æ•°çš„ä¸œè¥¿ã€‚
ç°åœ¨å›å¤´çœ‹çœ‹ï¼Œå…¶å®ä¹Ÿå°±æ˜¯é›†åˆè®ºå’ŒæŠ½è±¡ä»£æ•°çš„å†…å®¹ã€‚

æ‰€ä»¥ä¸‹é¢çš„æ¦‚å¿µéƒ½ç‚¹åˆ°ä¸ºæ­¢ï¼Œåªä¸ºè§£é‡Šå†™æˆä»£ç ä¼šé•¿ä»€ä¹ˆæ ·ã€‚

ä¸€ä¸ª \emph{èŒƒç•´/Category} åŒ…å«ä¸¤ä¸ªç©æ„:
\begin{itemize}
\item ä¸œè¥¿ \texttt{O} ï¼ˆObjectï¼‰
\item ä¸¤ä¸ªä¸œè¥¿çš„å…³ç³»ï¼Œç®­å¤´ \texttt{\textasciitilde{}>} ï¼ˆ \emph{æ€å°„/Morphism} ï¼‰
\end{itemize}

è¿˜å¿…é¡»å¸¦ä¸Šä¸€äº›å±æ€§:
\begin{itemize}
\item ä¸€å®šæœ‰ä¸€ä¸ªå« id çš„ç®­å¤´ï¼Œä¹Ÿå«åš 1
\item ç®­å¤´å¯ä»¥ \emph{ç»„åˆ} compose/
\end{itemize}

æ©, å°±æ˜¯è¿™ä¹ˆç®€å•!

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/category.png}
\caption{æœ‰ä¸œè¥¿ a, b, c å’Œç®­å¤´ f, g çš„ Categoryï¼Œå…¶ä¸­ f . g è¡¨ç¤º compose f å’Œ g}
\end{figure}


\begin{quote}
æ³¨æ„åˆ°ä¸ºä»€ä¹ˆæˆ‘ä¼šç®­å¤´ä»å³å¾€å·¦ï¼Œæ¥ç€çœ‹ä»£ç , ä½ ä¼šå‘ç°è¿™ä¸ªæ–¹å‘è·Ÿ compose çš„æ–¹å‘åˆšå¥½ä¸€è‡´!
\end{quote}

è¿™äº›ç©æ„å¯¹åº”åˆ° Haskell çš„ Typeclass å¤§è‡´å°±æ˜¯è¿™æ ·:

\lstset{language=haskell,label= ,caption={Category definition in Haskell},captionpos=b,numbers=none}
\begin{lstlisting}
class Category (c :: * -> * -> *) where
  id :: c a a
  (.) :: c y z -> c x y -> c x z
\end{lstlisting}

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° Haskell ä»£ç ï¼Œæ²¡æœ‰å…³ç³»ï¼Œè¯­æ³•çœŸçš„å¾ˆç®€å•ï¼š
\begin{itemize}
\item \texttt{class} å®šä¹‰äº†ä¸€ä¸ª TypeClassï¼Œ \texttt{Category} æ˜¯è¿™ä¸ª TypeClass çš„åå­—
\item Type class ç±»ä¼¼äºå®šä¹‰ç±»å‹çš„è§„èŒƒï¼Œè§„èŒƒä¸º \texttt{where} åé¢é‚£ä¸€å¨
\item ç±»å‹è§„èŒƒçš„å¯¹è±¡æ˜¯å‚æ•° \texttt{(c:: * -> * -> *)} ï¼Œ \texttt{::} åé¢æ˜¯cçš„ç±»å‹
\item c æ˜¯ \emph{higher kind} \texttt{* -> *} ï¼Œè·Ÿhigher order functionçš„å®šä¹‰å·®ä¸å¤šï¼Œå®ƒæ˜¯æ¥æ”¶ç±»å‹ï¼Œæ„é€ æ–°ç±»å‹çš„ç±»å‹ã€‚è¿™é‡Œçš„ c æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå†æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå°±å¯ä»¥è¿”å›ä¸ªç±»å‹ã€‚
\end{itemize}
\index{Kind}
\begin{itemize}
\item \texttt{id:: c a a} è¡¨ç¤º c èŒƒç•´ä¸Šçš„ a åˆ° a çš„ç®­å¤´
\item \texttt{.} çš„æ„æ€ c èŒƒç•´ä¸Šï¼Œå¦‚æœå–‚ä¸€ä¸ª y åˆ° z çš„ç®­å¤´ï¼Œå†å–‚ä¸€ä¸ª x åˆ° y çš„ç®­å¤´ï¼Œé‚£ä¹ˆå°±è¿”å› x åˆ° z çš„ç®­å¤´ã€‚
\end{itemize}

è€Œ Scala å¯ä»¥ç”¨ trait æ¥è¡¨ç¤ºè¿™ä¸ª typeclass:
\lstset{language=scala,label= ,caption={Category definition in Scala},captionpos=b,numbers=none}
\begin{lstlisting}
trait Category[C[_, _]] {
  def id[A]: C[A, A]
  def <<<(a: C[Y, Z], b: C[X, Y]): C[X, Z] 
}
\end{lstlisting}

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° Scala ä»£ç ï¼Œæ²¡å…³ç³»ï¼Œä»Haskellå¯ä»¥é£å¿«çš„åˆ‡æ¢è¿‡æ¥ï¼š
\begin{itemize}
\item \texttt{class} -> \texttt{trait}
\item[{=c}] * -> * -> *= -> \texttt{C[\_, \_]}
\item \texttt{::} -> \texttt{:}
\item å‡½æ•°åå‰åŠ  \texttt{def}
\end{itemize}

å¦å¤– compose åœ¨ haskell ä¸­ç›´æ¥æ˜¯å¥å· \texttt{.}

scala ä¸­ç”¨ä¹ æƒ¯ç”¨ \texttt{<<<} æˆ–è€… \texttt{compose}

æ€»ä¹‹ï¼Œæˆ‘ä»¬æ¥ç”¨æ–‡å­—å†è¯»ä¸€éä¸Šé¢è¿™äº›ä»£ç å°±äº†ç„¶äº†.

èŒƒç•´ C å…¶å®å°±åŒ…å«ï¼š
\begin{enumerate}
\item è¿”å› A å¯¹è±¡åˆ° A å¯¹è±¡çš„ id ç®­å¤´
\item å¯ä»¥ç»„åˆ Y å¯¹è±¡åˆ° Z å¯¹è±¡ å’Œ X å¯¹è±¡åˆ° Y å¯¹è±¡çš„ç®­å¤´ compose
\end{enumerate}

ç®€å•å§ï¼Ÿè¿˜æ²¡æœ‰é«˜æ•°æŠ½è±¡å‘¢ã€‚

\section{\emph{Hask}}
\label{sec:org2bda925}
Haskell ç±»å‹ç³»ç»ŸèŒƒç•´å«åš Haskã€‚
\index{Hask}

åœ¨ Hask èŒƒç•´ä¸Šï¼š

\begin{itemize}
\item ä¸œè¥¿å°±æ˜¯ç±»å‹
\item ç®­å¤´æ˜¯ç±»å‹çš„å˜æ¢ï¼Œå³ \texttt{->}
\item id å°±æ˜¯ id å‡½æ•°çš„ç±»å‹ \texttt{a -> a}
\item compose å½“ç„¶å°±æ˜¯å‡½æ•°ç»„åˆçš„ç±»å‹
\end{itemize}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type Hask = (->)
instance Category (Hask:: * -> * -> *) where
  id a = a
  (f . g) x = f (g x)
\end{lstlisting}

æˆ‘ä»¬çœ‹è§æ–°çš„å…³é”®å­— \texttt{instance} ï¼Œè¿™è¡¨ç¤º Hask æ˜¯ Type class Category çš„å®ä¾‹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹ä»»æ„Haskç±»å‹, é‚£ä¹ˆå°±èƒ½æ‰¾åˆ°å®ƒçš„ id å’Œ compose

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
given Category[=>[_, _]] {
  def id[A]: A => A = identity[A]
  def <<<[X, Y, Z](a: Y => Z, b: X => Y) = a compose b
}
\end{lstlisting}

Scala ä¸­, åªéœ€è¦ new è¿™ä¸ª trait å°±å¯ä»¥å®ç°è¿™ä¸ª typeclass

å…¶ä¸­: identity \texttt{Hask a a} å°±æ˜¯
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
(->) a a -- or
a -> a -- å› ä¸º -> æ˜¯ä¸­ç¼€æ„é€ å™¨
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
A => A
\end{lstlisting}
\section{\emph{Duel}}
\label{sec:org5481e33}
\index{Duel}
æ¯ä¸ª Category è¿˜æœ‰ä¸€ä¸ªé•œåƒï¼Œä»€ä¹ˆéƒ½ä¸€æ ·ï¼Œé™¤äº†ç®­å¤´æ˜¯åçš„ã€‚

\chapter{å‡½å­ / Functor}
\label{sec:orge4cfc5a}
\index{Functor}
\index{å‡½å­}
ä¸¤ä¸ªèŒƒç•´ä¸­é—´å¯ä»¥ç”¨å« Functor çš„ä¸œè¥¿æ¥è¿æ¥èµ·æ¥ï¼Œæ¯”å¦‚ä¸€ä¸ªä»èŒƒç•´ C åˆ°èŒƒç•´ D çš„å‡½å­ Tï¼Œæˆ‘ä»¬å¯ä»¥æ ‡
ä½œ \texttt{Functor C D T} ã€‚

\#+Functor Category
\begin{center}
\includegraphics[width=.9\linewidth]{images/functor.png}
\end{center}

æ‰€ä»¥å¤§éƒ¨åˆ†æŠŠå‡½å­æˆ–è€…å•å­æ¯”å–»æˆç›’å­å…¶å®åœ¨å®šä¹‰ä¸Šæ˜¯é”™çš„ï¼Œè™½ç„¶è¿™æ ·æ¯”å–»æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œåœ¨ä½¿ç”¨ä¸Šé—®é¢˜ä¹Ÿä¸å¤§ã€‚ä½†æ˜¯ï¼Œå‡½å­åªæ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„ç®­å¤´è€Œå·²ã€‚

\begin{itemize}
\item èŒƒç•´é—´ä¸œè¥¿çš„å‡½å­æ ‡è®°ä¸º \texttt{T(O)}
\item èŒƒç•´é—´ç®­å¤´çš„å‡½å­æ ‡è®°ä¸º \texttt{T(\textasciitilde{}>)}
\item ä»»ä½•èŒƒç•´ C ä¸Šå­˜åœ¨ä¸€ä¸ª T æŠŠæ‰€æœ‰çš„ O å’Œ \textasciitilde{}> éƒ½æ˜ å°„åˆ°è‡ªå·±ï¼Œæ ‡è®°ä¸ºå‡½å­ 1\textsubscript{C}
\begin{itemize}
\item 1\textsubscript{C}(O) = O
\item 1\textsubscript{C}(\textasciitilde{}>) = \textasciitilde{}>
\end{itemize}
\end{itemize}

\lstset{language=haskell,label= ,caption={å‡½å­çš„ Haskell å®šä¹‰},captionpos=b,numbers=none}
\begin{lstlisting}
class (Category c, Category d) => Functor c d t where
  fmap :: c a b -> d (t a) (t b)
\end{lstlisting}

\lstset{language=scala,label= ,caption={å‡½å­çš„ Scala å®šä¹‰},captionpos=b,numbers=none}
\begin{lstlisting}
trait Functor[C[_, _], D[_, _], T[_]]:
  def fmap[A, B](c: C[A, B]): D[T[A], T[B]]
\end{lstlisting}

\texttt{Functor c d t} è¿™è¡¨ç¤ºä»èŒƒç•´ c åˆ°èŒƒç•´ d çš„ä¸€ä¸ª Functor t

å¦‚æœæŠŠèŒƒç•´ c å’Œ d éƒ½é™åˆ¶åˆ° Hask èŒƒç•´ï¼š

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Functor (->) (->) t where
  fmap :: (->) a b -> (->) (t a) (t b)
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Functor[=>[_, _], =>[_, _], T[_]]:
 def fmap[A, B](c: =>[A, B]): =>[T[A], T[B]]
\end{lstlisting}

\texttt{->} æˆ–è€… \texttt{=>} å¯ä»¥å†™åœ¨ä¸­é—´çš„:

è¿™æ ·å°±ä¼šå˜æˆæˆ‘ä»¬ç†Ÿæ‚‰çš„å‡½å­å®šä¹‰ï¼š\footnote{è¿™é‡Œå¯ä»¥æŠŠ Functor çš„ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°æ¶ˆæ‰, å› ä¸ºå·²ç»çŸ¥é“æ˜¯åœ¨ Hask èŒƒç•´äº†}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Functor[T[_]]:
  def fmap[A, B](c: A => B): T[A] => T[B]
\end{lstlisting}

è€Œ \emph{è‡ªå‡½å­/endofunctor} å°±æ˜¯è¿™ç§è¿æ¥ç›¸åŒèŒƒç•´çš„ Functorï¼Œå› ä¸ºå®ƒä»èŒƒç•´ Hask åˆ°è¾¾åŒæ ·çš„èŒƒç•´ Haskã€‚
\index{endofunctor}
\index{è‡ªå‡½å­}

è¿™å›çœ‹ä»£ç å°±å¾ˆå®¹æ˜“å¯¹åº”ä¸Šå›¾å’Œæ¦‚å¿µäº†, è¿™é‡Œçš„è‡ªå‡½å­åªæ˜¯æ˜ å°„èŒƒç•´ \texttt{->} åˆ° \texttt{->}, ç®­å¤´å‡½æ•°é‚£ä¸ªç®­å¤´, ç±»å‹å´å˜æˆäº† \texttt{t a} ã€‚

è¿™é‡Œçš„ fmap å°±æ˜¯ T(\textasciitilde{}>)ï¼Œåœ¨ Hask èŒƒç•´ä¸Šï¼Œæ‰€ä»¥æ˜¯ T(->), è¿™ä¸ªç®­å¤´æ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿèƒ½è¡¨ç¤ºæˆ T(f) å¦‚æœ \texttt{f:: a -> b}

\chapter{Cat/çŒ«}
\label{sec:orgb23b488}

é€’å½’çš„, å½“æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªèŒƒç•´çœ‹æˆä¸€ä¸ªå¯¹è±¡ï¼Œå‡½å­çœ‹æˆç®­å¤´çš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆå¾—åˆ°äº†ä¸€ä¸ªæ–°çš„èŒƒç•´ï¼Œè¿™ç§å¯¹è±¡æ˜¯èŒƒç•´ç®­å¤´æ˜¯å‡½å­çš„èŒƒç•´æˆ‘ä»¬å«å®ƒ -- \emph{Cat/çŒ«} ã€‚

å·²ç»æ²¡/meowçš„åŠæ³•ç”¨è¯­è¨€æè¿°è¿™ä¹ˆé«˜ç»´åº¦çš„äº‹æƒ…äº†ï¼Œè¯·å›å¿†\label{org0420545}å¹¶æŠŠ C å’Œ D æƒ³è±¡æˆç‚¹ã€‚

\chapter{è‡ªç„¶å˜æ¢ / Natural Transformations \label{org45b15a0}}
\label{sec:org7bc7d92}

å‡½å­æ˜¯èŒƒç•´é—´çš„æ˜ å°„ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬ç°åœ¨åˆæŠŠ Cat èŒƒç•´çœ‹æˆæ˜¯å¯¹è±¡, é‚£ Cat èŒƒç•´ä¹‹é—´çš„ç®­å¤´ï¼Œå…¶å®å°±æ˜¯å‡½å­çš„å‡½å­ï¼Œ
åˆå‡ç»´åº¦äº†ï¼Œæˆ‘ä»¬æœ‰ä¸ªç‰¹æ®Šçš„åå­—ç»™å®ƒï¼Œå« \sout{å–µçš„å˜æ¢} \emph{è‡ªç„¶å˜æ¢/Natural Transformations} ã€‚
\index{Natural Transformations}
\index{è‡ªç„¶å˜æ¢}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/natrual-transformation.png}
\caption[Functor G \(\eta\)]{Functor F å’Œ G ä»¥åŠ F åˆ° G çš„è‡ªç„¶å˜åŒ–}
\end{figure}


èŒƒç•´ c ä¸Šçš„å‡½å­ f åˆ° g çš„è‡ªç„¶å˜åŒ–å°±å¯ä»¥è¡¨ç¤ºæˆï¼š
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type Nat c f g = c (f a) (g a)
\end{lstlisting}

Scala 3 çš„ rank n types\footnote{\url{https://blog.oyanglul.us/scala/dotty/en/rank-n-type} åˆ«æ€¥, åé¢é©¬ä¸Šè®²åˆ°} ä¹Ÿå¾ˆç®€æ´ï¼š
\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type Nat[C[_,_],F[_],G[_]] = [A] => C[F[A], G[A]]
\end{lstlisting}

å¦‚æœæ¢åˆ° Hask èŒƒç•´ä¸Šçš„è‡ªç„¶å˜åŒ–å°±å˜æˆäº†ï¼š

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type NatHask f g = f a -> g a
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type Nat[F[_],G[_]] = [A] => F[A] => G[A]
\end{lstlisting}

è¿™å°±æ˜¯ Scala ä¸­å¸¸è§çš„ FunctionK\footnote{\url{https://blog.oyanglul.us/scala/dotty/en/functionk}}ã€‚

æ­å–œä½ åˆ°è¾¾ Functor èŒƒç•´.

å½“ç„¶, è¦æˆä¸ºèŒƒç•´ï¼Œè¿˜æœ‰ä¸¤ä¸ªå±æ€§:
\begin{itemize}
\item id ä¸º f a åˆ° f a çš„è‡ªç„¶å˜æ¢
\item è‡ªç„¶å˜æ¢çš„ç»„åˆ
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{images/functor-category.png}
\end{center}

åˆ«ç€æ€¥, æˆ‘ä»¬æ¥æ¢³ç†ä¸€ä¸‹ï¼Œå¦‚æœå·²ç»ä¸çŸ¥é“å‡äº†å‡ ä¸ªç»´åº¦äº†ï¼Œæˆ‘ä»¬å‡è®¾ç±»å‹æ‰€åœ¨èŒƒç•´æ˜¯ç¬¬ä¸€ç»´åº¦
\begin{itemize}
\item ä¸€ç»´ï¼š Haskï¼Œ ä¸œè¥¿æ˜¯ç±»å‹ï¼Œç®­å¤´æ˜¯ ->
\item äºŒç»´ï¼š Catï¼Œ ä¸œè¥¿æ˜¯ Haskï¼Œ ç®­å¤´æ˜¯ Functor
\item ä¸‰ç»´ï¼š FunctorèŒƒç•´ï¼Œ ä¸œè¥¿æ˜¯Functorï¼Œ ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢
\end{itemize}

æ„Ÿè§‰åˆ°è¾¾ä¸‰ç»´å·²ç»æ˜¯æé™äº†ï¼Œå°¼ç›è¿˜æœ‰å®Œæ²¡å®Œäº†ï¼Œæ¯å‡ä¸€ä¸ªç»´åº¦è¿˜è¦èµ·è¿™ä¹ˆå¤šè£…é€¼çš„åå­—ï¼Œå†å‡ç»´åº¦è€å­å°±ç”»ä¸å‡ºæ¥äº†ã€‚

æ‰€ä»¥ï¼Œæ˜¯æ—¶å€™å¼•å…¥çœŸæ­£çš„æŠ€æœ¯äº† -- String Diagramã€‚

\chapter{String Diagram}
\label{sec:orga9ad355}

String Diagram\footnote{\url{https://www.youtube.com/watch?v=kiXjcqxVogE\&list=PL50ABC4792BD0A086\&index=5}} çš„æ¦‚å¿µå¾ˆç®€å•ï¼Œå°±æ˜¯ç‚¹å˜çº¿çº¿å˜ç‚¹ã€‚

è¿˜è®°å¾—å½“æœ‰äº†è‡ªç„¶å˜æ¢ä¹‹åï¼Œä¸‰ä¸ªç»´åº¦å·²ç»æ²¡æ³•è¡¨ç¤ºäº†ï¼Œé‚£åŸæ¥çš„ç‚¹å’Œçº¿éƒ½å‡ä¸€ç»´åº¦ï¼Œå˜æˆçº¿å’Œé¢ï¼Œè¿™æ ·ï¼Œå°±è…¾å‡ºä¸€ä¸ªç‚¹æ¥è¡¨ç¤ºè‡ªç„¶å˜æ¢äº†ã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-string-diagram.png}
\caption{String Diagramï¼šè‡ªç„¶å˜æ¢æ˜¯ç‚¹ï¼Œå‡½å­æ˜¯çº¿ï¼ŒèŒƒç•´æ˜¯é¢ï¼Œè‡ªç„¶å˜æ¢æ˜¯ç‚¹}
\end{figure}

ç»„åˆï¼ˆcomposeï¼‰çš„æ–¹å‘æ˜¯ä»å³å¾€å·¦ï¼Œä»ä¸‹åˆ°ä¸Šã€‚

é˜…è¯»èµ·æ¥ï¼Œä½ ä¼šå‘ç°å·¦å³å›¾ç»™å‡ºçš„ä¿¡æ¯æ˜¯å®Œå…¨ç­‰ä»·çš„ï¼š
\begin{enumerate}
\item èŒƒç•´ E é€šè¿‡ å‡½å­ D åˆ°èŒƒç•´ Dï¼ŒèŒƒç•´ D é€šè¿‡å‡½å­ F åˆ°èŒƒç•´ C
\item èŒƒç•´ E é€šè¿‡ å‡½å­ E åˆ°èŒƒç•´ C
\item F . G é€šè¿‡è‡ªç„¶å˜æ¢ \(\alpha\) åˆ° H
\end{enumerate}

\chapter{Adjunction Functor ä¼´éšå‡½å­}
\label{sec:orgda3fd5f}
\index{Adjunction Functor}
ä¼´éšå‡½å­æ˜¯èŒƒç•´ C å’Œ D ä¹‹é—´æœ‰æ¥æœ‰å›çš„å‡½å­ï¼Œä¸ºä»€ä¹ˆè¦ä»‹ç»è¿™ä¸ªï¼Œå› ä¸ºå®ƒç›´æ¥å¯ä»¥æ¨å‡ºå•å­ã€‚

è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä»€ä¹ˆå«æœ‰æ¥å›ã€‚

\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-adjunction-functor.png}
\end{center}

å…¶ä¸­ï¼š

\begin{itemize}
\item å›¾å³ï¼šä¸€ä¸ªèŒƒç•´ C å¯ä»¥é€šè¿‡å‡½å­ G åˆ°èŒƒç•´ Dï¼Œå†é€šè¿‡å‡½å­ F å›åˆ° Cï¼Œé‚£ä¹ˆ F å’Œ G å°±æ˜¯ä¼´éšå‡½å­ã€‚
\item å›¾ä¸­ï¼šèŒƒç•´ C é€šè¿‡å‡½å­ç»„åˆ F . G å›åˆ°èŒƒç•´ Cï¼Œå‡½å­ G . F é€šè¿‡è‡ªç„¶å˜æ¢ \(\eta\) åˆ°å‡½å­ 1\textsubscript{D}
\item å›¾å·¦ï¼šèŒƒç•´ D é€šè¿‡å‡½å­ç»„åˆ G . F å›åˆ°èŒƒç•´ Dï¼Œå‡½å­ 1\textsubscript{C} é€šè¿‡è‡ªç„¶å˜åŒ– \(\epsilon\) åˆ°å‡½å­ F . G
\end{itemize}

åŒæ—¶æ ¹æ®åŒæ„çš„å®šä¹‰ï¼ŒG ä¸ F æ˜¯ \emph{åŒæ„} çš„ã€‚
\index{isomorphic}
\index{åŒæ„}

åŒæ„æŒ‡çš„æ˜¯è‹¥æ˜¯æœ‰
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
f :: a -> b
f':: b -> a
\end{lstlisting}

é‚£ä¹ˆ f ä¸ f' åŒæ„ï¼Œå› ä¸º \texttt{f . f' = id = f' . f}

ä¼´éšå‡½å­çš„ F . G ç»„åˆæ˜¯ C èŒƒç•´çš„ id å‡½å­ \texttt{F . G = 1\_c}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-compose.png}
\caption{ä¼´éšå‡½å­çš„ä¸¤ä¸ªFunctorç»„åˆ, å·¦ä¾§è®°ä¸º F eta, å³ä¾§è®°ä¸º epsilon F}
\end{figure}

æ³¨æ„çœ‹åæ ‡ï¼Œè¯¥å›¾æ¨ªç€ç»„åˆè¡¨ç¤ºå‡½å­ç»„åˆï¼Œç«–ç€æ˜¯è‡ªç„¶å˜æ¢ç»´åº¦ï¼Œå› æ­¤æ˜¯è‡ªç„¶å˜æ¢çš„ç»„åˆã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-compose-nat.png}
\caption{eta . epsilon = F -> F}
\end{figure}

å½“ç»„åˆä¸¤ä¸ªè‡ªç„¶å˜æ¢ \(\eta\) . \(\epsilon\) å¾—åˆ°ä¸€ä¸ªå¼¯å¼¯æ›²æ›²çš„ F åˆ° F çš„çº¿æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æ‹½ç€ F çš„ä¸¤ç«¯ä¸€æ‹‰ï¼Œå°±å¾—åˆ°äº†ç›´çš„ F çº¿ã€‚

String Diagram ç¥å¥‡çš„åœ°æ–¹æ˜¯æ‰€æœ‰çº¿éƒ½å¯ä»¥æ‹‰ä¸Šä¸‹ä¸¤ç«¯ï¼Œå› ä¸ºçº¿ä¸ç®¡æ˜¯å¼¯çš„è¿˜æ˜¯ç›´çš„ï¼ŒåŒ…å«çš„ä¿¡æ¯å¹¶ä¸ä¼šå‘ç”Ÿå˜åŒ–ã€‚
è¿™ä¸ªæŠ€å·§éå¸¸æœ‰ç”¨ï¼Œåœ¨ä¹‹åçš„å•å­æ¨å¯¼è¿˜éœ€è¦ç”¨åˆ°ã€‚

\chapter{ä»ä¼´éšå‡½å­åˆ° å•å­/Monad}
\label{sec:orga815b6c}
æœ‰äº†ä¼´éšå‡½å­ï¼Œå¾ˆå®¹æ˜“æ¨å‡ºå•å­ï¼Œè®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯å•å­ï¼š

\begin{itemize}
\item é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªè‡ªå‡½å­ï¼ˆendofunctorï¼‰ T
\item æœ‰ä¸€ä¸ªä» i\textsubscript{c} åˆ° T çš„è‡ªç„¶å˜åŒ– \(\eta\) (eta)
\item æœ‰ä¸€ä¸ªä» T\textsuperscript{2} åˆ° T çš„è‡ªç„¶å˜åŒ– \(\mu\) (mu)
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-monad-properties.png}
\end{center}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Endofunctor c t => Monad c t where
  eta :: c a (t a)
  mu  :: c (t (t a)) (t a)
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Monad[C[_, _], T[_]]] extends Endofunctor[C, T]:
  def eta[A]: C[A, T[A]]
  def mu[A]: C[T[T[A]], T[A]]
\end{lstlisting}
åŒæ ·ï¼ŒæŠŠ c = Hask æ›¿æ¢è¿›å»ï¼Œå°±å¾—åˆ°æ›´ç±»ä¼¼æˆ‘ä»¬ Haskell ä¸­ Monad çš„å®šä¹‰
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Monad[M[_]] extends Endofunctor[M]:
  def eta[A]: A => M[A]
  def mu[A]: M[M[A]] => M[A]
\end{lstlisting}
è¦æ¨å‡ºå•å­çš„ \(\eta\) å˜æ¢ï¼Œåªéœ€è¦è®© FG = Tã€‚å¯ä»¥è„‘è¡¥ä¸€ä¸‹ï¼Œå› ä¸ºæ˜¯è‡ªå‡½å­ï¼Œå› æ­¤å¯ä»¥æŠ¹æ‰ Dï¼Œ
æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ D è¿™ä¸€å—é¢è¢«æ‹¿æ‰ä¹‹åï¼Œçº¿ F å’Œçº¿ G æ˜¯ä¸æ˜¯å°±è´´åœ¨ä¸€èµ·äº†å‘¢ï¼Ÿä¸¤æ ¹è´´ç€çš„çº¿ï¼Œä¸å°±æ˜¯ä¸€æ ¹çº¿å—ï¼Ÿ

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-to-monad-eta.png}
\caption{ä¼´éšå‡½å­çš„ epsilon å°±æ˜¯å•å­çš„ eta}
\end{figure}

åŒæ ·çš„ï¼Œå½“ FG = T, ä¹Ÿå°±æ˜¯æŠŠ D è¿™é™€ç»™æŠ¹æ‰ï¼ŒF å’Œ G å°±å˜æˆäº† Tã€‚
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-to-monad-mu.png}
\caption{ä¼´éšå‡½å­çš„ F eta G æ˜¯å‡½å­çš„ mu}
\end{figure}

\section{ä¸‰è§’ç­‰å¼}
\label{sec:org2d6499d}

ä¸‰è§’ç­‰å¼æ˜¯æŒ‡ \(\mu\) . T \(\eta\) = T = \(\mu\) . \(\eta\) T

è¦æ¨å‡ºä¸‰è§’ç­‰å¼åªéœ€è¦ç»„åˆ F \(\eta\) G å’Œ \(\epsilon\) F G
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-adjunction-functor-triangle.png}
\caption{F eta G  . epsilon F G = F G}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-monad-triangle.png}
\caption{F eta G  . epsilon F G= F G å¯¹åº”åˆ°Monadå°±æ˜¯ mu . eta T = T}
\end{figure}

æ¢åˆ°ä»£ç ä¸Šæ¥è¯´
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
(mu . eta) m = m
\end{lstlisting}

åŒæ ·çš„ï¼Œå·¦å³ç¿»è½¬ä¹Ÿæˆç«‹

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-adjunction-functor-triangle-reverse.png}
\caption{F eta G . F G epsilon = F G}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-monad-triangle-reverse.png}
\caption{F eta G . F G epsilon = F G å¯¹åº”åˆ° Monadæ˜¯ mu . T eta = T}
\end{figure}
T \(\eta\) å°±æ˜¯ fmap eta
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
(mu . fmap eta) m = m
\end{lstlisting}

å¦‚æœæŠŠ \texttt{mu . fmap} å†™æˆ \texttt{>>=} , å°±æœ‰äº†

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
m >>= eta = m
\end{lstlisting}

\section{ç»“åˆå¾‹}
\label{sec:org3ad2f67}

å•å­å¦ä¸€å¤§å®šå¾‹æ˜¯ç»“åˆå¾‹ï¼Œè®©æˆ‘ä»¬ä»ä¼´éšå‡½å­æ¨èµ·

å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰å‡½å­ F \(\eta\) G å’Œ å‡½å­ F \(\eta\) G F G, compose èµ·æ¥ä¼šå˜æˆ  F \(\eta\) G . F \(\eta\) G F G
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-1.png}
\end{center}

ç”¨ F G = T ï¼Œ F \(\eta\) G = \(\mu\) ä»£æ¢é‚£ä¹ˆå°±å¾—åˆ°äº†å•å­çš„ \(\mu\) . \(\mu\) T
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-2.png}
\end{center}

å½“ç»„åˆ F \(\eta\) G å’Œ F G F \(\mu\) G åï¼Œä¼šå¾—åˆ°ä¸€ä¸ªé•œåƒçš„å›¾
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-3.png}
\end{center}

å¯¹åº”åˆ°å•å­çš„ \(\mu\) . T \(\mu\)

ç»“åˆå¾‹æ˜¯è¯´ \(\mu\) . \(\mu\) T = \(\mu\) . T \(\mu\) , å³å›¾å·¦å³ç¿»è½¬ç»“æœæ˜¯ç›¸ç­‰çš„ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿçœ‹å•å­çš„String Diagram ä¸å¤ªå¥½çœ‹å‡ºæ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ä¼´éšå‡½å­

å¦‚æœæŠŠå·¦å›¾çš„å·¦è¾¹çš„ \(\mu\) å¾€ä¸ŠæŒªä¸€ç‚¹ï¼Œå³è¾¹çš„ \(\mu\) å¾€ä¸‹æŒªä¸€ç‚¹ï¼Œæ˜¯ä¸æ˜¯è·Ÿå³å›¾å°±ä¸€æ ·äº†
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-4.png}
\end{center}

ç»“åˆå¾‹åæ˜ åˆ°ä»£ç ä¸­å°±æ˜¯
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
mu . fmap mu = mu . mu
\end{lstlisting}

ä»£ç å¾ˆéš¾çœ‹å‡ºç»“åˆåœ¨å“ªé‡Œï¼Œå› ä¸ºæ­£å¸¸çš„ç»“åˆå¾‹åº”è¯¥æ˜¯è¿™æ ·çš„ (1+2)+3 = 1+(2+3)ï¼Œä½†æ˜¯ä¸æƒ³åŠ æ³•çš„ç»´åº¦ä¸ä¸€æ ·ï¼Œè¿™é‡Œè¯´çš„æ˜¯è‡ªç„¶å˜æ¢ç»´åº¦çš„ç»“åˆï¼Œå¯ä»¥é€šè¿‡String Diagram å¾ˆæ¸…æ¥šçš„çœ‹è§ç»“åˆçš„è¿‡ç¨‹ï¼Œå³ \(\mu\) å·¦è¾¹çš„ä¸¤ä¸ªTå’Œå…ˆ \(\mu\) å³è¾¹ä¸¤ä¸ª T æ˜¯ç›¸ç­‰çš„ã€‚

\chapter{Yoneda lemma / \sout{ç±³ç”°å…±} ç±³ç”°å¼•ç†}
\label{sec:orga68f251}
\index{ç±³ç”°å¼•ç†}
\index{Yoneda Lemma}

ç±³ç”°å¼•ç†æ˜¯è¯´æ‰€æœ‰çš„å‡½å­ \texttt{f a} ä¸€å®šå­˜åœ¨ä¸¤ä¸ªå˜æ¢ \texttt{embed} å’Œ \texttt{unembed=ï¼Œä½¿å¾— =f a} å’Œ \texttt{(a -> b) -> F b} åŒæ„ã€‚

è¦å† Haskell ä¸­åšåˆ°è¿™ä¸€æ³¢æ“ä½œéœ€è¦å…ˆæ‰“å¼€ \texttt{RankNTypes} çš„ç¼–è¯‘å™¨å¼€å…³ï¼š

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
{-# LANGUAGE RankNTypes #-}

embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
embed x f = fmap f x

unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
unembed f = f id
\end{lstlisting}

Scala 3 ä¸éœ€è¦æ’ä»¶æˆ–è€…å¼€å…³\footnote{\url{https://blog.oyanglul.us/scala/dotty/rank-n-type}}ï¼Œå¦‚æœæ˜¯ Scala 2 å¯ä»¥ç”¨ \texttt{apply} æ¥æ¨¡æ‹Ÿ. æ¯”å¦‚ Cats ä¸­ \href{https://typelevel.org/cats/datatypes/functionk.html}{FunctionK(\textasciitilde{}>)}ã€‚
\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type ~>[F[_],G[_]] = [A] => F[A] => G[A]
def embed[F[_], A](fa: F[A])(using F: Functor[F]) =
  [B] => (fn: A=>B) => f.fmap(fn)(fa)
def unembed[F[_]](fn: [B] => (A => B) => F[B]): F[A] =
  fn(identity)
\end{lstlisting}

\texttt{embed} å¯ä»¥æŠŠ \texttt{f a} å˜æˆ \texttt{(a -> b) -> f b}

\texttt{unembed} æ˜¯åè¿‡æ¥ï¼Œ \texttt{(a -> b) -> f b} å˜æˆ \texttt{f a}

ä¸Šä¸ªå›¾å¯èƒ½å°±æ˜ç™½äº†ï¼š
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/yoneda-lemma.png}
\caption{ä¹Ÿå°±æ˜¯è¯´ï¼Œå›¾ä¸­æ— è®ºçŸ¥é“a->b å†åŠ ä¸Šä»»æ„ä¸€ä¸ª F xï¼Œéƒ½èƒ½æ¨å‡ºå¦å¤–ä¸€ä¸ª F}
\end{figure}

è¿™ä¸ªå¼•ç†çœ‹ä¼¼å¾ˆå·§å¦™ï¼Œç‰¹åˆ«æ˜¯ç”¨ id çš„è¿™ä¸ªéƒ¨åˆ†ï¼Œä½†æ˜¯æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿ

å¦‚æœç€æ€¥å¯ä»¥è·³åˆ° Free Monad/è‡ªç”±å•å­ éƒ¨åˆ†ï¼Œä½ ä¼šå‘ç°ä»–æ˜¯è‡ªç”±å•å­çš„åŸºç¡€ã€‚è€Œä¸”å¦‚æœå†å¾€åä¼šä»‹ç»çš„å®‡å®™æœ¬åŸå·¦çœ‹å’Œå³çœ‹ï¼Œæ›´ä¼šå‘ç°å…¶ä¸­å¾—ç²¾å¦™ç›¸ä¼¼ä¹‹å¤„ã€‚

\section{Rank N Type}
\label{sec:orgbc21743}
\index{Arbitrary-rank polymorphism}
\index{Rank N Type}

å‰é¢è¯´å¥½çš„è¦è§£é‡Š Rank N Typeï¼Œè¿™é‡Œèµ¶å¿«è¡¥å……ä¸€ä¸‹ï¼Œä¸ç„¶ç­‰ä¼šæˆ‘å°±å¿˜äº†ã€‚

Haskell ä¸­å¯ä»¥ä¸ç”¨å£°æ˜ç±»å‹, ä½†æ˜¯å…¶å®æ˜¯çœç•¥æ‰ universally quantified \texttt{forall}, å¦‚æœæŠŠ forall å…¨éƒ¨åŠ å›æ¥,
å°±æ˜äº†å¾ˆå¤š:

\begin{itemize}
\item Monomorphic Rank 0 / 0çº§å•æ€\footnote{ä¹Ÿå°±ä¸æ˜¯ä¸å˜æ€}: t
\item Polymorphic Rank 1 / 1çº§ \sout{å˜æ€} å¤šæ€: forall a b. a -> b
\item Polymorphic Rank 2 / 2çº§å¤šæ€: forall c. (forall a b. a -> b) -> c
\item Polymorphic Rank 3 / 3çº§å¤šæ€: forall d . (forall c . (forall a b . a -> b) -> c) -> d
\end{itemize}

çœ‹ rank å‡ åªè¦æ•°å·¦è¾¹ forall çš„ä¸ªæ•°å°±å¥½äº†.

ä¸€çº§å¤šæ€åªé”å®šä¸€æ¬¡ç±»å‹ a å’Œ b

äºŒçº§å¤šæ€å¯ä»¥åˆ†ä¸¤æ¬¡ç¡®å®šç±»å‹, ç¬¬ä¸€æ¬¡ç¡®å®š c, ç¬¬äºŒæ¬¡ç¡®å®š a b

ä¸‰çº§å¤šå°åˆ†ä¸‰æ¬¡: ç¬¬ä¸€æ¬¡ d, ç¬¬äºŒæ¬¡ c, ç¬¬ä¸‰æ¬¡ a b

æ¯”å¦‚:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
rank2 :: forall b c . b -> c -> (forall a. a -> a) -> (b, c)
rank2 b c f = (f b, f c)

rank2 True 'a' id
-- (True, 'a')
\end{lstlisting}

\begin{itemize}
\item \texttt{f} åœ¨ \texttt{f True} æ—¶ç±»å‹ \texttt{Boolean -> Boolean} æ˜¯ç¬¦åˆ \texttt{forall a. a->a} çš„
\item ä¸æ­¤åŒæ—¶ \texttt{f 'a'} æ—¶ç±»å‹ç¡®å®æ˜¯ \texttt{Char -> Char} ä½†ä¹Ÿç¬¦åˆ \texttt{forall a. a->a}
\end{itemize}

çœ‹ Scala çš„æ›´ç®€å•ï¼Œå› ä¸º Scala ä¸èƒ½çœå» universally quantifiedï¼Œåªéœ€è¦æ•°æ–¹æ‹¬å·å³å¯ã€‚
æœ€å·¦è¾¹ \texttt{[B, C]} æ˜¯ rank1ï¼Œ \texttt{fn} çš„ç±»å‹é‡Œçš„ \texttt{[A]} æ˜¯ rank2ã€‚

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def rank2[B, C](b: B, c: C)(fn: [A] => A => A): (B, C) =
  (fn(b), fn(c))

rank2(true, 'a')([A] => (a: A) => A)
\end{lstlisting}

å¦‚æœä¸ç”¨rank2 è€Œæ˜¯åªæœ‰ rank1 ç±»å‹ç³»ç»Ÿå°±æ‡µé€¼äº†:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
rank1 :: forall a b c . b -> c -> (a -> a) -> (b, c)
rank1 b c f = (f b, f c)
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def rank1[A, B, C](b: B, c: C)(fn: A => A): (B, C) =
  (fn(b), fn(c))
\end{lstlisting}

f åœ¨ \texttt{f True} æ˜¯ç¡®å®š a æ˜¯ Booleanï¼Œåœ¨rank1å¤šæ€æ˜¯æ—¶å°±ç¡®å®šäº† \texttt{a -> a} çš„ç±»å‹ä¸€å®šæ˜¯ \texttt{Boolean -> Boolean} ï¼Œ
ç„¶åå½“çœ‹åˆ° \texttt{f 'a'} æ—¶ç±»å‹å°±æŒ‚äº†ï¼Œå› ä¸º \texttt{'a'} ä¸æ˜¯ \texttt{Boolean} ã€‚

\chapter{\emph{Kleisli Catergory}}
\label{sec:org97818f4}
\index{Kleisi Catergory}

å‡½å­/Functor çš„èŒƒç•´å«åš å‡½å­èŒƒç•´/Functor Catergory, è‡ªç„¶å˜æ¢æ˜¯å…¶ç®­å¤´ã€‚é‚£å•å­/Monadä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªèŒƒç•´å—?\footnote{å½“ç„¶, å•å­æ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥æ˜¯è‡ªå‡½å­èŒƒç•´}

æ˜¯çš„, è¿™ä¸ªèŒƒç•´åå­—å«åš \sout{å•å­èŒƒç•´}\footnote{æ€ä¹ˆè¯´ä¹Ÿæ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒ,æ€ä¹ˆå¯ä»¥å«çš„è¿™ä¹ˆlowè¿™ä¹ˆç›´æ¥} å¯è±æ–¯åˆ©èŒƒç•´/Kleisli Catergory\footnote{è¿™ä¸ªæ˜¯æˆ‘çç¿»è¯‘çš„, ä½†æ˜¯è¯»å‡ºæ¥å°±æ˜¯è¿™ä¹ˆä¸ªæ„æ€, çœŸçš„, ä¸éª—ä½ , ç…§è¿™ä¹ˆè¯»ç»å¯¹è£…çš„ä¸€æ‰‹å¥½é€¼, ä¸ä¼šè¢«å˜²ç¬‘çš„}ï¼Œé‚£ä¹ˆ Kleisli çš„ç®­å¤´æ˜¯ä»€ä¹ˆï¼Ÿ

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/kleisli.png}
\caption[\sout{å¼¯}]{æ³¨æ„è§‚å¯Ÿå¤§ç«ç®­ <=< çš„è½¨è¿¹, ä¸çŸ¥é“dotä¸ºä»€ä¹ˆä¼šæŠŠè¿™æ ¹çº¿æè¿™ä¹ˆåˆå¼¯åˆéªšçš„, å’Œ >>= ã€‚æ‰€ä»¥ Kleisli å…¶å®å°±æ˜¯æ–œç€èµ°çš„ä¸€ä¸ªèŒƒç•´ï¼Œä½†æ˜¯ >>= æŠŠå®ƒç¡¬ç”Ÿç”Ÿæ° \sout{å¼¯} ç›´äº†ã€‚}
\end{figure}

æˆ‘ä»¬çœ‹å®šä¹‰ï¼ŒKleisli Categoryï¼š

\begin{enumerate}
\item ç®­å¤´æ˜¯ Kleisli ç®­å¤´ \texttt{a -> T b}
\item ä¸œè¥¿å°±æ˜¯cèŒƒç•´ä¸­çš„ä¸œè¥¿. å› ä¸º a å’Œ b éƒ½æ˜¯ c èŒƒç•´ä¸Šçš„ï¼Œ ç”±äºTæ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ T b ä¹Ÿæ˜¯ c èŒƒç•´çš„
\end{enumerate}

çœ‹åˆ°å›¾ä¸Šçš„ T f/ fmap f å’Œ \(\mu\) äº†æ²¡ï¼Ÿ\footnote{(æ•²é»‘æ¿) å°±æ˜¯ç´«è‰²é‚£æ ¹å˜›!}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
f :: b -> T c
fmap f :: T b -> T T c
mu :: T T c -> T c
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def f[T[_], B, C](b: B): T[C]
def fmap[T[_], B, C](f: B => C)(tb: T[B]): T[T[C]]
def mu[T[_], C](ttc: T[T[C]]): T[C]
\end{lstlisting}

ç´«è‰²çš„ç®­å¤´ \texttt{T f} \footnote{å³ fmap f} å’Œç´«è‰²çš„è™šçº¿ç®­å¤´ \(\mu\) è¿èµ·æ¥å°±æ˜¯ \texttt{T f'}, é‚£ä¹ˆæœ€å‡ºåçš„ bind \texttt{>>=} ç¬¦å·ç»ˆäºå‡ºæ¥äº†:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
tb >>= f = (mu . fmap f) tb
\end{lstlisting}

Scala ä¸­é€šå¸¸å«ä½œ \texttt{flatMap} ï¼Œä½†å¦‚æœä½ ç”¨ Cats ä¹Ÿæ˜¯å¯ä»¥ç”¨ \texttt{>>=} çš„ã€‚
\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def flatMap[T[_], B, C](f: B => T[C])(tb: T[B]): T[C] = (mu compose fmap(f))(tb)
\end{lstlisting}

ä¸‹é¢è¿™ä¸ªå¤§ç«ç®­ \texttt{<=<} å¯ä»¥æŠŠè“è‰²ç®­å¤´ç»„åˆèµ·æ¥.
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
(f <=< g) = mu . T f . g = mu . fmap f . g
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def <=<[T[_], A, B, C](f: B => T[C])(g: A => T[B]): A => T[C] =
  mu compose fmap(f) compose g
\end{lstlisting}

å› æ­¤å¤§ç«ç®­å°±æ˜¯ Kleisli èŒƒç•´çš„ \texttt{compose}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
(<=<) :: Monad T => (b -> T c) -> (a -> T b) -> (a -> T c)
\end{lstlisting}

\chapter{Summary}
\label{sec:orgd5dd7d5}
ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›åŠç‚¸å¤©/ä¹±ä¸ƒå…«ç³Ÿçš„æ¦‚å¿µåŠé€€ï¼Œ
é‚£ä¹ˆä½ è¿™ä»½å¦‚æ­¤å¼ºå¤§å¾—ä¿¡å¿µæ„Ÿï¼Œå…¶å®åˆ°åé¢ä¸¤éƒ¨åˆ†ä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆç”¨ã€‚
å› ä¸ºï¼Œæ¥ä¸‹æ¥çš„ä¾‹å­ä¼šå¾ˆç®€å•ï¼Œæˆ‘ä»¬è¦é€šè¿‡ç¼–ç¨‹ä¸­å¸¸é‡åˆ°çš„åœºæ™¯çœ‹çœ‹ç†è®ºåˆ°åº•è¯¥å¦‚ä½•å¾—åˆ°å®è·µï¼Ÿ

\part{é£Ÿç”¨çŒ«å‘¢/Practical Monads}
\label{sec:orgee41947}

\begin{center}
\includegraphics[width=.9\linewidth]{./images/Alice_through_the_looking_glass.jpg}
\end{center}

\chapter{Functor é£Ÿç”¨å‡½å­å®šä¹‰}
\label{sec:org5fdf827}
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)
  (<$) :: a -> f b -> f a
  (<$) =  fmap . const
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Functor[F[_]]:
  def fmap[A, B](fn: A => B): F[A] => F[B]
  extension [B](fb: F[B])
    def <$(a: A)(fb: F[B]): F[A] = fmap(const(a))
\end{lstlisting}

\chapter{Applicative}
\label{sec:orgd390c88}
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Functor f => Applicative f where
  pure       :: a -> f a
  (<*>)      :: f (a -> b) -> f a -> f B
  liftA2     :: (a -> b -> c) -> f a -> f b -> f c
  liftA2 f x = (<*>) (fmap f x)
  (*>)       :: f a -> f b -> f b
  a1 *> a2   = (id <$ a1) <*> a2
  (<*)       :: f a -> f b -> f a
  (<*)       = liftA2 const
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Applicative[F[_]] extends Functor[F]:
  def pure[A](a: A): F[A]
  def ap[A, B](fab: F[A=>B]): F[A] => F[B]
  def liftA2[A, B, C](f: A => B => C): F[A] => F[B] => F[C] = (x: F[A]) =>
    ap(fmap(f)(x))
  extension [A](fa: F[A])
    def *>(fb: F[B]) = (identity <$ fa) <*> fb
    def <*(fb: F[B]) = liftA2(const)
  extension [A, B](fab: F[A => B])
    def <*>(fa: F[B]) = ap(fab)(fa)
\end{lstlisting}

\chapter{Monad}
\label{sec:org3cf4122}
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Applicative m => Monad m where
 (>>=)       :: forall a b. m a -> (a -> m b) -> m b
 (>>)        :: forall a b. m a -> m b -> m b
 m >> k      = m >>= \_ -> k
 return      :: a -> m a
 return      = pure
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
trait Monad[M[_]] extends Applicative[M] {
  def flatMap[A, B](ma: M[A])(f: A => M[B]): M[B]
  extension [A, B](ma: M[A])
    def >>(mb: M[B]): MB = flatMap(ma)((_: A) => mb)
}
\end{lstlisting}
\chapter{Identity æœ¬èº«å°±æœ‰}
\label{sec:org4276978}

æœ¬èº«å°±æœ‰å•å­/ Identity Monad\footnote{ä»æ¥æ²¡è§è¿‡æœ‰äººç»™è¿™äº›æ•°æ®ç±»å‹æŒ‰è¿‡ä¸­æ–‡åå­—, ä¸ç„¶æˆ‘æ¥, è¿™æ ·ä¹Ÿæ›´å¥½çš„ä½“ä¼šè¿™äº›æ•°æ®ç±»å‹çš„æ„å›¾.} å¯èƒ½æ˜¯æœ€ç®€å•çš„å•å­äº†ã€‚æœ¬èº«ä¸åŒ…å«ä»»ä½•è®¡ç®—, ä¸”åªæœ‰ä¸€ä¸ªæ„é€ å™¨:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype Identity a = Identity { runIdentity :: a }
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
case class Identity[A](run: A)
\end{lstlisting}

\begin{itemize}
\item è¿™é‡Œå–å \texttt{Identity} å« \textbf{æœ¬èº«å°±æœ‰} ï¼Œæ‰€ä»¥ \texttt{Identity a} å°±æ˜¯ \textbf{æœ¬èº«å°±æœ‰ a}
\item è¿™é‡Œä½¿ç”¨ \texttt{newtype} è€Œä¸æ˜¯ \texttt{data} æ˜¯å› ä¸º \texttt{Identity} ä¸ \texttt{runIdentity} æ˜¯ \emph{åŒæ„} çš„\footnote{è§ \href{part1.org}{ç¬¬ä¸€éƒ¨åˆ† ä¼´éšå‡½å­}}.
\end{itemize}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Identity :: a -> Identity a
runIdentity :: Identity a -> a
\end{lstlisting}

ä½ çœ‹ \texttt{runIdentity . Identity = id} ï¼Œæ‰€ä»¥ä»–ä»¬æ˜¯åŒæ„çš„ã€‚

å·¦è¾¹çš„ \texttt{Identity} æ˜¯ \emph{ç±»å‹æ„é€ å™¨}\footnote{ä¹Ÿå°±æ˜¯ Kind * -> *, å› ä¸ºå®ƒéå¸¸çš„ nice, ä¸€å®šè¦ç­‰åˆ° a æ‰å‡ºç±»å‹}, æ¥æ”¶ç±»å‹ \texttt{a} è¿”å› \texttt{Identity a} ç±»å‹ã€‚

å¦‚æœ \texttt{a} æ˜¯ \texttt{Int}, é‚£ä¹ˆå°±å¾—åˆ°ä¸€ä¸ª \texttt{Identity Int} ç±»å‹ã€‚

å³è¾¹çš„ \texttt{Identity} æ˜¯æ•°æ®æ„é€ å™¨ï¼Œä¹Ÿå°±æ˜¯æ„é€ å€¼ï¼Œæ¯”å¦‚ \texttt{Identity 1} ä¼šæ„é€ å‡ºä¸€ä¸ªå€¼ï¼Œå…¶ç±»å‹ä¸º \texttt{Identity Int} ã€‚

å¤§æ‹¬å·æ¯”è¾ƒè¯¡å¼‚ï¼Œå¯ä»¥æƒ³è±¡æˆç»™ \texttt{a} è‡ªåŠ¨ç”Ÿæˆäº†ä¸€ä¸ª \texttt{Identity a -> a} çš„å‡½æ•°ï¼Œ æ¯”å¦‚:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
runIdentity (Identity 1)
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Identity(1).run
\end{lstlisting}

ä¼šè¿”å› 1

\textbf{æœ¬èº«å°±æœ‰} å¯ä»¥å®ç° Functor å’Œ Monadï¼Œå°±å¾—åˆ° Identity å‡½å­ å’Œ Identity å•å­ã€‚

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Functor Identity where
  fmap f (Identity a) = Identity (f a)

instance Monad Identity where
  return a = Identity a
  Identity a >>= f = f a
\end{lstlisting}

è€Œ Scala åˆ™ç”¨ \texttt{given} æ¥å®ç° typeclass:

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
given Functor[Identity]:
  def fmap[A, B](f: A => B): Identity[A] => Identity[B] =
    case Identity(a) => Identity(f(a))

given Monad[Identity]:
  def pure[A](a: A): Id[A] = Identity(a)
  def flatMap[A, B](f: A => Identity[B]): Identity[A] => Identity[B] =
    case Identity(a) => f(a)
\end{lstlisting}

å¯ä»¥çœ‹åˆ° \texttt{Identity} å³æ˜¯æ„é€ å™¨/constructorï¼Œä¹Ÿæ˜¯è§£æ„å™¨/destructureï¼Œåˆ©ç”¨æ¨¡å¼åŒ¹é…æ˜¯å¯ä»¥è§£æ„å‡ºå€¼çš„ã€‚

ä¸Šé¢å‡½å­å®ç°ä¸­çš„ \texttt{fmap f (Identity a)}, å‡å¦‚ \texttt{fmap} çš„æ˜¯ \texttt{Identity 1},
é‚£ä¹ˆè¿™ä¸ªæ¨¡å¼åŒ¹é…åˆ° \texttt{(Identity a)} æ—¶ä¼šé€šè¿‡è§£æ„å™¨æŠŠ \texttt{1} æ”¾åˆ° \texttt{a} çš„ä½ç½®ã€‚

\textbf{æœ¬æ¥å°±æœ‰} çœ‹èµ·æ¥ä»€ä¹ˆä¹Ÿæ²¡æœ‰å¹²ï¼Œå°±è·Ÿ \texttt{identity} å‡½æ•°ä¸€æ ·ï¼Œä½†æ˜¯å®é™…ä¸Š, å®ƒä¹Ÿè·Ÿ identity ç›¸å¯¹äºå‡½æ•°ä¸€æ ·ï¼Œåœ¨æŸäº›åœºæ™¯åº•ä¸‹éå¸¸æœ‰ç”¨ï¼Œæ¯”å¦‚åä¸€éƒ¨åˆ†æåŸºçŒ«å‘¢ä¼š
æçš„é«˜è¾¾çŒ«ã€‚

\chapter{Maybe å¯èƒ½ä¼šæœ‰}
\label{sec:org038ba9f}
å¯èƒ½ä¼šæœ‰å•å­/Maybe Monadæ˜¯ä¸€ä¸ªè¶…çº§ç®€å•çš„ä½†æ¯”æœ¬èº«å°±æœ‰ç¨ç¨å¤æ‚çš„å•å­.

å› ä¸ºå®ƒæ‹¥æœ‰æ¯”æœ¬èº«å°±æœ‰å¤šä¸€ä¸ªçš„ç±»å‹æ„é€ å™¨ï¼Œç±»ä¼¼è¿™æ ·çš„å«åš ä»£æ•°æ•°æ®ç±»å‹/ Algebra Data Type(ADT)

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Maybe a = Just a | Nothing
\end{lstlisting}

å…¶ä¸­ \texttt{a} \footnote{ä¸€å®šè¦è®°å¾—å°å†™å“¦}è¡¨ç¤ºæ˜¯ä»»æ„ç±»å‹.

ä½ çœ‹, ä¸ç®¡æ˜¯ \texttt{Just} è¿˜æ˜¯ \texttt{Nothing} éƒ½å¯ä»¥æ„é€ å‡ºä¸€ä¸ª \texttt{Maybe} ç±»å‹çš„æ•°æ®æ¥.

ADT åœ¨ Scala å¯ä»¥ç”¨ enum è¡¨ç¤º, è€Œä¸”, Scala ä¸­çš„ \texttt{Maybe} å«åš \texttt{Option}:

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
enum Option[+A]:
  case Some(a: A)
  case None
\end{lstlisting}


æ‰€ä»¥ \texttt{Just 1} ä¼šå¾—åˆ°ä¸€ä¸ª \texttt{Num a => Mabye a} ç±»å‹\footnote{æ„æ€å°±æ˜¯ \texttt{Maybe a} ä½†æ˜¯ \texttt{a} çš„ç±»å‹çº¦æŸä¸º \texttt{Num}}ï¼Œ
\texttt{Nothing} ä¹Ÿä¼šå¾—åˆ°ä¸€ä¸ª \texttt{Maybe a} åªä¸è¿‡ \texttt{a} æ²¡æœ‰ç±»å‹çº¦æŸã€‚

æ€»ä¹‹æˆ‘ä»¬æœ‰äº†æ„é€ å™¨å¯ä»¥æ„é€ å‡º \texttt{Maybe} ç±»å‹ï¼Œè€Œè¿™ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ï¼Œå°±è¦å–å†³å®ƒå®ç°äº†å“ªäº› typeclass çš„å®ä¾‹ äº†ã€‚æ¯”å¦‚å®ƒå¯ä»¥æ˜¯ä¸€ä¸ªå‡½å­.
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Functor Maybe where
  fmap f (Just a) = Just (f a)
  fmap f Nothing = Nothing
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
given Functor[Option]:
  def fmap[A, B](f: A => B): Option[A] => Option[B] =
    case Some(a) => Some(f(a))
    case None => None
\end{lstlisting}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-maybe-functor.png}
\caption{fmap :: (a -> b) -> f a -> f b}
\end{figure}

çœ‹æ¸…æ¥šäº†, è™šçº¿ç®­å¤´å³ \texttt{fmap}, å›¾ä¸Šè¡¨ç¤ºçš„ \texttt{fmap} æ˜¯ \texttt{(a -> b) - - -> (Maybe a -> Maybe b)} ç”±äºè¿™é‡Œçš„ç®­å¤´éƒ½æ˜¯åœ¨ \texttt{->} èŒƒç•´, æ‰€ä»¥ \texttt{- - ->} å°±æ˜¯ \texttt{->} äº†.

å³: \texttt{fmap :: (a -> b) -> f a -> f b}

ä¸ä»…å¦‚æ­¤ï¼Œè¿˜å¯ä»¥å®ç°å•å­:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Monad Maybe where
  return a = Just a
  (Just a) >>= f = f a
  Nothing >>= f = Nothing
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
given Monad[Option]:
  def pure[A](a: A): Option[A] = Some(a)
  def flatMap[A, B](f: A => Option[B]): Option[A] => Option[B] =
    case Some(a) => f(a)
    case None => None
  extension [A,B](fa: Option[A])
    def >>=(f: A => Option[B]): Option[B] = flatMap(f)(fa)
\end{lstlisting}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-maybe-kleisli.png}
\caption{è¿˜è®°å¾—ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„ Kleisli èŒƒç•´å—ï¼Ÿ}
\end{figure}

Maybe æœ‰ç”¨åœ¨äºèƒ½åˆé€‚çš„å¤„ç† \emph{åå‡½æ•°} Partial Function/ çš„è¿”å›å€¼ã€‚
åå‡½æ•°ç›¸å¯¹äº \emph{å…¨å‡½æ•°} Total Function/ æ˜¯æŒ‡åªèƒ½å¯¹éƒ¨åˆ†è¾“å…¥è¿”å›è¾“å‡ºçš„å‡½æ•°ã€‚

æ¯”å¦‚ä¸€ä¸ªå–æ•°ç»„æŸä¸€ä½ä¸Šçš„å€¼çš„å‡½æ•°ï¼Œå°±æ˜¯åå‡½æ•°ï¼Œå› ä¸ºå‡è®¾ä½ æƒ³å–ç¬¬4ä½çš„å€¼ï¼Œä½†ä¸æ˜¯æ‰€æœ‰æ•°ç»„é•¿åº¦éƒ½å¤§äº4ï¼Œå°±ä¼šæœ‰è·å–ä¸äº†çš„å°´å°¬æƒ…å†µã€‚
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
[1,2,3] !! 4
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
List(1,2,3).get(4)
\end{lstlisting}

å¦‚æœä½¿ç”¨ Maybe æŠŠåå‡½æ•°å¤„ç†ä¸äº†çš„è¾“å…¥éƒ½è¿”å›æˆ Nothingï¼Œè¿™æ ·ç»“æœä¾ç„¶ä¿æŒ Maybe ç±»å‹ï¼Œä¸å½±å“åé¢çš„è®¡ç®—ã€‚

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
([[1,2,3], [4,5,6]] !! 1) >>= \x -> x !! 2
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
List(List(1,2,3), List(4,5,6)).get(1) >>= { _.get(2) }
\end{lstlisting}

\chapter{Either è¦ä¹ˆæœ‰è¦ä¹ˆæœ‰}
\label{sec:org542b817}

Either çš„å®šä¹‰ä¹Ÿå¾ˆç®€å•
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Either a b = Left a | Right b
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
enum Either[+A, +B]:
  case Left(a: A)
  case Right(b: B)
\end{lstlisting}


\section{Product \& Coproduct}
\label{sec:orgb971bb5}
çœ‹è¿‡ç¬¬ä¸€éƒ¨åˆ†åº”è¯¥è¿˜èƒ½è®°å¾—æœ‰ä¸€ä¸ªä¸œè¥¿å« Duelï¼Œæ‰€ä»¥è§åˆ°å¦‚æœèŒƒç•´ä¸Šæœ‰ Coproduct é‚£ä¹ˆè‚¯å®šåœ¨duelèŒƒç•´ä¸Šä¼šæœ‰åŒæ ·çš„ä¸œè¥¿å« Productã€‚

é‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯ Coproduct

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-coproduct.png}
\caption{Coproduct}
\end{figure}

åƒè¿™æ ·ï¼Œèƒ½é€šè¿‡ä¸¤ä¸ªç®­å¤´åˆ°è¾¾åŒä¸€ä¸ªä¸œè¥¿ï¼Œå°±æ˜¯ Coproductã€‚è¿™é‡Œç®­å¤´ \texttt{Left} èƒ½è®© \texttt{a} åˆ° \texttt{Either a b} ï¼Œ ç®­å¤´ \texttt{Right} ä¹Ÿèƒ½è®© \texttt{b} åˆ°è¾¾ \texttt{Either a b}

æœ‰æ„æ€çš„æ˜¯è¿˜è‚¯å®šå­˜åœ¨ä¸€ä¸ª Coproduct å’Œ ç®­å¤´ï¼Œä½¿å¾—ä¸‹å›¾æˆç«‹
\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-coproduct-law.png}
\end{center}

ç®­å¤´åè¿‡æ¥ï¼Œå°±æ˜¯ Product, æ¯”å¦‚ Tuple

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-product.png}
\caption{Product}
\end{figure}

Tuple çš„ \texttt{fst} ç®­å¤´èƒ½è®© \texttt{(a, b)} åˆ°è¾¾ \texttt{a} å¯¹è±¡ï¼Œè€Œç®­å¤´ \texttt{snd} èƒ½è®©å…¶åˆ°è¾¾ \texttt{b} å¯¹è±¡ã€‚

\section{Either Monad}
\label{sec:org6b6ad30}
ç¡®åˆ‡çš„è¯´ï¼ŒEither ä¸æ˜¯ monadï¼Œ \texttt{Either a} æ‰æ˜¯ã€‚è¿˜è®°å¾— monad çš„ class å®šä¹‰å—ï¼Ÿ
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
\end{lstlisting}
æ‰€ä»¥ m å¿…é¡»æ˜¯ä¸ª Endofunctorï¼Œä¹Ÿå°±æ˜¯è¦æ»¡è¶³ Functor
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
\end{lstlisting}
t a çš„ kind æ˜¯ *ï¼Œæ‰€ä»¥ t å¿…é¡»æ˜¯ kind * -> *
ä¹Ÿå°±æ˜¯è¯´ï¼Œm å¿…é¡»æ˜¯æ¥æ”¶ä¸€ä¸ªç±»å‹å‚æ•°çš„ç±»å‹æ„é€ å™¨

è€Œ Either çš„ kind æ˜¯ * -> * -> *, Either a æ‰æ˜¯ * -> *

æ‰€ä»¥åªèƒ½å®šä¹‰ Either a çš„ Monad
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Monad (Either a) where
  Left  l >>= _ = Left l
  Right r >>= k = k r
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
given [A]: Monad[Either[A, ?]] with
  def flatMap[B, C](f: B => Either[A, C]): Either[A, B] => Either[A, C] = (fa: Either[A, B]) =>
    fa match
      case Left(l) => Left(l)
      case Right(r) => f(r)
\end{lstlisting}

å¾ˆæ˜æ˜¾çš„ï¼Œ>>= ä»»ä½•å‡½æ•°åˆ°å·¦è¾¹/ Left éƒ½ä¸ä¼šæ”¹å˜ï¼Œåªæœ‰ >>= å³è¾¹æ‰èƒ½äº§ç”Ÿæ–°çš„è®¡ç®—ã€‚

\chapter{Reader å·®ä¸€ç‚¹å°±æœ‰}
\label{sec:orge52651d}

\emph{å·®ä¸€ç‚¹å°±æœ‰} çš„ä½œç”¨æ˜¯æè¿°ä¸€ä¸ªéœ€è¦å–‚æ•°æ®çš„è®¡ç®—ã€‚

åœ¨æè¿°è®¡ç®—çš„æ—¶å€™ï¼Œå¹¶ä¸éœ€è¦å…³å¿ƒå…·ä½“è¾“å…¥çš„å€¼æ˜¯ä»€ä¹ˆï¼Œæ›´éœ€è¦å…³æ³¨çš„æ˜¯è¾“å…¥çš„ç±»å‹ã€‚
å½“è®¡ç®—éœ€è¦ä»¥æ¥è¯¥å€¼æ—¶ï¼Œåªéœ€è¦ asks å°±å¯ä»¥å‡è£…æ‹¿åˆ°è¾“å…¥å€¼ï¼Œç»§ç»­æè¿°æ¥ä¸‹æ¥çš„è®¡ç®—ã€‚

è€ŒçœŸæ­£çš„è¾“å…¥ï¼Œä¼šåœ¨æœ€ç»ˆè¿è¡Œè®¡ç®—æ—¶ç»™äºˆã€‚

è·Ÿ \emph{æœ¬èº«å°±æœ‰} ä¸€æ ·ï¼Œæˆ‘ä»¬ç”¨ newtype æ¥å®šä¹‰ä¸€ä¸ªåŒæ„çš„ \emph{å·®ä¸€ç‚¹å°±æœ‰} ç±»å‹ï¼š

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype Reader e a = Reader { runReader :: (e -> a) }
\end{lstlisting}

\lstset{language=scala,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
case class Reader[E, A](run: E => A)
\end{lstlisting}

å…¶ä¸­ï¼š
\begin{itemize}
\item e æ˜¯è¾“å…¥
\item a æ˜¯ç»“æœ
\item æ„é€  Reader ç±»å‹éœ€è¦ç¡®å®šè¾“å…¥çš„ç±»å‹ e ä¸è¾“å‡ºçš„ç±»å‹ a
\item \texttt{runReader} çš„ç±»å‹æ˜¯ \texttt{runReader:: (Reader e a) -> (e -> a)}
\end{itemize}

ä¹Ÿå°±æ˜¯è¯´åœ¨æè¿°å®Œä¸€ä¸ª Reader çš„è®¡ç®—åï¼Œä½¿ç”¨ runReader å¯ä»¥å¾—åˆ°ä¸€ä¸ª e -> a çš„å‡½æ•°ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå°±å¯ä»¥æ¥æ”¶è¾“å…¥ï¼Œé€šè¿‡æ„é€ å¥½çš„è®¡ç®—ï¼Œç®—å‡ºç»“æœ a è¿”å›ã€‚

é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬æ¥å®ç° Reader çš„å•å­å®åŠ›ï¼Œå°±å¯ä»¥æè¿°ä¸€ä¸ªå¯ä»¥ ask çš„è®¡ç®—äº†ã€‚

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Monad (Reader e) where
    return a         = Reader $ \_ -> a
    (Reader g) >>= f = Reader $ \e -> runReader (f (g e)) e
\end{lstlisting}

\begin{verbatim}
given [E]: Monad[Reader[E, ?]] with
  def pure[A](a: A): Reader[E, A] = Reader((e: E) => a)
  def flatMap[A, B](f: A => Reader[E, B]): Reader[E, A] => Reader[E, B] = (fa: Reader[E, A]) =>
    Reader((e: E) => f(fa.run(e)).run(e)

\end{verbatim}

è·ŸEitherä¸€æ ·ï¼Œæˆ‘ä»¬åªèƒ½å®šä¹‰ Reader e çš„ monad instanceã€‚

æ³¨æ„è¿™é‡Œçš„
\begin{itemize}
\item f ç±»å‹æ˜¯ \texttt{(a -> Reader e a)}
\item g å…¶å®å°±æ˜¯æ˜¯ destructure å‡ºæ¥çš„ runReaderï¼Œä¹Ÿå°±æ˜¯ e -> a
\item æ‰€ä»¥ (g e) è¿”å› a
\item f (g e) å°±æ˜¯ \texttt{Reader e a}
\item å† run ä¸€æŠŠæœ€åå¾—åˆ° a
\end{itemize}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-reader-monad.png}
\caption{f å‡½æ•°ï¼Œæ¥æ”¶ a è¿”å›ä¸€ä¸ª ä» e åˆ° a çš„ Reader}
\end{figure}

è®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ Reader
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
import Control.Monad.Reader

data Environment = Env
  { fistName :: String
  , lastName :: String
  } deriving (Show)

helloworld :: Reader Environment String
helloworld = do
  f <- asks firstName
  l <- asks lastName
  return "Hello " ++ f ++ l

runHelloworld :: String
runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"
\end{lstlisting}

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œhelloworld è´Ÿè´£æ‰“æ‹›å‘¼ï¼Œä¹Ÿå°±æ˜¯åœ¨åå­—å‰é¢åŠ ä¸ª "Hello"ï¼Œè€Œè·Ÿè°æ‰“æ‹›å‘¼ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸å…³å¿ƒï¼Œè€Œå•çº¯çš„æ˜¯å‘ Environment é—®/asks å°±å¥½ã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-reader-monad-ask.png}
\caption{asks å¯ä»¥å°† e -> a çš„å‡½æ•°å˜æ¢æˆ Reader e a}
\end{figure}

åœ¨è¿è¡Œæ—¶ï¼Œå¯ä»¥æä¾›ç»™ Reader çš„è¾“å…¥ Env fistname lastnameã€‚
\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-reader-monad-run.png}
\end{center}

\section{do notation}
\label{sec:orgcd119be}
è¿™å¯èƒ½æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° \texttt{do} å’Œ \texttt{<-}. å¦‚æœä¸æ˜¯ï¼Œéšæ„è·³è¿‡è¿™èŠ‚ã€‚

\begin{itemize}
\item do ä¸­æ‰€æœ‰ <- çš„å³è¾¹éƒ½æ˜¯ \texttt{Reader Environment String} ç±»å‹
\item do ä¸­çš„ return è¿”å›ç±»å‹ä¹Ÿå¿…é¡»ä¸º  \texttt{Reader Environment String}
\item \texttt{asks firstName} è¿”å›çš„æ˜¯ \texttt{Reader Environment String} ç±»å‹ï¼Œ \texttt{<-} å¯ä»¥ç†è§£æˆå§ monad \texttt{Reader Environment} çš„å†…å®¹æ”¾åˆ°å·¦è¾¹çš„ f, æ‰€ä»¥ f çš„ç±»å‹æ˜¯ Stringã€‚
\end{itemize}

çœ‹èµ·æ¥åƒå‘½ä»¤å¼çš„è¯­å¥ï¼Œå…¶å®åªæ˜¯ \texttt{>>=} çš„è¯­æ³•ç³–ï¼Œä½†æ˜¯æ˜æ˜¾ç”¨doå¯è¯»æ€§è¦é«˜å¾ˆå¤šã€‚
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
helloworld = (asks firstName) >>=
  \f -> (asks lastName) >>=
       \l -> return "Hello " ++ f ++ l
\end{lstlisting}


\chapter{Writer å…‰å‡ºè¿›æ²¡æœ‰}
\label{sec:org97934f2}

é™¤äº†è¿”å›å€¼ï¼Œè®¡ç®—ä¼šéœ€è¦äº§ç”Ÿä¸€äº›é¢å¤–çš„æ•°æ®ï¼Œæ¯”å¦‚ log

æ­¤æ—¶å°±éœ€è¦ä¸€ä¸ª Writterï¼Œå…¶è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · \texttt{(result, log)} çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª å«å¹ºåŠç¾¤/monoid

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
example :: Writer String String
example  = do
  tell "How are you?"
  tell "I'm fine thank you, and you?"
  return "Hehe Da~"

output :: (String, String)
output = runWriter example
-- ("Hehe Da~", "How are you?I'm fine thank you, and you?")
\end{lstlisting}

Writer çš„å®šä¹‰æ›´ç®€å•
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype Writer l a = Writer { runWriter :: (a,l) }
\end{lstlisting}
é‡Œé¢åªæ˜¯ä¸€ä¸ª tuple è€Œå·²
\begin{itemize}
\item w æ˜¯ log
\item a æ˜¯ è¿”å›å€¼
\end{itemize}

çœ‹çœ‹å¦‚ä½•å®ç° Writer monad
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance (Monoid w) => Monad (Writer w) where
    return a             = Writer (a,mempty)
    (Writer (a,l)) >>= f = let (a',l') = runWriter $ f a in
                           Writer (a',l `mappend` l')
\end{lstlisting}

\begin{itemize}
\item return ä¸ä¼šæœ‰ä»»ä½• logï¼Œl æ˜¯ monoid çš„ mempty
\item f çš„ç±»å‹ä¸º \texttt{a -> Writer l a}
\item \texttt{runWriter \$ f a} è¿”å› \texttt{(a, l)}
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-writer-monad.png}
\end{center}

æ‰€ä»¥åœ¨ >>= æ—¶ï¼Œæˆ‘ä»¬å…ˆæŠŠ f a è¿”å›çš„ Writer runäº†ï¼Œç„¶åæŠŠä¸¤æ¬¡ log \texttt{mappend} èµ·æ¥ã€‚
\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-writer-monad-bind.png}
\end{center}

\chapter{State å˜åŒ–ä¼šæœ‰}
\label{sec:org4cf833a}
è·Ÿåå­—å°±çœ‹å¾—å‡ºæ¥ State monad æ˜¯ä¸ºäº†å¤„ç†çŠ¶æ€ã€‚è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹ä¸åº”è¯¥æœ‰çŠ¶æ€ï¼Œä¸ç„¶ä¼šå¼•ç”¨é€æ˜æ€§ã€‚ä½†æ˜¯ï¼Œstate monadå¹¶ä¸æ˜¯åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹çŠ¶æ€ï¼Œè€Œæ˜¯é€šè¿‡æè¿°è¿™ç§å˜åŒ–ï¼Œç„¶åéœ€è¦æ—¶åœ¨è¿è¡Œè¿”å›æœ€ç»ˆç»“æœã€‚è¿™ä¸€ç‚¹è·Ÿ Reader å’Œ Writer è¿™ä¸¤ä¸ªçœ‹èµ·æ¥æ˜¯å‰¯ä½œç”¨çš„ IO æ˜¯ä¸€æ ·çš„ã€‚

å…ˆçœ‹ä¸‹ State ç±»å‹çš„å®šä¹‰
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype State s a = State { runState :: s -> (a, s) }
\end{lstlisting}

å¯ä»¥çœ‹åˆ° State åªåŒ…å«ä¸€ä¸ª ä»æ—§çŠ¶æ€ s åˆ°æ–°çŠ¶æ€ s å’Œè¿”å›å€¼ a çš„ Tuple çš„å‡½æ•°ã€‚

é€šè¿‡å®ç° Monadï¼ŒState å°±å¯ä»¥å®ç°å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„å˜é‡çš„åŠŸèƒ½ã€‚
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Monad (State s) where
  return a        = State $ \s -> (a,s)
  (State x) >>= f = State $ \s -> let (v,s') = x s in
                                 runState (f v) s'
\end{lstlisting}
return å¾ˆç®€å•ï¼Œå°±ä¸ç”¨è§£é‡Šäº†ã€‚

\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-state-monad.png}
\end{center}

x ç±»å‹æ˜¯ \texttt{s -> (a, s)} ,æ‰€ä»¥ x s ä¹‹åä¼šè¿”å› ç»“æœå’ŒçŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¿è¡Œå½“å‰ Stateï¼ŒæŠŠç»“æœ v ä¼ ç»™å‡½æ•° fï¼Œè¿”å›çš„ State å†æ¥ç€ä¸Šæ¬¡çŠ¶æ€è¿è¡Œã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-state-monad-bind.png}
\caption{State x >>= f årunStateçš„æ•°æ®æµï¼ˆå•Šå•Šå•Šï¼Œç”»æ­ªäº†ï¼Œæ„Ÿè§‰éœ€è¦è„‰åŠ¨ä¸€ä¸‹ï¼‰}
\end{figure}

ä½¿ç”¨èµ·æ¥ä¹Ÿå¾ˆæ–¹ä¾¿ï¼ŒState æä¾› \texttt{get} \texttt{put} \texttt{moidfy} ä¸‰ä¸ªæ–¹ä¾¿çš„å‡½æ•°å¯ä»¥ç”Ÿæˆä¿®æ”¹çŠ¶æ€çš„State monad

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
import Control.Monad.Trans.State.Strict
test :: State Int Int
test = do
  a <- get
  modify (+1)
  b <- get
  return (a + b)

main = print $ show $ runState test 3
-- (7, 4)
\end{lstlisting}


\chapter{Validation æ£€æŸ¥æ£€æŸ¥}
\label{sec:org811d64e}
å¦‚æœä½ æœ‰æ³¨æ„åˆ°ï¼Œå‰é¢çš„ Either å¯ä»¥ç”¨åœ¨å¤„ç†é”™è¯¯å’Œæ­£ç¡®çš„è·¯å¾„åˆ†æ”¯ï¼Œä½†æ˜¯é—®é¢˜æ˜¯é”™è¯¯åªå‘ç”Ÿä¸€æ¬¡ã€‚

\begin{quote}
Validation æ²¡æœ‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œä½†æ˜¯æˆ‘è§‰å¾—å¥½æœ‰ç”¨å•Šï¼Œä½ å¯ä»¥åœ¨ ekmett çš„ \href{https://github.com/ekmett/either}{github} ä¸­æ‰¾åˆ°æºç 
\end{quote}

æƒ³è±¡ä¸€ä¸‹è¿™ç§åœºæ™¯ï¼Œç”¨æˆ·æäº¤ä¸€ä¸ªè¡¨å•ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸€ä¸ªfieldè¿›è¡ŒéªŒè¯ï¼Œå¦‚æœæœ‰é”™è¯¯ï¼Œéœ€è¦æŠŠé”™è¯¯çš„å“ªå‡ ä¸ªfieldçš„é”™è¯¯æ¶ˆæ¯è¿”å›ã€‚æ˜¾ç„¶å¦‚æœä½¿ç”¨ Either æ¥åšï¼Œåªèƒ½è¿”å›ç¬¬ä¸€ä¸ªfieldçš„é”™è¯¯ä¿¡æ¯ï¼Œåé¢çš„è®¡ç®—éƒ½ä¼šè¢«è·³è¿‡ã€‚

é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œ Validation æ›´é€‚åˆ
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Validation e a = Failure e | Success a
\end{lstlisting}

ADTå®šä¹‰çœ‹èµ·æ¥è·Ÿ Either æ˜¯ä¸€æ ·çš„ï¼Œä¸åŒçš„æ˜¯ å·¦è¾¹/Left Failure æ˜¯ å«å¹ºåŠç¾¤/Monoid

\section{å«å¹ºåŠç¾¤/Monoid}
\label{sec:orgc6d7ebb}
monoid é¦–å…ˆå¾—æ˜¯ åŠç¾¤/Semigroup ï¼Œç„¶åå† å«å¹ºã€‚
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Semigroup a where
  (<>) :: a -> a -> a
  (<>) = mappend
\end{lstlisting}

åŠç¾¤éå¸¸ç®€å•ï¼Œåªè¦æ˜¯å¯ä»¥ \texttt{<>} (mappend) çš„ç±»å‹å°±æ˜¯äº†ã€‚

å«å¹ºåªéœ€è¦æœ‰ä¸€ä¸ª \texttt{mempty} çš„ å¹ºå…ƒå°±è¡Œ
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Monoid a where
  mempty  :: a
  mappend :: a -> a -> a
\end{lstlisting}

æ¯”å¦‚ List å°±æ˜¯ Semigroup
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Semigroup [a] where
  (<>) = (++)
\end{lstlisting}
ä¹Ÿæ˜¯ Monoid
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Monoid [a] where
  mempty  = []
  mappend = (++)
\end{lstlisting}

Monoid çš„ \texttt{<>} æ»¡è¶³ï¼š
\begin{itemize}
\item mempty <> a = a
\item a <> b <> c = a <> (b <> c)
\end{itemize}
\section{å›åˆ° Validation}
\label{sec:orgf1319d4}
ç°åœ¨è®© Failure e æ»¡è¶³ Monoidï¼Œå°±å¯ä»¥ \texttt{mappend} é”™è¯¯ä¿¡æ¯äº†ã€‚
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Semigroup e => Semigroup (Validation e a) where
  Failure e1 <> Failure e2 = Failure (e1 <> e2)
  Failure _  <> Success a2 = Success a2
  Success a1 <> Failure _  = Success a1
  Success a1 <> Success _  = Success a1
\end{lstlisting}

ä¸‹æ¥ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹çœ‹ Validation ä¸ Either æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªformï¼Œéœ€è¦è¾“å…¥å§“åä¸ç”µè¯ï¼ŒéªŒè¯éœ€è¦å§“åæ˜¯éç©ºè€Œç”µè¯æ˜¯11ä½æ•°å­—ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªå‡½æ•°å»åˆ›å»ºåŒ…å«å§“åå’Œç”µè¯çš„model
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Info = Info {name: String, phone: String} deriving Show
\end{lstlisting}

ç„¶åæˆ‘ä»¬éœ€è¦éªŒè¯å‡½æ•°
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
notEmpty :: String -> String -> Validation [String] String
notEmpty desc "" = Failure [desc <> " cannot be empty!"]
notEmpty _ field = Success field
\end{lstlisting}
notEmpty æ£€æŸ¥å­—ç¬¦æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ˜¯ç©ºè¿”å› Failure åŒ…å«é”™è¯¯ä¿¡æ¯ï¼Œè‹¥æ˜¯éç©ºåˆ™è¿”å› Success åŒ…å« field

åŒæ ·çš„å¯ä»¥åˆ›å»º 11ä½æ•°å­—çš„éªŒè¯å‡½æ•°
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
phoneNumberLength :: String -> String -> Validation [String] String
phoneNumberLength desc field | (length field) == 11 = Success field
                             | otherwise = Failure [desc <> "'s length is not 11"]
\end{lstlisting}
å®ç° Validation çš„ Applicative instanceï¼Œè¿™æ ·å°±å¯ä»¥æŠŠå‡½æ•°è°ƒç”¨liftæˆå¸¦æœ‰éªŒè¯çš„ Applicative
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Semigroup e => Applicative (Validation e) where
  pure = Success
  Failure e1 <*> Failure e2 = Failure e1 <> Failure e2
  Failure e1 <*> Success _  = Failure e1
  Success _  <*> Failure e2 = Failure e2
  Success f <*> Success a = Success (f a)
\end{lstlisting}
\begin{itemize}
\item å¤±è´¥åº”ç”¨åˆ°å¤±è´¥ä¼š concat èµ·æ¥
\item å¤±è´¥è·Ÿåº”ç”¨æˆ–è¢«æˆåŠŸåº”ç”¨è¿˜æ˜¯å¤±è´¥
\item åªæœ‰æˆåŠŸåº”ç”¨åˆ°æˆåŠŸæ‰èƒ½æˆåŠŸï¼Œè¿™å¾ˆç¬¦åˆéªŒè¯çš„é€»è¾‘ï¼Œä¸€æ—¦éªŒè¯ä¸­å‘ç”Ÿä»»ä½•é”™è¯¯ï¼Œéƒ½åº”è¯¥è¿”å›å¤±è´¥ã€‚
\end{itemize}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
createInfo :: String -> String -> Validation [String] Info
createInfo name phone = Info <$> notEmpty "name" name <*> phoneNumberLength "phone" phone
\end{lstlisting}

ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨å¸¦validationçš„ createInfo æ¥å®‰å…¨çš„åˆ›å»º Info äº†

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
createInfo "jichao" "12345678910" -- Success Info "jichao" "12345678910"
createInfo "" "123" -- Failure ["name cannot be empty!", "phone's length is not 11"]
\end{lstlisting}

\chapter{Cont æ¥ä¸‹æ¥æœ‰}
\label{sec:orgba04a00}
Cont æ˜¯ Continuation Passing Style/CPS çš„ monadï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯åŒ…å« cps è®¡ç®— monadã€‚

å…ˆçœ‹ä¸€ä¸‹ä»€ä¹ˆæ˜¯ CPSï¼Œæ¯”å¦‚æœ‰ä¸€ä¸ªåŠ æ³•
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
add :: Int -> Int -> Int
add = (+)
\end{lstlisting}

ä½†æ˜¯å¦‚æœä½ æƒ³åœ¨ç®—æ³•åŠ æ³•åï¼Œèƒ½å¤Ÿç»§ç»­è¿›è¡Œä¸€ä¸ªå…¶ä»–çš„è®¡ç®—ï¼Œé‚£ä¹ˆå°±å¯ä»¥å†™ä¸€ä¸ª cpsç‰ˆæœ¬çš„åŠ æ³•
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
addCPS :: Int -> Int -> (Int -> r) -> r
addCPS a b k = k (a + b)
\end{lstlisting}

éå¸¸ç®€å•ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹çœ‹ä¸ºä»€ä¹ˆéœ€è¦ä¸€ä¸ª Cont monad æ¥åŒ…ä½ CPS è®¡ç®—ï¼Œé¦–å…ˆï¼Œæ¥çœ‹ ADT å®šä¹‰
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype Cont r a = Cont { runCont :: ((a -> r) -> r) }
\end{lstlisting}

åˆæ˜¯ä¸€ä¸ªåŒæ„çš„ç±»å‹ï¼ŒCont æ„é€ å™¨åªéœ€è¦ä¸€ä¸ª runCountï¼Œä¹Ÿå°±æ˜¯è®©ä»–èƒ½ç»§ç»­è®¡ç®—çš„ä¸€ä¸ªå‡½æ•°ã€‚

å®Œäº†ä¹‹åæ¥æŠŠä¹‹å‰çš„ addCPS æ”¹æˆ Cont
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
add :: Int -> Int -> Cont k Int
add a b = return (a + b)
\end{lstlisting}

æ³¨æ„åˆ° addCPS æ¥æ”¶åˆ° a å’Œ b ä¹‹åè¿”å›çš„ç±»å‹æ˜¯ \texttt{(Int -> r) -> r} ï¼Œè€Œ Cont ç‰ˆæœ¬çš„ \texttt{add} è¿”å› \texttt{Cont k Int}

æ˜æ˜¾æ„é€  \texttt{Cont k Int} ä¹Ÿæ­£æ˜¯éœ€è¦ \texttt{(Int -> r) -> r} ï¼Œæ‰€ä»¥ Cont å°±æ˜¯ç®—äº† k çš„æŠ½è±¡äº†ã€‚

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
\end{lstlisting}

\texttt{(\$ a)} æ¯”è¾ƒæœ‰æ„æ€, æˆ‘ä»¬éƒ½çŸ¥é“ \texttt{f \$ g a} å…¶å®å°±æ˜¯ \texttt{f(g a)}, æ‰€ä»¥ \texttt{\$} å…¶å®å°±æ˜¯ä¸€ä¸ª apply å·¦è¾¹çš„å‡½æ•°åˆ°å³è¾¹è¡¨è¾¾å¼çš„ä¸­ç¼€å‡½æ•°, å¦‚æœå†™æˆå‰ç¼€åˆ™æ˜¯
\texttt{(\$ (g a) f)}. æ˜¯åçš„æ˜¯å› ä¸º \texttt{\$} æ˜¯æœ‰ç»“åˆ, éœ€è¦å³è¾¹è¡¨è¾¾å¼å…ˆæ±‚å€¼, æ‰€ä»¥åªç»™ä¸€ä¸ª a å°±ç›¸å½“äº \texttt{(\$ a) = \textbackslash{}f -> f a}

å›åˆ° Monad Cont\ldots{}

\chapter{Summary}
\label{sec:org539d46d}
ç¬¬äºŒéƒ¨åˆ†é£Ÿç”¨éƒ¨åˆ†ä¹Ÿè®²å®Œäº†ï¼Œ ä¸çŸ¥æ˜¯å¦ä»¥åŠå¤§è‡´äº†è§£äº†monadçš„å°¿æ€§å„ç§åŸºæœ¬ç©æ³•å‘¢ï¼Ÿé€šè¿‡è¿™äº›å¸¸ç”¨çš„åŸºæœ¬çš„ monad instanceï¼Œè§£å†³å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„ä¸€äº›ç®€å•é—®é¢˜åº”è¯¥æ˜¯å¤Ÿäº†ã€‚

ä¸è¿‡ï¼Œæ¥ä¸‹æ¥è¿˜æœ‰æ›´å˜æ€çš„çŒ«ï¼Œå°±å…ˆå«å¥¹ \sout{æåŸº} çŒ«å‘¢å¥½äº†ã€‚

\begin{itemize}
\item ğŸ‘‰ \href{./part3.org}{ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢/ Advanced Monads}
\end{itemize}

å½“ç„¶æˆ‘åˆè¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœè¿˜æœ‰å¾ˆå¤šäººé¢„å®š/åªè¦998 Gumroad ä¸Šçš„  ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œï¼Œå°±å½“æ˜¯æˆ‘åˆè‡ªè¨€è‡ªè¯­å§ï¼Œæ€ä¹ˆåˆçªç„¶è§‰å¾—è‡ªå·±å¥½åˆ†è£‚ï¼Œè¯¶\textasciitilde{}ï¼Œä¸ºä»€ä¹ˆæˆ‘è¦è¯´åˆï¼Ÿ

\part{æåŸºçŒ«å‘¢/Advanced Monads}
\label{sec:orgbc34df1}
ç¬¬äºŒéƒ¨åˆ†ä»‹ç»äº†ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

é€šè¿‡å®ƒä»¬å¯ä»¥è§£å†³å¤§å¤šæ•°çš„åŸºæœ¬é—®é¢˜ï¼Œä½†æ˜¯æ­£å¯¹äºå¤æ‚ä¸šåŠ¡é€»è¾‘ï¼Œæˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦ä¸€äº›æ›´é«˜é˜¶çš„ monad æˆ–è€… patternã€‚

å½“æœ‰äº†ç¬¬ä¸€éƒ¨åˆ†çš„ç†è®ºåŸºç¡€å’Œç¬¬äºŒéƒ¨åˆ†çš„å®è·µï¼Œè¿™éƒ¨åˆ†è¦ä»‹ç»çš„çŒ«å‘¢å…¶å®å¹¶ä¸æ˜¯å¾ˆæåŸºã€‚é€šè¿‡è¿™ä¸€éƒ¨åˆ†ä»‹ç»çš„æåŸºçŒ«å‘¢ï¼Œ
æˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚

\chapter{RWS}
\label{sec:orgbdde1ab}
RWS æ˜¯ç¼©å†™ Reader Writer State monad, æ‰€ä»¥æ˜æ˜¾æ˜¯ä¸‰ä¸ªmonadçš„åˆä½“ã€‚å¦‚æœå·²ç»å¿˜è®° Reader Writer æˆ–è€… Stateï¼Œè¯·åˆ°ç¬¬äºŒéƒ¨åˆ†å¤ä¹ ä¸€ä¸‹ã€‚

ä¸€æ—¦æŠŠä¸‰ä¸ª monad åˆä½“ï¼Œæ„å‘³ç€å¯ä»¥åœ¨åŒä¸€ä¸ª monad ä½¿ç”¨ä¸‰ä¸ª monad çš„æ–¹æ³•ï¼Œæ¯”å¦‚ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ Reader çš„ ask, State çš„ get, put, å’Œ Writer çš„ tell

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
readWriteState = do
  e <- ask
  a <- get
  let res = a + e
  put res
  tell [res]
  return res
runRWS readWriteState 1 2
-- (3 3 [3])
\end{lstlisting}

æ³¨æ„åˆ°è·Ÿ Reader å’Œ State ä¸€æ ·ï¼Œrunçš„æ—¶å€™è¾“å…¥åˆå§‹å€¼

å…¶ä¸­ 1 ä¸º Reader çš„å€¼ï¼Œ2 ä¸º State çš„åˆå§‹çŠ¶æ€.

\chapter{Monad Transform}
\label{sec:orgcb320a6}

ä½ ä¼šå‘ç° RWS ä¸€èµ·ç”¨æŒºå¥½çš„ï¼Œèƒ½è¯»èƒ½å†™èƒ½æ‰“ logï¼Œä½†æ˜¯å·²ç»å›ºå®šå¥½æ­é…äº†ï¼Œåªèƒ½æ˜¯ RWS ï¼Œå¦‚æœæˆ‘è¿˜æƒ³åŠ å…¥å…¶å®ƒçš„ Monadï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

è¿™æ—¶å€™ï¼Œç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åŠ ä¸ª Tï¼Œæ¯”å¦‚å¯¹äº Readerï¼Œæˆ‘ä»¬æœ‰ ReaderTï¼ŒRWSï¼Œä¹Ÿæœ‰å¯¹åº”çš„ RWSTã€‚å…¶ä¸­ T ä»£è¡¨ Transformã€‚

\section{ReaderT}
\label{sec:org6fd5901}

è®©æˆ‘æ¥é€šè¿‡ç®€å•çš„ ReaderT æ¥è§£é‡Šåˆ°åº•ä»€ä¹ˆæ˜¯ T å§, é¦–å…ˆè·Ÿ Reader ä¸€æ ·æˆ‘ä»¬æœ‰ä¸ª runReaderT

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
\end{lstlisting}

æ¯”è¾ƒä¸€ä¸‹ Reader çš„å®šä¹‰
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
newtype Reader e a = Reader { runReader :: (e -> a) }
\end{lstlisting}

æœ‰æ²¡æœ‰å‘ç°å¤šäº†ä¸€ä¸ª m, ä¹Ÿå°±æ˜¯è¯´, \texttt{runReader e} ä¼šè¿”å› a, ä½†æ˜¯ \texttt{runReaderT e} åˆ™ä¼šè¿”å› \texttt{m a}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-ReaderT.png}
\end{center}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance (Monad m) => Monad (ReaderT e m) where
    return   = lift . return
    r >>= k  = ReaderT $ \ e -> do
        a <- runReaderT r e
        runReaderT (k a) e
\end{lstlisting}

å†çœ‹çœ‹ monad çš„å®ç°, ä¹Ÿæ˜¯ä¸€æ ·çš„, å…ˆ run ä¸€ä¸‹ \texttt{r e} å¾—åˆ°ç»“æœ \texttt{a}, åº”ç”¨å‡½æ•° \texttt{k} åˆ° \texttt{a}, å† run ä¸€æŠŠ.


é—®é¢˜æ˜¯, è¿™é‡Œçš„ \texttt{return} é‡Œé¢çš„ \texttt{lift} æ˜¯å“ªæ¥çš„?

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance MonadTrans (ReaderT e) where
  lift m = ReaderT (const m)
\end{lstlisting}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-MonadTrans-ReaderT-e-m.png}
\end{center}

è¿™ä¸ªå‡½æ•° \texttt{lift} è¢«å®šä¹‰åœ¨ MonadTrans çš„å®ä¾‹ä¸­, ç®€å•çš„æŠŠ m æ”¾åˆ° ReaderT ç»“æœä¸­.

ä¾‹å¦‚, \texttt{lift (Just 1)} ä¼šå¾—åˆ° ReaderT, å…¶ä¸­ e éšæ„, m ä¸º Maybe Num

é‡ç‚¹éœ€è¦ä½“ä¼šçš„æ˜¯, Reader å¯ä»¥è¶Šè¿‡ Maybe ç›´æ¥æ“ä½œåˆ° Num, å®Œäº†å†åŒ…å›æ¥.

æœ‰äº† ReaderT, æ­é… Id Monad å°±å¾ˆå®¹æ˜“åˆ›å»ºå‡ºæ¥ Reader Monad

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
type Reader r a= ReaderT r Identity a
\end{lstlisting}

è¶Šè¿‡ Id read åˆ° Id å†…éƒ¨, å®Œäº†å†ç”¨ Id åŒ…å›æ¥, ä¸å°±æ˜¯ Reader äº†ä¹ˆ

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
ReaderT { runReaderT :: r -> Identity a }
-- Identity a is a
ReaderT { runReaderT :: r -> a }
\end{lstlisting}

\chapter{Alternative}
\label{sec:org4cd6769}

è¿™ä¸ª typeclass æä¾› \texttt{<|>} å‡½æ•°, è¡¨ç¤ºè¦ä¹ˆè®¡ç®—å·¦è¾¹, è¦ä¹ˆè®¡ç®—å³è¾¹

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
\end{lstlisting}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-Alternative.png}
\end{center}

å…¶å®å°±æ˜¯ Applicative çš„ \texttt{æˆ–}

æ¯”å¦‚:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Just 1 <|> Just 2 -- Just 1
Just 1 <|> Nothing -- Just 1
Nothing <|> Just 1 -- Just 1
Nothing <|> Nothing -- Nothing
\end{lstlisting}

\chapter{MonadPlus}
\label{sec:orgfe8531f}
è¿™è·Ÿ Alternative æ˜¯ä¸€æ¯›ä¸€æ ·çš„, åªæ˜¯é™åˆ¶çš„æ›´ç»†, å¿…é¡»æ˜¯ Monadæ‰è¡Œ

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
class (Alternative m, Monad m) => MonadPlus m where
   mzero :: m a
   mzero = empty
   mplus :: m a -> m a -> m a
   mplus = (<|>)
\end{lstlisting}

çœ‹, å®ç°ä¸­ç›´æ¥å°±è°ƒç”¨äº† Alternative çš„ \texttt{empty} å’Œ \texttt{<|>}

\chapter{ST Monad}
\label{sec:org9161e44}
ST Monad è·Ÿ State Monad çš„åŠŸèƒ½æœ‰äº›åƒ, ä¸è¿‡æ›´å‰å®³çš„æ˜¯, ä»–ä¸æ˜¯ immutable çš„, è€Œæ˜¯ "immutable" çš„åœ¨åŸåœ°åšä¿®æ”¹. æ”¹å®Œä¹‹å runST åˆç„¶ä»–å›åˆ°äº† immutable çš„ Haskell ä¸–ç•Œ.

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
sumST :: Num a => [a] -> a
sumST xs = runST $ do           -- do åé¢çš„äº‹æƒ…ä¼šæ˜¯ä¸é”™çš„å†…å­˜æ“ä½œ, runST å¯ä»¥æŠŠå®ƒæ‹‰ä¼šçº¯çš„ä¸–ç•Œ
    n <- newSTRef 0             -- åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€å—å¹¶æŒ‡åˆ° STRef
    forM_ xs $ \x -> do         -- è¿™è·Ÿå‘½ä»¤å¼çš„forå¾ªç¯æ”¹å†™å˜é‡æ˜¯ä¸€æ¯›ä¸€æ ·çš„
        modifySTRef n (+x)
    readSTRef n                 -- è¿”å›æ”¹å®Œä¹‹åçš„ n çš„å€¼
\end{lstlisting}

\chapter{Free Monad}
\label{sec:orgf40b2be}
ä¸Šä¸€ç« è¯´è¿‡çš„ RWS Monad æ¯•ç«Ÿæ˜¯å›ºå®šæ­é…ï¼Œå½“ä½ çš„ä¸šåŠ¡éœ€è¦æ›´å¤šçš„ Monad æ¥è¡¨ç¤º Effect æ—¶ï¼Œ
æˆ‘ä»¬å°±éœ€è¦æœ‰é‚£ä¹ˆä¸ªå°çŒªæ‰‹å¸®æˆ‘ä»¬å®šä¹‰è‡ªå·±çš„ Monadã€‚

é‚£å°±æ˜¯ Free, Free å¯ä»¥å°†ä»»æ„ datatype lift æˆä¸º Monad

\section{Free}
\label{sec:orged5e29d}
å…ˆçœ‹ Free ä»€ä¹ˆå®šä¹‰:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Free f a = Roll (f (Free f a)) | Return a
\end{lstlisting}

å…¶ä¸­ \texttt{f} å°±æ˜¯ä½ ä¸šåŠ¡éœ€è¦çš„ effect ç±»å‹, \texttt{a} æ˜¯è¿™ä¸ª effect æ‰€äº§ç”Ÿçš„è¿”å›å€¼ç±»å‹ã€‚

å³è¾¹ä¸¤ç§æ„é€ å‡½æ•°ï¼Œå¦‚æœæŠŠ \texttt{Role} æ”¹æˆ \texttt{Cons}, \texttt{Return} æ”¹æˆ \texttt{Nil} çš„è¯, æ˜¯ä¸æ˜¯è·Ÿ List å…¶å®æ˜¯ åŒæ„/isomophic çš„å‘¢? æ‰€ä»¥å¦‚æœæƒ³è±¡æˆ List, é‚£ä¹ˆ \texttt{f} åœ¨è¿™é‡Œå°±ç›¸å½“äº List ä¸­çš„ä¸€ä¸ªå…ƒç´ .

åˆ°é‚£æ—¶, \texttt{>>=} çš„æ“ä½œåˆè·Ÿ List ç•¥æœ‰ä¸åŒ, æˆ‘ä»¬éƒ½çŸ¥é“ \texttt{>>=} ä¼šæŠŠæ¯ä¸€ä¸ªå…ƒç´  map æˆ List, ç„¶å flatten, ä½† Free å…¶å®æ˜¯ç”¨æ¥æ„å»º
é¡ºåºçš„ effect çš„, æ‰€ä»¥:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Functor f => Monad (Free f) where
  return a        = Return a
  Return a >>= fn = fn a
  Roll ffa >>= fn = Roll $ fmap (>>= fn) ffa
\end{lstlisting}

ä½ ä¼šå‘ç° \texttt{>>=} ä¼šé€’å½’çš„ \texttt{fmap} åˆ° \texttt{Roll} ä¸Š, ç›´åˆ°æœ€åä¸€ä¸ª \texttt{Return}.

æ¯”å¦‚, å¦‚æœä½ æœ‰ä¸€ä¸ª program æœ‰ä¸‰ç§å‰¯ä½œç”¨ Eff1, Eff2, Eff3

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Eff a = Eff1 a | Eff2 a | Eff3 a
program = do
 a <- liftF $ Eff1 1
 b <- liftF $ Eff2 2
 c <- liftF $ Eff3 3
 return a + b + c
\end{lstlisting}

å¦‚æœæˆ‘ä»¬æŠŠ program å±•å¼€, æ¯ä¸€æ­¥ \texttt{>>=} å¤§æ¦‚æ˜¯è¿™æ ·:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
liftF $ Eff1 1
\end{lstlisting}

å±•å¼€æ—¢æ˜¯:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Roll (Eff1 (Return 1))
\end{lstlisting}

ä»£å…¥åˆ° program å³:
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll (Eff1 (Return 1)) >>= \a -> do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
\end{lstlisting}

ç”¨ Free çš„ \texttt{>>=} å…¬å¼ \texttt{Roll ffa >>= fn = Roll \$ fmap (>>= fn) ffa} å»å±•å¼€ä¸Šé¢å°±å¾—åˆ°:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll $ Eff1 (Return 1 >>= fn1)) where
  fn1 = \a -> do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
\end{lstlisting}

\texttt{Return 1 >>= fn1} æˆ‘ä»¬éƒ½çŸ¥é“æ€ä¹ˆå±•å¼€:

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll $ Eff1 (fn1 1) where
  fn1 = \a -> do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
\end{lstlisting}

å±•å¼€ \texttt{fn1}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll $ Eff1 do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return 1 + b + c
\end{lstlisting}


åŒæ ·çš„æ­¥éª¤å±•å¼€ Eff2
\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll $ Eff1 $ Roll $ Eff2 do
   c <- liftF $ Eff3 3
   return 1 + 2 + c
\end{lstlisting}

å’Œ Eff3

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll $ Eff1 $ Roll $ Eff2 $ Roll $ Eff3 do
   return 1 + 2 + 3
\end{lstlisting}

æœ€åçš„ program æ˜¯ä¸æ˜¯å¾ˆåƒ List çš„ Cons å’Œ Nil å‘¢?

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
program = Roll $ Eff1 $ Roll $ Eff2 $ Roll $ Eff3 $ Return 1 + 2 + 3
\end{lstlisting}


ä½†æ˜¯, ç»†å¿ƒçš„ä½ å¯èƒ½æ—©éƒ½å‘ç°äº† \texttt{Eff} è¿™è´§å¿…é¡»æ˜¯ä¸ª \texttt{Functor} æ‰è¡Œ. é‚£æˆ‘ä»¬å¦‚ä½•éšä¾¿å®šä¹‰ä¸€ä¸ª \texttt{data Eff} ç›´æ¥èƒ½ç”Ÿæˆ \texttt{Functor Eff} çš„å®ä¾‹å‘¢?

\section{Coyoneda}
\label{sec:org496bb2d}

å¸Œæœ›ä½ è¿˜ä¾ç„¶è®°å¾—ç¬¬ä¸€éƒ¨åˆ†çš„ç±³ç”° \sout{å…±} å¼•ç†

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data CoYoneda f a = forall b. CoYoneda (b -> a) (f b)
\end{lstlisting}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-CoYoneda.png}
\end{center}

äº‹å®ä¸Šå¾ˆç®€å•å¯ä»¥æŠŠä»»ä½• \texttt{f} å˜æˆ \texttt{CoYoneda f}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
phi :: f a -> CoYoneda f a
phi fa = CoYoneda id fa
\end{lstlisting}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-CoYoneda-phi.png}
\end{center}

è¯€çªå°±æ˜¯ \texttt{id}, ä¹Ÿå°±æ˜¯ä½ æŠŠ \texttt{b} å˜æˆ \texttt{a}, å†æŠŠ \texttt{fa} æ”¾åˆ° \texttt{CoYoneda} é‡Œå°±å¥½äº†

å½“ \texttt{f} æ˜¯ \texttt{Functor} æ—¶, åˆå¯ä»¥æŠŠ \texttt{CoYoneda} å˜æˆ \texttt{f}

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
psi :: Functor f => CoYoneda f a -> f a
psi (CoYoneda g fa) = fmap g fa
\end{lstlisting}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-CoYoneda-psi.png}
\end{center}

åè¿‡æ¥çš„è¿™ä¸ªä¸é‡è¦, é‡è¦çš„æ˜¯ \texttt{phi}, å› ä¸ºå¦‚æœä½ å¯ä»¥æŠŠä»»ä½• \texttt{f} å˜æˆ \texttt{CoYoneda f}, è€Œ \texttt{CoYoneda f} åˆæ˜¯ \texttt{Functor},
æˆ‘ä»¬ä¸å°±å…è´¹å¾—åˆ°ä¸€ä¸ª \texttt{Functor}?

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
instance Functor (Coyoneda f) where
  fmap f (Coyoneda g fb) = Coyoneda (f . g) fb
\end{lstlisting}

\section{Free Functor}
\label{sec:orged06f0c}
æ¯”å¦‚æˆ‘ä»¬çš„ \texttt{Eff} å°±å¯ä»¥ç›´æ¥é€šè¿‡ \texttt{phi} å˜æˆ \texttt{CoYoneda Eff}, ä»è€Œå¾—åˆ°å…è´¹çš„ Functor

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
data Eff a = Eff1 a | Eff2 a | Eff3 a
program = Roll (phi (Eff1 (Roll (phi (Eff2 (Return Int))))))
\end{lstlisting}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-Free.png}
\end{center}

\section{Interpreter}
\label{sec:org66a58c8}
æ„é€ å®Œä¸€ä¸ª free program å,æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªåµŒå¥—çš„æ•°æ®ç»“æ„, å½“æˆ‘ä»¬éœ€è¦ run è¿™ä¸ª program æ—¶, æˆ‘ä»¬éœ€è¦ foldMap ä¸€ä¸ª
Interpreter å»ä¸€å±‚å±‚æ‹¨å¼€ è¿™ä¸ª free program.

\lstset{language=haskell,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
foldMap :: Monad m => (forall x . f x -> m x) -> Free f a -> m a
foldMap _ (Return a)  = return a
foldMap f (Roll a) = f a >>= foldMap f
\end{lstlisting}

\chapter{Free Monoid}
\label{sec:orga863419}
\chapter{Eff}
\label{sec:orgef082b8}

\chapter{Comonad}
\label{sec:org058f2f5}
\end{document}
