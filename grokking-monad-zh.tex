% Created 2020-07-19 Sun 22:43
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{tufte-book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{ucs}
\usepackage{xeCJK}
\setCJKmainfont{STXihei}
\usepackage{graphicx}
  \setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
  \graphicspath{{graphics/}} % set of paths to search for images
\usepackage{booktabs} % book-quality tables
\usepackage{units}    % non-stacked fractions and better unit spacing
\usepackage{multicol} % multiple column layout facilities
\usepackage{lipsum}   % filler text
\usepackage{fancyvrb} % extended verbatim environments
  \fvset{fontsize=\normalsize}% default font size for fancy-verbatim environments
\setcounter{secnumdepth}{3}
\author{æ¬§é˜³ç»§è¶…}
\date{\textit{<2017-02-10 Fri>}}
\title{Grokking Monad}
\hypersetup{
 pdfauthor={æ¬§é˜³ç»§è¶…},
 pdftitle={Grokking Monad},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\part{ç¬¬ä¸€éƒ¨åˆ†ï¼šçŒ«è®º/Catergory Theory}
\label{sec:org0998dc3}

\begin{center}
\includegraphics[width=.9\linewidth]{./images/Cheshire_Cat.png}
\end{center} \footnote{\url{https://en.wikipedia.org/wiki/Cheshire\_Cat}}

\begin{quote}
`But I donâ€™t want to go among mad people,â€™ Alice remarked.

`Oh, you canâ€™t help that,â€™ said the Cat: `weâ€™re all mad here. Iâ€™m mad. Youâ€™re mad.â€™

`How do you know Iâ€™m mad?â€™ said Alice.
`You must be,â€™ said the Cat, `or you wouldnâ€™t have come here.â€™

Alice didnâ€™t think that proved it at all; however, she went on `And how do you know that youâ€™re mad?â€™

-- Alice's Adventures in Wonderland
\end{quote}

å•å­/Monadæ˜¯ä»€ä¹ˆ? ä½ ä¹Ÿä¸æ‡‚, æˆ‘ä¹Ÿä¸æ‡‚, æˆ‘ä»¬éƒ½ä¸æ‡‚.

è¯è¯´, æˆ‘åˆæ€ä¹ˆçŸ¥é“ä½ ä¸æ‡‚å‘¢?

å½“ç„¶ä¸æ‡‚, ä¸ç„¶, ä½ æ€ä¹ˆä¼šæ¥åˆ°è¿™é‡Œ?

æˆ‘åˆæ˜¯æ€ä¹ˆçŸ¥é“è‡ªå·±ä¸æ‡‚å‘¢?

å› ä¸º, æˆ‘çŸ¥é“æ‡‚çš„äººä»€ä¹ˆæ ·å­. æ˜¾ç„¶, æˆ‘ä¸æ˜¯.

æ‡‚çš„äººä¸€å®šçŸ¥é“çŒ«è®º/ Category Theory.

æ‡‚çŒ«è®ºçš„äººåˆä¸ä¸€å®šçŸ¥é“ç¼–ç¨‹. ä½†æ˜¯æ‡‚ç¼–ç¨‹çš„äººå¯ä»¥ç•¥æ‡‚çŒ«è®º.

ç¼–ç¨‹æ˜¯é¡¹æŠ€æœ¯, å³ç†è®ºçš„é™ç»´. æ‰€ä»¥è¦é™ä½é—¨æ§›, æ¯”å¦‚æˆ‘åœ¨ä¹¦ä¸­ä¹Ÿ\href{https://book.douban.com/subject/26883736/}{å†™è¿‡ä¸€ç« }ç”¨JavaScriptæ¥è§£é‡Šï¼ŒæŸäººä¹Ÿå°è¯•è¿‡\href{http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html}{å†™åšå®¢è§£é‡Š}ï¼Œ\footnote{å¦‚æœæ²¡çœ‹å°±åˆšå¥½ä¸è¦çœ‹äº†, ç¡®å®æœ‰äº›è¯¯å¯¼}æ²¡æƒ³åˆ°é‚£äº›ä¹Ÿä¸çŸ¥é“ä¼šä¸ä¼š Haskell/Scala çš„äººå°±è·‘å‡ºæ¥å–·ä½ ä»¬å‰ç«¯\footnote{ç­‰ç­‰, å†™å‰ç«¯æ€ä¹ˆäº†? JavaScript åªæ˜¯æˆ‘è§‰å¾—é¡ºæ‰‹çš„è‹¥å¹²è¯­è¨€ä¹‹ä¸€, JSç”¨æˆ·é‚£ä¹ˆå¤š, å†™ä¹¦å½“ç„¶è¦ç”¨ JS å•¦, éš¾é“ç”¨ Idris é‚£è¿˜èƒ½å–å¾—æ‰å—? \sout{å½“ç„¶æœ€åç”¨JSä¹Ÿæ²¡æ€ä¹ˆå–æ‰\ldots{}}}è¿™äº›ä¸æ‡‚å‡½æ•°å¼çš„æ¸£æ¸£ä¹±æå‡ºæ¥çš„ä¸œè¥¿æ ¹æœ¬å°±ä¸æ˜¯å•å­ã€‚

æˆ‘ä¹Ÿç”»è¿‡ä¸€äº›å›¾æ¥è§£é‡Šï¼Œåˆä¼šè¢«å«Œå¼ƒç”»é£ä¸å¥½ã€‚ä½†æ˜¯ï¼Œä½œä¸ºçµé­‚ç”»å¸ˆï¼Œæˆ‘åª \sout{æ˜¯è§‰å¾—è‡ªå·±èŒèŒçš„å•Š} åœ¨ä¹ç”»çš„çµé­‚æ˜¯å¦èƒ½å¤Ÿç»™ä½ ä¸€ç‚¹å¯å‘ã€‚å¥½å§ï¼Œè®²è¿™ä¹ˆå­¦æœ¯çš„ä¸œè¥¿ï¼Œè¿˜æ˜¯ç”¨dotæ¥ç”»å§ï¼Œçœ‹èµ·æ¥å¥½æ­£è§„å‘¢ã€‚

å¥½äº†ï¼Œå®‰å…¨å¸¦ç³»å¥½ï¼Œæˆ‘çœŸçš„è¦å¼€è½¦äº†ã€‚ä¸ºäº†é˜²æ­¢è§£é‡Šçš„ä¸åˆ°ä½/åˆè¢«å–·ï¼Œå°±ç”¨ Haskell/Scala å¥½äº†\footnote{å¹¶ä¸æ˜¯è¯´è¿™ä¸¤é—¨è¯­è¨€ä¸€å®šåœ¨é„™è§†é“¾é¡¶ç«¯, è€Œæ˜¯æ‹¥æœ‰å¼ºå¤§ç±»å‹ç³»ç»Ÿçš„è¯­è¨€æ‰èƒ½ä½“ç°å‡ºèŒƒç•´è®ºçš„å†…å®¹}ï¼Œå…¶å®ä¹Ÿä¸éš¾è§£é‡Šæ¸…æ¥š \sout{æ‰æ€ª} ã€‚

è¿™é‡Œé¢å¾ˆå¤šå¾ˆè£…é€¼çš„å•è¯ï¼Œå®ƒä»¬éƒ½æ˜¯ \emph{æ–œä½“} ï¼Œå°±ç®—æ²¡çœ‹æ‡‚ï¼ŒæŠŠè¿™äº›è¯èƒŒä¸‹æ¥ä¹Ÿè¶³å¤Ÿè£…å¥½ä¸€é˜µå­é€¼äº†/ä¹°ä¸€é˜µå­èŒäº†ã€‚

è¿™é‡Œè¿˜æœ‰å¾ˆå¤šä»£ç , å®ƒä»¬éƒ½æˆå¯¹å‡ºç°, ç¬¬ä¸€æ®µæ˜¯ Haskell, ç¬¬äºŒæ®µæ˜¯ Scala.

\chapter{\emph{Category}}
\label{sec:org7808b7f}
\index{Catergory}
\index{èŒƒç•´}

ä¸€ä¸ª \emph{èŒƒç•´/Category} åŒ…å«ä¸¤ä¸ªç©æ„
\begin{itemize}
\item ä¸œè¥¿ \texttt{O} ï¼ˆObjectï¼‰
\item ä¸¤ä¸ªä¸œè¥¿çš„å…³ç³»ï¼Œç®­å¤´ \texttt{\textasciitilde{}>} ï¼ˆ \emph{æ€å°„/Morphism} ï¼‰
\end{itemize}

è¿˜å¿…é¡»å¸¦ä¸Šä¸€äº›å±æ€§: 
\begin{itemize}
\item ä¸€å®šæœ‰ä¸€ä¸ªå« id çš„ç®­å¤´ï¼Œä¹Ÿå«åš 1
\item ç®­å¤´å¯ä»¥ \emph{ç»„åˆ} compose/
\end{itemize}

æ©, å°±æ˜¯è¿™ä¹ˆç®€å•!

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/category.png}
\caption{æœ‰ä¸œè¥¿ a, b, c å’Œç®­å¤´ f, g çš„ Categoryï¼Œå…¶ä¸­ f . g è¡¨ç¤º compose f å’Œ g}
\end{figure}


\begin{quote}
æ³¨æ„åˆ°ä¸ºä»€ä¹ˆæˆ‘ä¼šç®­å¤´ä»å³å¾€å·¦ï¼Œæ¥ç€çœ‹ä»£ç , ä½ ä¼šå‘ç°è¿™ä¸ªæ–¹å‘è·Ÿ compose çš„æ–¹å‘åˆšå¥½ä¸€è‡´!
\end{quote}

è¿™äº›ç©æ„å¯¹åº”åˆ° haskell çš„ typeclass å¤§è‡´å°±æ˜¯è¿™æ ·:

\begin{verbatim}
class Category (c :: * -> * -> *) where
  id :: c a a
  (.) :: c y z -> c x y -> c x z
\end{verbatim}


è€Œ Scala å¯ä»¥ç”¨ trait æ¥è¡¨ç¤ºè¿™ä¸ª typeclass:
\begin{verbatim}
trait Category[C[_, _]] {
  val id[A]: C[A, A]
  def <<<(a: C[Y, Z], b: C[X, Y]): C[X, Z] 
}
\end{verbatim}

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° Haskell ä»£ç ï¼Œæ²¡æœ‰å…³ç³»ï¼Œè¯­æ³•çœŸçš„å¾ˆç®€å• \sout{æ‰æ€ª}
\begin{itemize}
\item \texttt{class} å®šä¹‰äº†ä¸€ä¸ª TypeClassï¼Œ \texttt{Category} æ˜¯è¿™ä¸ª TypeClass çš„åå­—
\item Type class ç±»ä¼¼äºå®šä¹‰ç±»å‹çš„è§„èŒƒï¼Œè§„èŒƒä¸º \texttt{where} åé¢é‚£ä¸€å¨
\item ç±»å‹è§„èŒƒçš„å¯¹è±¡æ˜¯å‚æ•° \texttt{(c:: * -> * -> *)} ï¼Œ \texttt{::} åé¢æ˜¯cçš„ç±»å‹
\item c æ˜¯ \emph{higher kind} \texttt{* -> *} ï¼Œè·Ÿhigher order functionçš„å®šä¹‰å·®ä¸å¤šï¼Œå®ƒæ˜¯æ¥æ”¶ç±»å‹ï¼Œæ„é€ æ–°ç±»å‹çš„ç±»å‹ã€‚è¿™é‡Œçš„ c æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå†æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå°±å¯ä»¥è¿”å›ä¸ªç±»å‹ã€‚
\end{itemize}
\index{Kind}
\begin{itemize}
\item \texttt{id:: c a a} è¡¨ç¤º c èŒƒç•´ä¸Šçš„ a åˆ° a çš„ç®­å¤´
\item \texttt{.} çš„æ„æ€ c èŒƒç•´ä¸Šï¼Œå¦‚æœå–‚ä¸€ä¸ª y åˆ° z çš„ç®­å¤´ï¼Œå†å–‚ä¸€ä¸ª x åˆ° y çš„ç®­å¤´ï¼Œé‚£ä¹ˆå°±è¿”å› x åˆ° z çš„ç®­å¤´ã€‚
\end{itemize}

å¦å¤– compose åœ¨ haskell ä¸­ç›´æ¥æ˜¯å¥å· \texttt{.}

scala ä¸­ç”¨ \texttt{<<<} æˆ–è€… \texttt{compose}

æ€»ä¹‹, ç”¨æ–‡å­—å†è¯»ä¸€éä¸Šé¢è¿™äº›ä»£ç å°±äº†ç„¶äº†.

èŒƒç•´ C å…¶å®å°±åŒ…å«
\begin{enumerate}
\item è¿”å› A å¯¹è±¡åˆ° A å¯¹è±¡çš„ id ç®­å¤´
\item å¯ä»¥ç»„åˆ Y å¯¹è±¡åˆ° Z å¯¹è±¡ å’Œ X å¯¹è±¡åˆ° Y å¯¹è±¡çš„ç®­å¤´ compose
\end{enumerate}

ç®€å•å§/hen nan ba?è¿˜æ²¡æœ‰é«˜æ•°æŠ½è±¡å‘¢ã€‚

\section{\emph{Hask}}
\label{sec:orgac3c44b}
Haskell ç±»å‹ç³»ç»ŸèŒƒç•´å«åš Hask
\index{Hask}

åœ¨ Hask èŒƒç•´ä¸Šï¼š

\begin{itemize}
\item ä¸œè¥¿å°±æ˜¯ç±»å‹
\item ç®­å¤´æ˜¯ç±»å‹çš„å˜æ¢ï¼Œå³ \texttt{->}
\item id å°±æ˜¯ id å‡½æ•°çš„ç±»å‹ \texttt{a -> a}
\item compose å½“ç„¶å°±æ˜¯å‡½æ•°ç»„åˆçš„ç±»å‹
\end{itemize}

\begin{verbatim}
type Hask = (->)
instance Category (Hask:: * -> * -> *) where
  (f . g) x = f (g x)
\end{verbatim}

æˆ‘ä»¬çœ‹è§æ–°çš„å…³é”®å­— \texttt{instance} ï¼Œè¿™è¡¨ç¤º Hask æ˜¯ Type class Category çš„å®ä¾‹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹ä»»æ„Haskç±»å‹, é‚£ä¹ˆå°±èƒ½æ‰¾åˆ°å®ƒçš„ id å’Œ compose

\begin{verbatim}
implicit val haskCat: Category[Hask[_, _]] = new Category[Hask] {
  val id[A] = identity[A]
  def <<<[X, Y, Z](a: Hask[Y, Z], b: Hask[X, Y]) = a compose b
}
\end{verbatim}

Scala ä¸­, åªéœ€è¦ new è¿™ä¸ª trait å°±å¯ä»¥å®ç°è¿™ä¸ª typeclass

å…¶ä¸­: identity \texttt{Hask a a} å°±æ˜¯
\begin{verbatim}
(->) a a -- or
a -> a -- å› ä¸º -> æ˜¯ä¸­ç¼€æ„é€ å™¨
\end{verbatim}

\begin{verbatim}
A => A
\end{verbatim}
\section{\emph{Duel}}
\label{sec:org510f00a}
\index{Duel}
æ¯ä¸ª Category è¿˜æœ‰ä¸€ä¸ªé•œåƒï¼Œä»€ä¹ˆéƒ½ä¸€æ ·ï¼Œé™¤äº†ç®­å¤´æ˜¯åçš„

\chapter{å‡½å­ / Functor}
\label{sec:orgeff4bd7}
\index{Functor}
\index{å‡½å­}
ä¸¤ä¸ªèŒƒç•´ä¸­é—´å¯ä»¥ç”¨å« Functor çš„ä¸œè¥¿æ¥è¿æ¥èµ·æ¥ï¼Œç®€ç§° Tã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/functor.png}
\caption{Functor C D T, ä» C åˆ° D èŒƒç•´çš„Functor T}
\end{figure}

æ‰€ä»¥å¤§éƒ¨åˆ†æŠŠ Functor/Monad æ¯”å–»æˆç›’å­å…¶å®åœ¨å®šä¹‰ä¸Šæ˜¯é”™çš„ï¼Œè™½ç„¶è¿™æ ·æ¯”å–»æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œåœ¨ä½¿ç”¨ä¸Šé—®é¢˜ä¹Ÿä¸å¤§ã€‚ä½†æ˜¯ï¼ŒFunctor åªæ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„æ˜ å°„å…³ç³»è€Œå·²ã€‚

\begin{itemize}
\item èŒƒç•´é—´ ä¸œè¥¿çš„ Functor æ ‡è®°ä¸º \texttt{T(O)}
\item èŒƒç•´é—´ ç®­å¤´çš„ Functor æ ‡è®°ä¸º \texttt{T(\textasciitilde{}>)}
\item ä»»ä½•èŒƒç•´Cä¸Šå­˜åœ¨ä¸€ä¸ª T æŠŠæ‰€æœ‰çš„ O å’Œ \textasciitilde{}> éƒ½æ˜ å°„åˆ°è‡ªå·±ï¼Œæ ‡è®°ä¸ºid functor 1\(_{\text{C}}\)
\begin{itemize}
\item 1\(_{\text{C}}\)(O) = O
\item 1\(_{\text{C}}\)(\textasciitilde{}>) = \textasciitilde{}>
\end{itemize}
\end{itemize}

\begin{verbatim}
class (Category c, Category d) => Functor c d t where
  fmap :: c a b -> d (t a) (t b)
\end{verbatim}

\begin{verbatim}
trait Functor[C[_, _], D[_, _], T[_]] {
  def fmap[A, B](c: C[A, B]): D[T[A], T[B]]
}
\end{verbatim}

\texttt{Functor c d t} è¿™è¡¨ç¤ºä»èŒƒç•´ c åˆ°èŒƒç•´ d çš„ä¸€ä¸ª Functor t

å¦‚æœæŠŠèŒƒç•´ c å’Œ d éƒ½é™åˆ¶åˆ° Hask èŒƒç•´

\begin{verbatim}
class Functor (->) (->) t where
  fmap :: (->) a b -> (->) (t a) (t b)
\end{verbatim}

\begin{verbatim}
trait Functor[=>[_, _], =>[_, _], T[_]] {
 def fmap[A, B](c: =>[A, B]): =>[T[A], T[B]]
}
\end{verbatim}
\texttt{->} åœ¨ Haskell ä¸­æ˜¯ä¸­ç¼€ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥å†™åœ¨ä¸­é—´çš„

è¿™æ ·å°±ä¼šå˜æˆæˆ‘ä»¬ç†Ÿæ‚‰çš„ Funtor çš„ Typeclass\footnote{è¿™é‡Œå¯ä»¥æŠŠ Functor çš„ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°æ¶ˆæ‰, å› ä¸ºå·²ç»çŸ¥é“æ˜¯åœ¨ Hask èŒƒç•´äº†}

\begin{verbatim}
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
\end{verbatim}

\begin{verbatim}
trait Functor[T[_]] {
 def fmap[A, B](c: A => B): T[A] => T[B]
}
\end{verbatim}

è€Œ \emph{è‡ªå‡½å­/endofunctor} å°±æ˜¯è¿™ç§è¿æ¥ç›¸åŒèŒƒç•´çš„ Functorï¼Œå› ä¸ºå®ƒä»èŒƒç•´ Hask åˆ°è¾¾åŒæ ·çš„èŒƒç•´ Hask
\index{endofunctor}
\index{è‡ªå‡½å­}

è¿™å›çœ‹ä»£ç å°±å¾ˆå®¹æ˜“å¯¹åº”ä¸Šå›¾å’Œæ¦‚å¿µäº†, è¿™é‡Œçš„è‡ªå‡½å­åªæ˜¯æ˜ å°„èŒƒç•´ \texttt{->} åˆ° \texttt{->}, ç®­å¤´å‡½æ•°é‚£ä¸ªç®­å¤´, ç±»å‹å´å˜æˆäº† t a

è¿™é‡Œçš„ fmap å°±æ˜¯ T(\textasciitilde{}>)ï¼Œåœ¨ Hask èŒƒç•´ä¸Šï¼Œæ‰€ä»¥æ˜¯ T(->), è¿™ä¸ªç®­å¤´æ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿèƒ½è¡¨ç¤ºæˆ T(f) å¦‚æœ \texttt{f:: a -> b}

\chapter{\emph{Cat} +çŒ«+/}
\label{sec:org248e5d9}

é€’å½’çš„, å½“æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ª Category çœ‹æˆä¸€ä¸ª objectï¼Œfunctor çœ‹æˆç®­å¤´ï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆå¾—åˆ°äº†ä¸€ä¸ª Categoryï¼Œè¿™ç§ object æ˜¯ category çš„ category æˆ‘ä»¬å«å®ƒ -- \emph{Cat}

å·²ç»æ²¡/ meowçš„åŠæ³•ç”¨è¯­è¨€æè¿°è¿™ä¹ˆé«˜ç»´åº¦çš„äº‹æƒ…äº†ï¼Œçœ‹å›¾å§\ldots{}

\chapter{è‡ªç„¶å˜æ¢ / Natural Transformations \label{org75e4d4a}}
\label{sec:orgc943a0e}

Functor æ˜¯èŒƒç•´é—´çš„æ˜ å°„ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ª Cat èŒƒç•´ä¸­, æŠŠèŒƒç•´çœ‹æˆæ˜¯å¯¹è±¡, é‚£ä¹ˆ Functor åœ¨ Cat èŒƒç•´åˆæ˜¯ä¸ªç®­å¤´
\index{Natural Transformations}
\index{è‡ªç„¶å˜æ¢}

\begin{center}
\includegraphics[width=.9\linewidth]{images/natrual-transformation.png}
\end{center}
è€Œ Functor é—´ä¹Ÿæœ‰æ˜ å°„ï¼Œå«åš \sout{å–µçš„å˜æ¢} \emph{è‡ªç„¶å˜æ¢}

èŒƒç•´ c ä¸Šçš„å‡½å­ f åˆ° g çš„è‡ªç„¶å˜åŒ–å°±å¯ä»¥è¡¨ç¤ºæˆ
\begin{verbatim}
type Nat c f g = c (f a) (g a)
\end{verbatim}

Scala æ²¡æœ‰ rank n type\footnote{åˆ«æ€¥, åé¢é©¬ä¸Šè®²åˆ°}, åªèƒ½é  apply æ¥ meme äº†
\begin{verbatim}
trait Nat[C[_, _], F[_], G[_]] {
  def apply[A]: C[F[A], G[A]]
}
\end{verbatim}

Hask èŒƒç•´ä¸Šçš„è‡ªç„¶å˜åŒ–å°±å˜æˆäº†

\begin{verbatim}
type NatHask f g = f a -> g a
\end{verbatim}

\begin{verbatim}
trait NatHask[F[_], G[_]] {
  def apply[A]: F[A] => G[A]
}

\end{verbatim}

æœ‰è¶£çš„æ˜¯, è¿˜å¯ä»¥ç»§ç»­å‡ç»´åº¦, æ¯”å¦‚

\begin{itemize}
\item ä¸œè¥¿æ˜¯å‡½å­
\item ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢
\end{itemize}

æ­å–œä½ åˆ°è¾¾ Functor èŒƒç•´.

å½“ç„¶, è¦æˆä¸ºèŒƒç•´ï¼Œè¿˜æœ‰ä¸¤ä¸ªå±æ€§:
\begin{itemize}
\item id ä¸º f a åˆ° f a çš„è‡ªç„¶å˜æ¢
\item è‡ªç„¶å˜æ¢çš„ç»„åˆ
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{images/functor-category.png}
\end{center}

åˆ«ç€æ€¥, æˆ‘ä»¬æ¥æ¢³ç†ä¸€ä¸‹ï¼Œå¦‚æœå·²ç»ä¸çŸ¥é“å‡äº†å‡ ä¸ªç»´åº¦äº†ï¼Œæˆ‘ä»¬å‡è®¾ç±»å‹æ‰€åœ¨èŒƒç•´æ˜¯ç¬¬ä¸€ç»´åº¦
\begin{itemize}
\item ä¸€ç»´ï¼š Haskï¼Œ ä¸œè¥¿æ˜¯ç±»å‹ï¼Œç®­å¤´æ˜¯ ->
\item äºŒç»´ï¼š Catï¼Œ ä¸œè¥¿æ˜¯ Haskï¼Œ ç®­å¤´æ˜¯ Functor
\item ä¸‰ç»´ï¼š FunctorèŒƒç•´ï¼Œ ä¸œè¥¿æ˜¯Functorï¼Œ ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢
\end{itemize}

æ„Ÿè§‰åˆ°è¾¾ä¸‰ç»´å·²ç»æ˜¯æé™äº†ï¼Œå°¼ç›è¿˜æœ‰å®Œæ²¡å®Œäº†ï¼Œæ¯å‡ä¸€ä¸ªç»´åº¦è¿˜è¦èµ·è¿™ä¹ˆå¤šè£…é€¼çš„åå­—ï¼Œå†å‡ç»´åº¦è€å­å°±ç”»ä¸å‡ºæ¥äº†

æ‰€ä»¥è¿™æ—¶å€™, éœ€è¦å¼•å…¥ String Diagramã€‚

\chapter{String Diagram}
\label{sec:org050993a}

String Diagram çš„æ¦‚å¿µå¾ˆç®€å•ï¼Œå°±æ˜¯ç‚¹å˜çº¿çº¿å˜ç‚¹ã€‚

è¿˜è®°å¾—å½“æœ‰äº†è‡ªç„¶å˜æ¢ä¹‹åï¼Œä¸‰ä¸ªç»´åº¦å·²ç»æ²¡æ³•è¡¨ç¤ºäº†ï¼Œé‚£åŸæ¥çš„ç‚¹å’Œçº¿éƒ½å‡ä¸€ç»´åº¦ï¼Œå˜æˆçº¿å’Œé¢ï¼Œè¿™æ ·ï¼Œå°±è…¾å‡ºä¸€ä¸ªç‚¹æ¥è¡¨ç¤ºè‡ªç„¶å˜æ¢äº†ã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-string-diagram.png}
\caption{String Diagramï¼šè‡ªç„¶å˜æ¢æ˜¯ç‚¹ï¼ŒFunctoræ˜¯çº¿ï¼ŒèŒƒç•´æ˜¯é¢}
\end{figure}

composeçš„æ–¹å‘æ˜¯ä»å³å¾€å·¦ï¼Œä»ä¸‹åˆ°ä¸Šã€‚

\chapter{\emph{Adjunction Functor} ä¼´éšå‡½å­}
\label{sec:org7e0062a}
\index{Adjunction Functor}
èŒƒç•´Cå’ŒDç›´æ¥æœ‰æ¥æœ‰å›çš„å‡½å­ï¼Œä¸ºä»€ä¹ˆè¦ä»‹ç»è¿™ä¸ªï¼Œå› ä¸ºå®ƒç›´æ¥å¯ä»¥æ¨å‡º Monad

è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä»€ä¹ˆå«æœ‰æ¥å›ã€‚

\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-adjunction-functor.png}
\end{center}

å…¶ä¸­ï¼š

\begin{itemize}
\item ä¸€ä¸ªèŒƒç•´ C å¯ä»¥é€šè¿‡å‡½å­ G åˆ° Dï¼Œå†é€šè¿‡å‡½å­ F å›åˆ° Cï¼Œé‚£ä¹ˆ F å’Œ G å°±æ˜¯ä¼´éšå‡½å­ã€‚
\item \(\eta\) æ˜¯ GF åˆ° 1\(_{\text{D}}\) çš„è‡ªç„¶å˜æ¢
\item \(\epsilon\) æ˜¯ 1\(_{\text{C}}\) åˆ° FG çš„è‡ªç„¶å˜æ¢
\end{itemize}

åŒæ—¶æ ¹æ®åŒæ„çš„å®šä¹‰ï¼ŒG ä¸ F æ˜¯ \emph{åŒæ„} çš„ã€‚
\index{isomorphic}
\index{åŒæ„}

åŒæ„æŒ‡çš„æ˜¯è‹¥æ˜¯æœ‰
\begin{verbatim}
f :: a -> b
f':: b -> a
\end{verbatim}

é‚£ä¹ˆ f ä¸ f' åŒæ„ï¼Œå› ä¸º f . f' = id = f' . f

ä¼´éšå‡½å­çš„ FG ç»„åˆæ˜¯ C èŒƒç•´çš„ id å‡½å­ F . G = 1\(_{\text{c}}\)

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-compose.png}
\caption{ä¼´éšå‡½å­çš„ä¸¤ä¸ªFunctorç»„åˆ, å·¦ä¾§ä¸º F eta, å³ä¾§ä¸º epsilon F}
\end{figure}

Functor ä¸ä»…æ¨ªç€å¯ä»¥ç»„åˆï¼Œç«–ç€(è‡ªç„¶å˜æ¢ç»´åº¦)ä¹Ÿæ˜¯å¯ä»¥ç»„åˆçš„ï¼Œå› ä¸ºè‡ªç„¶å˜æ¢æ˜¯ Functor èŒƒç•´çš„ç®­å¤´ã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-compose-nat.png}
\caption{F eta . epsilon F  = F}
\end{figure}

å½“åˆ°ç»„åˆ F \(\eta\) . \(\epsilon\) F å¾—åˆ°ä¸€ä¸ªå¼¯å¼¯æ›²æ›²çš„ F æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æ‹½ç€Fçš„ä¸¤æ®µä¸€æ‹‰ï¼Œå°±å¾—åˆ°äº†ç›´çš„ Fã€‚

String Diagram ç¥å¥‡çš„åœ°æ–¹æ˜¯æ‰€æœ‰çº¿éƒ½å¯ä»¥æ‹‰ä¸Šä¸‹ä¸¤ç«¯ï¼Œè¿™ä¸ªæŠ€å·§éå¸¸æœ‰ç”¨ï¼Œåœ¨ä¹‹åçš„å•å­æ¨å¯¼è¿˜éœ€è¦ç”¨åˆ°ã€‚

\chapter{ä»ä¼´éšå‡½å­åˆ° å•å­/ Monad}
\label{sec:orgac02402}
æœ‰äº†ä¼´éšå‡½å­ï¼Œå¾ˆå®¹æ˜“æ¨å‡ºå•å­ï¼Œè®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯å•å­

\begin{itemize}
\item é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ª endofunctor T
\item æœ‰ä¸€ä¸ªä» i\(_{\text{c}}\) åˆ° T çš„è‡ªç„¶å˜åŒ– \(\eta\) (eta)
\item æœ‰ä¸€ä¸ªä» T\(^{\text{2}}\) åˆ° T çš„è‡ªç„¶å˜åŒ– \(\mu\) (mu)
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-monad-properties.png}
\end{center}

\begin{verbatim}
class Endofunctor c t => Monad c t where
  eta :: c a (t a)
  mu  :: c (t (t a)) (t a)
\end{verbatim}

\begin{verbatim}
trait Monad[C[_, _], T[_]]] extends Endofunctor[C, T] {
  def eta[A]: C[A, T[A]]
  def mu[A]: C[T[T[A]], T[A]]
}
\end{verbatim}
åŒæ ·ï¼ŒæŠŠ c = Hask æ›¿æ¢è¿›å»ï¼Œå°±å¾—åˆ°æ›´ç±»ä¼¼æˆ‘ä»¬ Haskell ä¸­ Monad çš„å®šä¹‰
\begin{verbatim}
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
\end{verbatim}

\begin{verbatim}
trait Monad[M[_]] extends Endofunctor[M] {
  def eta[A]: A => M[A]
  def mu[A]: M[M[A]] => M[A]
}
\end{verbatim}
è¦æ¨å‡ºå•å­çš„ \(\eta\) å˜æ¢ï¼Œåªéœ€è¦è®© FG = T
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-to-monad-eta.png}
\caption{ä¼´éšå‡½å­çš„ epsilon å°±æ˜¯å•å­çš„ eta}
\end{figure}

åŒæ ·çš„ï¼Œå½“ FG = T, F \(\eta\) G å°±å¯ä»¥å˜æˆ \(\mu\)
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-to-monad-mu.png}
\caption{ä¼´éšå‡½å­çš„ F eta G æ˜¯å‡½å­çš„ mu}
\end{figure}

\section{ä¸‰è§’ç­‰å¼}
\label{sec:org4f1315f}

ä¸‰è§’ç­‰å¼æ˜¯æŒ‡ \(\mu\) . T \(\eta\) = T = \(\mu\) . \(\eta\) T

è¦æ¨å‡ºä¸‰è§’ç­‰å¼åªéœ€è¦ç»„åˆ F \(\eta\) G å’Œ \(\epsilon\) F G
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-adjunction-functor-triangle.png}
\caption{F eta G  . epsilon F G = F G}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-monad-triangle.png}
\caption{F eta G  . epsilon F G= F G å¯¹åº”åˆ°Monadå°±æ˜¯ mu . eta T = T}
\end{figure}

æ¢åˆ°ä»£ç ä¸Šæ¥è¯´
\begin{verbatim}
(mu . eta) m = m
\end{verbatim}

åŒæ ·çš„ï¼Œå·¦å³ç¿»è½¬ä¹Ÿæˆç«‹

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-adjunction-functor-triangle-reverse.png}
\caption{F eta G . F G epsilon = F G}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p1-monad-triangle-reverse.png}
\caption{F eta G . F G epsilon = F G å¯¹åº”åˆ° Monadæ˜¯ mu . T eta = T}
\end{figure}
T \(\eta\) å°±æ˜¯ fmap eta
\begin{verbatim}
(mu . fmap eta) m = m
\end{verbatim}

å¦‚æœæŠŠ \texttt{mu . fmap} å†™æˆ \texttt{>>=} , å°±æœ‰äº†

\begin{verbatim}
m >>= eta = m
\end{verbatim}

\section{ç»“åˆå¾‹}
\label{sec:org5e82dc0}

å•å­å¦ä¸€å¤§å®šå¾‹æ˜¯ç»“åˆå¾‹ï¼Œè®©æˆ‘ä»¬ä»ä¼´éšå‡½å­æ¨èµ·

å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰å‡½å­ F \(\eta\) G å’Œ å‡½å­ F \(\eta\) G F G, compose èµ·æ¥ä¼šå˜æˆ  F \(\eta\) G . F \(\eta\) G F G
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-1.png}
\end{center}

ç”¨ F G = T ï¼Œ F \(\eta\) G = \(\mu\) ä»£æ¢é‚£ä¹ˆå°±å¾—åˆ°äº†å•å­çš„ \(\mu\) . \(\mu\) T
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-2.png}
\end{center}

å½“ç»„åˆ F \(\eta\) G å’Œ F G F \(\mu\) G åï¼Œä¼šå¾—åˆ°ä¸€ä¸ªé•œåƒçš„å›¾
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-3.png}
\end{center}

å¯¹åº”åˆ°å•å­çš„ \(\mu\) . T \(\mu\)

ç»“åˆå¾‹æ˜¯è¯´ \(\mu\) . \(\mu\) T = \(\mu\) . T \(\mu\) , å³å›¾å·¦å³ç¿»è½¬ç»“æœæ˜¯ç›¸ç­‰çš„ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿçœ‹å•å­çš„String Diagram ä¸å¤ªå¥½çœ‹å‡ºæ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ä¼´éšå‡½å­

å¦‚æœæŠŠå·¦å›¾çš„å·¦è¾¹çš„ \(\mu\) å¾€ä¸ŠæŒªä¸€ç‚¹ï¼Œå³è¾¹çš„ \(\mu\) å¾€ä¸‹æŒªä¸€ç‚¹ï¼Œæ˜¯ä¸æ˜¯è·Ÿå³å›¾å°±ä¸€æ ·äº†
\begin{center}
\includegraphics[width=.9\linewidth]{images/p1-ajunction-functor-monad-laws-4.png}
\end{center}

ç»“åˆå¾‹åæ˜ åˆ°ä»£ç ä¸­å°±æ˜¯
\begin{verbatim}
mu . fmap mu = mu . mu
\end{verbatim}

ä»£ç å¾ˆéš¾çœ‹å‡ºç»“åˆåœ¨å“ªé‡Œï¼Œå› ä¸ºæ­£å¸¸çš„ç»“åˆå¾‹åº”è¯¥æ˜¯è¿™æ ·çš„ (1+2)+3 = 1+(2+3)ï¼Œä½†æ˜¯ä¸æƒ³åŠ æ³•çš„ç»´åº¦ä¸ä¸€æ ·ï¼Œè¿™é‡Œè¯´çš„æ˜¯è‡ªç„¶å˜æ¢ç»´åº¦çš„ç»“åˆï¼Œå¯ä»¥é€šè¿‡String Diagram å¾ˆæ¸…æ¥šçš„çœ‹è§ç»“åˆçš„è¿‡ç¨‹ï¼Œå³ \(\mu\) å·¦è¾¹çš„ä¸¤ä¸ªTå’Œå…ˆ \(\mu\) å³è¾¹ä¸¤ä¸ª T æ˜¯ç›¸ç­‰çš„ã€‚

\chapter{Yoneda lemma / \sout{ç±³ç”°å…±} ç±³ç”°å¼•ç†}
\label{sec:org3127f76}
\index{ç±³ç”°å¼•ç†}
\index{Yoneda Lemma}

ç±³ç”°å¼•ç†æ˜¯è¯´æ‰€æœ‰Functor \texttt{f a} ä¸€å®šå­˜åœ¨ embed å’Œ unembedï¼Œä½¿å¾— \texttt{f a} å’Œ \texttt{(a -> b) -> F b} isomorphic åŒæ„

haskellè¿˜è¦å…ˆæ‰“å¼€ RankNTypes çš„ feature

\begin{verbatim}
{-# LANGUAGE RankNTypes #-}

embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
embed x f = fmap f x

unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
unembed f = f id
\end{verbatim}

Scala è¯­è¨€æ²¡æœ‰ Rank N Typeæ”¯æŒ, ä½†æ˜¯ \hyperref[org75e4d4a]{è‡ªç„¶å˜æ¢/Natural Transformations} æåˆ°è¿‡å¯ä»¥ç”¨ \texttt{apply} æ¥æ¨¡æ‹Ÿ. å…¶å®å¯ä»¥ä½¿ç”¨ Cats çš„ \href{https://typelevel.org/cats/datatypes/functionk.html}{FunctionK(\textasciitilde{}>)} æ›´æ–¹ä¾¿:
\begin{verbatim}
def embed[F[_], A](fa: F[A])(implicit f: Functor[F]): (A => ?) ~> F =
  Lambda[(A => ?) ~> F](f.fmap(_)(fa))
def unembed[F[_]](fnk: (A => ?) ~> F): F[A] =
  fnk(identity)
\end{verbatim}

embed å¯ä»¥æŠŠ functor \texttt{f a} å˜æˆ \texttt{(a -> b) -> f b}

unembed æ˜¯åè¿‡æ¥ï¼Œ \texttt{(a -> b) -> f b} å˜æˆ \texttt{f a}

ä¸Šä¸ªå›¾å°±æ˜ç™½äº†
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/yoneda-lemma.png}
\caption{ä¹Ÿå°±æ˜¯è¯´ï¼Œå›¾ä¸­æ— è®ºçŸ¥é“a->b å†åŠ ä¸Šä»»æ„ä¸€ä¸ª F xï¼Œéƒ½èƒ½æ¨å‡ºå¦å¤–ä¸€ä¸ª F}
\end{figure}

\section{Rank N Type}
\label{sec:orgd750076}
\index{Arbitrary-rank polymorphism}
\index{Rank N Type}

è¯´å¥½çš„è¦è§£é‡Š Rank N Type

Haskell ä¸­å¯ä»¥ä¸ç”¨å£°æ˜ç±»å‹, ä½†æ˜¯å…¶å®æ˜¯çœç•¥æ‰ universally quantified \texttt{forall}, å¦‚æœæŠŠ forall å…¨éƒ¨åŠ å›æ¥,
å°±æ˜äº†å¾ˆå¤š:

\begin{itemize}
\item Monomorphic Rank 0 / 0çº§å•æ€\footnote{ä¹Ÿå°±ä¸æ˜¯ä¸å˜æ€}: t
\item Polymorphic Rank 1 / 1çº§ \sout{å˜æ€} å¤šæ€: forall a b. a -> b
\item Polymorphic Rank 2 / 2çº§å¤šæ€: forall c. (forall a b. a -> b) -> c
\item Polymorphic Rank 3 / 3çº§å¤šæ€: forall d . (forall c . (forall a b . a -> b) -> c) -> d
\end{itemize}

çœ‹ rank å‡ åªè¦æ•°å·¦è¾¹ forall çš„ä¸ªæ•°å°±å¥½äº†.

ä¸€çº§å¤šæ€åªé”å®šä¸€æ¬¡ç±»å‹ a å’Œ b

äºŒçº§å¤šæ€å¯ä»¥åˆ†ä¸¤æ¬¡ç¡®å®šç±»å‹, ç¬¬ä¸€æ¬¡ç¡®å®š c, ç¬¬äºŒæ¬¡ç¡®å®š a b

ä¸‰çº§å¤šå°åˆ†ä¸‰æ¬¡: ç¬¬ä¸€æ¬¡ d, ç¬¬äºŒæ¬¡ c, ç¬¬ä¸‰æ¬¡ a b

æ¯”å¦‚:

\begin{verbatim}
rank2 :: forall b c . b -> c -> (forall a. a -> a) -> (b, c)
rank2 b c f = (f b, f c)

rank2 True 'a' id
-- (True, 'a')
\end{verbatim}

\begin{verbatim}
def rank2[B, C](b: B, c: C)(fnk: Id ~> Id): (B, C) =
  (fnk(b), fnk(c))
rank2(true, 'a')(FunctionK.id[Id])
\end{verbatim}

\begin{itemize}
\item f åœ¨ \texttt{f True} æ—¶ç±»å‹ \texttt{Boolean -> Boolean} æ˜¯ç¬¦åˆ \texttt{forall a. a->a} çš„
\item ä¸æ­¤åŒæ—¶ \texttt{f 'a'} æ—¶ç±»å‹ç¡®å®æ˜¯ \texttt{Char -> Char} ä½†ä¹Ÿç¬¦åˆ \texttt{forall a. a->a}
\end{itemize}

å¦‚æœæ˜¯ rank1 ç±»å‹ç³»ç»Ÿå°±æ‡µé€¼äº†:
\begin{verbatim}
rank1 :: forall a b c . b -> c -> (a -> a) -> (b, c)
rank1 b c f = (f b, f c)
\end{verbatim}

\begin{verbatim}
def rank1[A, B, C](b: B, c: C)(fn: A => A): (B, C) =
  (fn(b), fn(c))
\end{verbatim}
f åœ¨ \texttt{f True} æ˜¯ç¡®å®š a æ˜¯ Booleanï¼Œåœ¨rank1å¤šæ€æ˜¯æ—¶å°±ç¡®å®šäº† \texttt{a->a} çš„ç±»å‹ä¸€å®šæ˜¯ \texttt{Boolean -> Boolean}

æ‰€ä»¥åˆ° \texttt{f 'a'} ç±»å‹å°±æŒ‚äº†ã€‚

\chapter{\emph{Kleisli Catergory}}
\label{sec:orgab35996}
\index{Kleisi Catergory}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/kleisli.png}
\caption{æ³¨æ„è§‚å¯Ÿå¤§ç«ç®­ <=< çš„è½¨è¿¹, ä¸çŸ¥é“dotä¸ºä»€ä¹ˆä¼šæŠŠè¿™æ ¹çº¿æè¿™ä¹ˆåˆå¼¯åˆéªšçš„, å’Œ >>= ã€‚æ‰€ä»¥ Kleisli å…¶å®å°±æ˜¯æ–œç€èµ°çš„ä¸€ä¸ªèŒƒç•´ï¼Œä½†æ˜¯ >>= æŠŠå®ƒç¡¬ç”Ÿç”Ÿæ° \sout{å¼¯} ç›´äº†ã€‚}
\end{figure}

å‡½å­/Functor çš„èŒƒç•´å«åš å‡½å­èŒƒç•´/Functor Catergory, è‡ªç„¶å˜æ¢æ˜¯å…¶ç®­å¤´ã€‚é‚£å•å­/Monadä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªèŒƒç•´å—?\footnote{å½“ç„¶, å•å­æ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥æ˜¯è‡ªå‡½å­èŒƒç•´}

æ˜¯çš„, è¿™ä¸ªèŒƒç•´åå­—å«åš \sout{å•å­èŒƒç•´}\footnote{æ€ä¹ˆè¯´ä¹Ÿæ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒ,æ€ä¹ˆå¯ä»¥å«çš„è¿™ä¹ˆlowè¿™ä¹ˆç›´æ¥} å¯è±æ–¯åˆ©èŒƒç•´/Kleisli Catergory\footnote{è¿™ä¸ªæ˜¯æˆ‘çç¿»è¯‘çš„, ä½†æ˜¯è¯»å‡ºæ¥å°±æ˜¯è¿™ä¹ˆä¸ªæ„æ€, çœŸçš„, ä¸éª—ä½ , ç…§è¿™ä¹ˆè¯»ç»å¯¹è£…çš„ä¸€æ‰‹å¥½é€¼, ä¸ä¼šè¢«å˜²ç¬‘çš„}ï¼Œé‚£ä¹ˆ Kleisli çš„ç®­å¤´æ˜¯ä»€ä¹ˆï¼Ÿ
æˆ‘ä»¬çœ‹å®šä¹‰ï¼ŒKleisli Catergory

\begin{enumerate}
\item ç®­å¤´æ˜¯ Kleisli ç®­å¤´ \texttt{a -> T b}
\item ä¸œè¥¿å°±æ˜¯cèŒƒç•´ä¸­çš„ä¸œè¥¿. å› ä¸º a å’Œ b éƒ½æ˜¯ c èŒƒç•´ä¸Šçš„ï¼Œ ç”±äºTæ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ T b ä¹Ÿæ˜¯ c èŒƒç•´çš„
\end{enumerate}

çœ‹åˆ°å›¾ä¸Šçš„ T f/ fmap f å’Œ \(\mu\) äº†æ²¡ï¼Ÿ\footnote{(æ•²é»‘æ¿) å°±æ˜¯ç´«è‰²é‚£æ ¹å˜›!}

\begin{verbatim}
f :: b -> T c
fmap f :: T b -> T T c
mu :: T T c -> T c
\end{verbatim}

\begin{verbatim}
def f[T[_], B, C](b: B): T[C]
def fmap[T[_], B, C](f: B => C)(tb: T[B]): T[T[C]]
def mu[T[_], C](ttc: T[T[C]]): T[C]
\end{verbatim}

ç´«è‰²çš„ç®­å¤´ \texttt{T f}\footnote{å³ \texttt{fmap f}} å’Œç´«è‰²çš„è™šçº¿ç®­å¤´ \(\mu\) è¿èµ·æ¥å°±æ˜¯ \texttt{T f'}, é‚£ä¹ˆæœ€å‡ºåçš„ \texttt{>>=} ç¬¦å·ç»ˆäºå‡ºæ¥äº†:
\begin{verbatim}
tb >>= f = (mu . fmap f) tb
\end{verbatim}

\begin{verbatim}
def flatMap[T[_], B, C](f: B => T[C])(tb: T[B]): T[C] = (mu compose fmap(f))(tb)
\end{verbatim}

ä¸‹é¢è¿™ä¸ªå¤§ç«ç®­ \texttt{<=<} å¯ä»¥æŠŠè“è‰²ç®­å¤´ç»„åˆèµ·æ¥.
\begin{verbatim}
(f <=< g) = mu . T f . g = mu . fmap f . g
\end{verbatim}

\begin{verbatim}
def <=<[T[_], A, B, C](f: B => T[C])(g: A => T[B]): A => T[C] =
  mu compose fmap(f) compose g
\end{verbatim}

å› æ­¤å¤§ç«ç®­å°±æ˜¯ Kleisli èŒƒç•´çš„ \texttt{compose}

\begin{verbatim}
(<=<) :: Monad T => (b -> T c) -> (a -> T b) -> (a -> T c)
\end{verbatim}

\chapter{Summary}
\label{sec:org493098f}
ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›åŠç‚¸å¤©/ä¹±ä¸ƒå…«ç³Ÿçš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad

\begin{itemize}
\item ğŸ‘‰ \href{./part2.org}{ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢/ Practical Monads}
\item \href{./part3.org}{ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢/ Advanced Monads}
\end{itemize}

å½“ç„¶æˆ‘è¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœæœ‰å¾ˆå¤šäººé¢„å®š/åªè¦998 Gumroad ä¸Šçš„  ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œï¼Œå°±å½“æ˜¯è‡ªè¨€è‡ªè¯­å§ï¼Œæ€ä¹ˆçªç„¶è§‰å¾—è‡ªå·±å¥½åˆ†è£‚ã€‚

\part{ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢/ Practical Monads}
\label{sec:org79df89b}

\begin{center}
\includegraphics[width=.9\linewidth]{./images/Alice_through_the_looking_glass.jpg}
\end{center}

\begin{quote}
â€œIf I had a world of my own, everything would be nonsense. 
Nothing would be what it is, because everything would be what it isn't.
And contrary wise, what is, it wouldn't be. And what it wouldn't be, it would. You see?â€
â€• Lewis Carroll, Alice's Adventures in Wonderland \& Through the Looking-Glass 
\end{quote}

å¦‚æœæœ‰ä¸€ä¸ªå•å­çš„ä¸–ç•Œ, é‚£ä¸€åˆ‡éƒ½è¯´ä¸é€šäº†.
æ²¡æœ‰ä»€ä¹ˆæ˜¯åº”è¯¥çš„, å› ä¸ºæ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯å®ƒä¸æ˜¯çš„ä¸œè¥¿.
åè¿‡æ¥è¯´, æ˜¯åˆä¸ä¼šæ˜¯, è€Œä¸ä¼šæ˜¯çš„åˆä¼šæ˜¯. æ‡‚æ²¡?

åˆ°åº•ä»€ä¹ˆæ˜¯, ä»€ä¹ˆä¸æ˜¯, æˆ‘ä»¬çœ‹ç¼–ç¨‹ä¸–ç•Œé‡Œåˆ°åº•ä»€ä¹ˆæ˜¯å•å­ï¼Ÿ

è¿™ä¸€éƒ¨åˆ†å°†ä»‹ç»ç”±ä¸€äº›å®ç”¨çš„å•å­å®ä¾‹/monad instancesï¼Œé€šè¿‡è¿™äº›å•å­å®ä¾‹ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨, å·²ç»ç»„åˆæ€§çš„é—®é¢˜ã€‚

\chapter{Identity æœ¬èº«å°±æœ‰}
\label{sec:orgf411766}

æœ¬èº«å°±æœ‰å•å­/ Identity Monad\footnote{ä»æ¥æ²¡è§è¿‡æœ‰äººç»™è¿™äº›æ•°æ®ç±»å‹æŒ‰è¿‡ä¸­æ–‡åå­—, ä¸ç„¶æˆ‘æ¥, è¿™æ ·ä¹Ÿæ›´å¥½çš„ä½“ä¼šè¿™äº›æ•°æ®ç±»å‹çš„æ„å›¾.} å¯èƒ½æ˜¯æœ€ç®€å•çš„å•å­äº†ã€‚æœ¬èº«ä¸åŒ…å«ä»»ä½•è®¡ç®—, ä¸”åªæœ‰ä¸€ä¸ªæ„é€ å™¨:
\begin{verbatim}
newtype Identity a = Identity { runIdentity :: a }
\end{verbatim}

\begin{verbatim}
case class Identity[A](run: A)
\end{verbatim}

è¿™é‡Œä½¿ç”¨ \texttt{newtype} è€Œä¸æ˜¯ \texttt{data} æ˜¯å› ä¸º \texttt{Identity} ä¸ \texttt{runIdentity} æ˜¯åŒæ„çš„\footnote{è§ \href{part1.org}{ç¬¬ä¸€éƒ¨åˆ† ä¼´éšå‡½å­}}.

\begin{verbatim}
Identity :: a -> Identity a
runIdentity :: Identity a -> a
\end{verbatim}

ä½ çœ‹ \texttt{runIdentity . Identity = id} ï¼Œæ‰€ä»¥ä»–ä»¬æ˜¯åŒæ„çš„ã€‚

å·¦è¾¹çš„ \texttt{Identity} æ˜¯ç±»å‹æ„é€ å™¨\footnote{ä¹Ÿå°±æ˜¯ Kind * -> *, å› ä¸ºå®ƒéå¸¸çš„ nice, ä¸€å®šè¦ç­‰åˆ° a æ‰å‡ºç±»å‹}, æ¥æ”¶ç±»å‹ \texttt{a} è¿”å› \texttt{Identity a} ç±»å‹

å¦‚æœ a æ˜¯ Intï¼Œé‚£ä¹ˆå°±å¾—åˆ°ä¸€ä¸ª \texttt{Identity Int} ç±»å‹ã€‚

å³è¾¹çš„ \texttt{Identity} æ˜¯æ•°æ®æ„é€ å™¨ï¼Œä¹Ÿå°±æ˜¯æ„é€ å€¼ï¼Œæ¯”å¦‚ \texttt{Identity 1} ä¼šæ„é€ å‡ºä¸€ä¸ªå€¼ï¼Œå…¶ç±»å‹ä¸º \texttt{Identity Int}

å¤§æ‹¬å·æ¯”è¾ƒè¯¡å¼‚ï¼Œå¯ä»¥æƒ³è±¡æˆç»™ \texttt{a} ä¸€ä¸ª keyï¼ŒåŒè¿‡è¿™ä¸ª key å¯ä»¥æŠŠ a å–å‡ºæ¥ï¼Œæ¯”å¦‚
\begin{verbatim}
runIdentity (Identity 1)
\end{verbatim}

\begin{verbatim}
Identity(1).run
\end{verbatim}

ä¼šè¿”å› 1

Identity å¯ä»¥å®ç° Functor å’Œ Monadï¼Œå°±å¾—åˆ° Identity functor å’Œ Identity monad:

\begin{verbatim}
instance Functor Identity where
  fmap f (Identity a) = Identity (f a)

instance Monad Identity where
  return a = Identity a
  Identity a >>= f = f a
\end{verbatim}

è€Œ Scala åˆ™éœ€è¦ç”¨ \texttt{implicit} æ¥å®ç° typeclass:

\begin{verbatim}
implicit val identityFunctor: Functor[Identity] = new Functor[Identity] {
  def fmap[A, B](f: A => B): Identity[A] => Identity[B] = {
    case Identity(a) => Identity(f(a))
  }
}

implicit val identityMonad: Monad[Identity] = new Monad[Identity] {
  def pure[A](a: A): Id[A] = Identity(a)
  def flatMap[A, B](f: A => Identity[B]): Identity[A] => Identity[B] = {
    case Identity(a) => f(a)
  }
}
\end{verbatim}

å¯ä»¥çœ‹åˆ° Identity å³æ˜¯æ„é€ å™¨/constructorï¼Œä¹Ÿæ˜¯è§£æ„å™¨/destructureï¼Œåˆ©ç”¨æ¨¡å¼åŒ¹é…æ˜¯å¯ä»¥è§£æ„å‡ºå€¼çš„ã€‚

ä¾‹å¦‚ä¸Šé¢ Functor å®ç°ä¸­çš„ \texttt{fmap f (Identity a)}, å‡å¦‚ \texttt{fmap} çš„æ˜¯ \texttt{Identity 1},
é‚£ä¹ˆè¿™ä¸ªæ¨¡å¼åŒ¹é…åˆ° \texttt{(Identity a)} æ—¶ä¼šé€šè¿‡è§£æ„å™¨æŠŠ \texttt{1} æ”¾åˆ° \texttt{a} çš„ä½ç½®ã€‚

Identity çœ‹èµ·æ¥ä»€ä¹ˆä¹Ÿæ²¡æœ‰å¹²ï¼Œå°±è·Ÿ identity å‡½æ•°ä¸€æ ·ï¼Œä½†æ˜¯å®é™…ä¸Š, å®ƒä¹Ÿè·Ÿ identity ç›¸å¯¹äºå‡½æ•°ä¸€æ ·
ç›¸å¯¹äºç±»å‹éå¸¸æœ‰ç”¨.

\chapter{Maybe å¯èƒ½ä¼šæœ‰}
\label{sec:orgb9eb3c2}
å¯èƒ½ä¼šæœ‰å•å­/Maybe Monadæ˜¯ä¸€ä¸ªè¶…çº§ç®€å•çš„ä½†æ¯”æœ¬èº«å°±æœ‰ç¨ç¨å¤æ‚çš„å•å­.

å› ä¸ºå®ƒæ‹¥æœ‰æ¯”æœ¬èº«å°±æœ‰å¤šä¸€ä¸ªçš„ç±»å‹æ„é€ å™¨ï¼Œç±»ä¼¼è¿™æ ·çš„å«åš ä»£æ•°æ•°æ®ç±»å‹/ Algebra Data Type(ADT)

\begin{verbatim}
data Maybe a = Just a | Nothing
\end{verbatim}

ä½ çœ‹, ä¸ç®¡æ˜¯ \texttt{Just} è¿˜æ˜¯ \texttt{Nothing} éƒ½å¯ä»¥æ„é€ å‡ºä¸€ä¸ª \texttt{Maybe} ç±»å‹çš„æ•°æ®æ¥.

ADT åœ¨ Scala å¯ä»¥ç”¨ trait è¡¨ç¤º, è€Œä¸”, Scala ä¸­çš„ \texttt{Maybe} å«åš \texttt{Option}:

\begin{verbatim}
trait Option[+A]
case class Some[A](a: A) extends Option[A]
case object None extends Option[Nothing]
\end{verbatim}

Haskell ä¸­å®šä¹‰ä¸€ä¸ª ADT ååˆ†ç®€å•ï¼Œä¸åƒ Scala é‚£ä¹ˆå•°å—¦ã€‚å·¦è¾¹æ˜¯ç±»å‹æ„é€ å™¨ï¼Œå³è¾¹æœ‰æ•°æ®æ„é€ å™¨ï¼Œä½ ä¼šå‘ç°æœ‰ä¸€æ ¹ç«–çº¿ \texttt{|} ï¼Œ å®ƒåˆ†éš”ç€ä¸¤ä¸ªæ„é€ å™¨
\begin{itemize}
\item \texttt{Just}
\item \texttt{Nothing}
\end{itemize}

å…¶ä¸­ \texttt{a} \footnote{ä¸€å®šè¦è®°å¾—å°å†™å“¦}è¡¨ç¤ºæ˜¯ä»»æ„ç±»å‹.

æ‰€ä»¥ \texttt{Just 1} ä¼šå¾—åˆ°ä¸€ä¸ª \texttt{Num a => Mabye a} ç±»å‹\footnote{æ„æ€å°±æ˜¯ \texttt{Maybe a} ä½†æ˜¯ \texttt{a} çš„ç±»å‹çº¦æŸä¸º \texttt{Num}}ï¼Œ
\texttt{Nothing} ä¹Ÿä¼šå¾—åˆ°ä¸€ä¸ª \texttt{Maybe a} åªä¸è¿‡ \texttt{a} æ²¡æœ‰ç±»å‹çº¦æŸã€‚

æ€»ä¹‹æˆ‘ä»¬æœ‰äº†æ„é€ å™¨å¯ä»¥æ„é€ å‡º \texttt{Maybe} ç±»å‹ï¼Œè€Œè¿™ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ï¼Œå°±è¦å–å†³å®ƒå®ç°äº†å“ªäº› typeclass çš„ instance äº†ã€‚æ¯”å¦‚å®ƒå¯ä»¥æ˜¯ä¸€ä¸ªå‡½å­.
\begin{verbatim}
instance Functor Maybe where
  fmap f (Just a) = Just (f a)
  fmap f Nothing = Nothing
\end{verbatim}

\begin{verbatim}
implicit val optionFunctor: Functor[Option] = new Functor[Option] {
  def fmap[A, B](f: A => B): Option[A] => Option[B] = {
    case Some(a) => Some(f(a))
    case None => None
  }
}
\end{verbatim}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-maybe-functor.png}
\caption{fmap :: (a -> b) -> f a -> f b}
\end{figure}

çœ‹æ¸…æ¥šäº†, è™šçº¿ç®­å¤´å³ \texttt{fmap}, å›¾ä¸Šè¡¨ç¤ºçš„ \texttt{fmap} æ˜¯ \texttt{(a -> b) - - -> (Maybe a -> Maybe b)} ç”±äºè¿™é‡Œçš„ç®­å¤´éƒ½æ˜¯åœ¨ \texttt{->} èŒƒç•´, æ‰€ä»¥ \texttt{- - ->} å°±æ˜¯ \texttt{->} äº†.

å³: \texttt{fmap :: (a -> b) -> f a -> f b}

ä¸ä»…å¦‚æ­¤ï¼Œè¿˜å¯ä»¥å®ç°å•å­:
\begin{verbatim}
instance Monad Maybe where
  return a = Just a
  (Just a) >>= f = f a
  Nothing >>= f = Nothing
\end{verbatim}

\begin{verbatim}
implicit val optionMonad: Monad[Option] = new Monad[Option] {
  def flatMap[A, B](f: A => Option[B]): Option[A] => Option[B] = {
    case Some(a) => f(a)
    case None => None
  }
}
\end{verbatim}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-maybe-kleisli.png}
\caption{è¿˜è®°å¾—ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„ Kleisli èŒƒç•´å—ï¼Ÿ}
\end{figure}

Maybe æœ‰ç”¨åœ¨äºèƒ½åˆé€‚çš„å¤„ç† \emph{åå‡½æ•°} Partial Function/ çš„è¿”å›å€¼ã€‚
åå‡½æ•°ç›¸å¯¹äº \emph{å…¨å‡½æ•°} Total Function/ æ˜¯æŒ‡åªèƒ½å¯¹éƒ¨åˆ†è¾“å…¥è¿”å›è¾“å‡ºçš„å‡½æ•°ã€‚

æ¯”å¦‚ä¸€ä¸ªå–æ•°ç»„æŸä¸€ä½ä¸Šçš„å€¼çš„å‡½æ•°ï¼Œå°±æ˜¯åå‡½æ•°ï¼Œå› ä¸ºå‡è®¾ä½ æƒ³å–ç¬¬4ä½çš„å€¼ï¼Œä½†ä¸æ˜¯æ‰€æœ‰æ•°ç»„é•¿åº¦éƒ½å¤§äº4ï¼Œå°±ä¼šæœ‰è·å–ä¸äº†çš„å°´å°¬æƒ…å†µã€‚
\begin{verbatim}
[1,2,3] !! 4
\end{verbatim}

\begin{verbatim}
List(1,2,3).get(4)
\end{verbatim}

å¦‚æœä½¿ç”¨ Maybe æŠŠåå‡½æ•°å¤„ç†ä¸äº†çš„è¾“å…¥éƒ½è¿”å›æˆ Nothingï¼Œè¿™æ ·ç»“æœä¾ç„¶ä¿æŒ Maybe ç±»å‹ï¼Œä¸å½±å“åé¢çš„è®¡ç®—ã€‚

\chapter{Either è¦ä¹ˆæœ‰è¦ä¹ˆæœ‰}
\label{sec:orgdb30dec}

Either çš„å®šä¹‰ä¹Ÿå¾ˆç®€å•
\begin{verbatim}
data Either a b = Left a | Right b
\end{verbatim}

\begin{verbatim}
trait Either[+A, +B]
case class Left[+A, +B](a: A) extends Either[A, B]
case class Right[+A, +B](b: B) extends Either[A, B]
\end{verbatim}


\section{Product \& Coproduct}
\label{sec:org94ad970}
çœ‹è¿‡ç¬¬ä¸€éƒ¨åˆ†åº”è¯¥è¿˜èƒ½è®°å¾—æœ‰ä¸€ä¸ªä¸œè¥¿å« Duelï¼Œæ‰€ä»¥è§åˆ°å¦‚æœèŒƒç•´ä¸Šæœ‰ Coproduct é‚£ä¹ˆè‚¯å®šåœ¨duelèŒƒç•´ä¸Šä¼šæœ‰åŒæ ·çš„ä¸œè¥¿å« Productã€‚

é‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯ Coproduct

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-coproduct.png}
\caption{Coproduct}
\end{figure}

åƒè¿™æ ·ï¼Œèƒ½é€šè¿‡ä¸¤ä¸ªç®­å¤´åˆ°è¾¾åŒä¸€ä¸ªä¸œè¥¿ï¼Œå°±æ˜¯ Coproductã€‚è¿™é‡Œç®­å¤´ \texttt{Left} èƒ½è®© \texttt{a} åˆ° \texttt{Either a b} ï¼Œ ç®­å¤´ \texttt{Right} ä¹Ÿèƒ½è®© \texttt{b} åˆ°è¾¾ \texttt{Either a b}

æœ‰æ„æ€çš„æ˜¯è¿˜è‚¯å®šå­˜åœ¨ä¸€ä¸ª Coproduct å’Œ ç®­å¤´ï¼Œä½¿å¾—ä¸‹å›¾æˆç«‹
\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-coproduct-law.png}
\end{center}

ç®­å¤´åè¿‡æ¥ï¼Œå°±æ˜¯ Product, æ¯”å¦‚ Tuple

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-product.png}
\caption{Product}
\end{figure}

Tuple çš„ \texttt{fst} ç®­å¤´èƒ½è®© \texttt{(a, b)} åˆ°è¾¾ \texttt{a} å¯¹è±¡ï¼Œè€Œç®­å¤´ \texttt{snd} èƒ½è®©å…¶åˆ°è¾¾ \texttt{b} å¯¹è±¡ã€‚

\section{Either Monad}
\label{sec:orgd190698}
ç¡®åˆ‡çš„è¯´ï¼ŒEither ä¸æ˜¯ monadï¼Œ \texttt{Either a} æ‰æ˜¯ã€‚è¿˜è®°å¾— monad çš„ class å®šä¹‰å—ï¼Ÿ
\begin{verbatim}
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
\end{verbatim}
æ‰€ä»¥ m å¿…é¡»æ˜¯ä¸ª Endofunctorï¼Œä¹Ÿå°±æ˜¯è¦æ»¡è¶³ Functor
\begin{verbatim}
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
\end{verbatim}
t a çš„ kind æ˜¯ *ï¼Œæ‰€ä»¥ t å¿…é¡»æ˜¯ kind * -> *
ä¹Ÿå°±æ˜¯è¯´ï¼Œm å¿…é¡»æ˜¯æ¥æ”¶ä¸€ä¸ªç±»å‹å‚æ•°çš„ç±»å‹æ„é€ å™¨

è€Œ Either çš„ kind æ˜¯ * -> * -> *, Either a æ‰æ˜¯ * -> *

æ‰€ä»¥åªèƒ½å®šä¹‰ Either a çš„ Monad
\begin{verbatim}
instance Monad (Either a) where
  Left  l >>= _ = Left l
  Right r >>= k = k r
\end{verbatim}

å¾ˆæ˜æ˜¾çš„ï¼Œ>>= ä»»ä½•å‡½æ•°åˆ°å·¦è¾¹/ Left éƒ½ä¸ä¼šæ”¹å˜ï¼Œåªæœ‰ >>= å³è¾¹æ‰èƒ½äº§ç”Ÿæ–°çš„è®¡ç®—ã€‚


\chapter{Reader å·®ä¸€ç‚¹å°±æœ‰}
\label{sec:org7a33c1e}
Reader çš„ä½œç”¨æ˜¯ç»™ä¸€ä¸ªè®¡ç®—å–‚æ•°æ®ã€‚

åœ¨æè¿°è®¡ç®—çš„æ—¶å€™ï¼Œå¹¶ä¸éœ€è¦å…³å¿ƒè¾“å…¥æ—¶ä»€ä¹ˆï¼Œåªéœ€è¦ asks å°±å¯ä»¥æ‹¿åˆ°è¾“å…¥å€¼

è€ŒçœŸæ­£çš„è¾“å…¥ï¼Œä¼šåœ¨è¿è¡Œè®¡ç®—æ—¶ç»™äºˆã€‚

è·Ÿ Identity ä¸€æ ·ï¼Œæˆ‘ä»¬ç”¨ newtype æ¥å®šä¹‰ä¸€ä¸ªåŒæ„çš„ Reader ç±»å‹
\begin{verbatim}
newtype Reader e a = Reader { runReader :: (e -> a) }
\end{verbatim}

å…¶ä¸­
\begin{itemize}
\item e æ˜¯è¾“å…¥
\item a æ˜¯ç»“æœ
\item æ„é€  Reader ç±»å‹éœ€è¦ç¡®å®š è¾“å…¥çš„ç±»å‹ e ä¸è¾“å‡ºçš„ç±»å‹ a
\item \texttt{runReader} çš„ç±»å‹æ˜¯ \texttt{runReader:: (Reader e a) -> (e -> a)}
\end{itemize}

ä¹Ÿå°±æ˜¯è¯´åœ¨æè¿°å®Œä¸€ä¸ª Reader çš„è®¡ç®—åï¼Œä½¿ç”¨ runReader å¯ä»¥å¾—åˆ°ä¸€ä¸ª e -> a çš„å‡½æ•°ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå°±å¯ä»¥æ¥æ”¶è¾“å…¥ï¼Œé€šè¿‡æ„é€ å¥½çš„è®¡ç®—ï¼Œç®—å‡ºç»“æœ a è¿”å›ã€‚

é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬æ¥å®ç° Reader çš„ monad instanceï¼Œå°±å¯ä»¥æè¿°ä¸€ä¸ªå¯ä»¥ ask çš„è®¡ç®—äº†ã€‚

\begin{verbatim}
instance Monad (Reader e) where
    return a         = Reader $ \_ -> a
    (Reader g) >>= f = Reader $ \e -> runReader (f (g e)) e
\end{verbatim}

è·ŸEitherä¸€æ ·ï¼Œæˆ‘ä»¬åªèƒ½å®šä¹‰ Reader e çš„ monad instanceã€‚

æ³¨æ„è¿™é‡Œçš„
\begin{itemize}
\item f ç±»å‹æ˜¯ \texttt{(a -> Reader e a)}
\item g å…¶å®å°±æ˜¯æ˜¯ destructure å‡ºæ¥çš„ runReaderï¼Œä¹Ÿå°±æ˜¯ e -> a
\item æ‰€ä»¥ (g e) è¿”å› a
\item f (g e) å°±æ˜¯ \texttt{Reader e a}
\item å† run ä¸€æŠŠæœ€åå¾—åˆ° a
\end{itemize}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-reader-monad.png}
\caption{f å‡½æ•°ï¼Œæ¥æ”¶ a è¿”å›ä¸€ä¸ª ä» e åˆ° a çš„ Reader}
\end{figure}

è®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ Reader
\begin{verbatim}
import Control.Monad.Reader

data Environment = Env
  { fistName :: String
  , lastName :: String
  } deriving (Show)

helloworld :: Reader Environment String
helloworld = do
  f <- asks firstName
  l <- asks lastName
  return "Hello " ++ f ++ l

runHelloworld :: String
runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"
\end{verbatim}

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œhelloworld è´Ÿè´£æ‰“æ‹›å‘¼ï¼Œä¹Ÿå°±æ˜¯åœ¨åå­—å‰é¢åŠ ä¸ª "Hello"ï¼Œè€Œè·Ÿè°æ‰“æ‹›å‘¼ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸å…³å¿ƒï¼Œè€Œå•çº¯çš„æ˜¯å‘ Environment é—®/asks å°±å¥½ã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-reader-monad-ask.png}
\caption{asks å¯ä»¥å°† e -> a çš„å‡½æ•°å˜æ¢æˆ Reader e a}
\end{figure}

åœ¨è¿è¡Œæ—¶ï¼Œå¯ä»¥æä¾›ç»™ Reader çš„è¾“å…¥ Env fistname lastnameã€‚
\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-reader-monad-run.png}
\end{center}

\section{do notation}
\label{sec:orgc161d0d}
è¿™å¯èƒ½æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° \texttt{do} å’Œ \texttt{<-}. å¦‚æœä¸æ˜¯ï¼Œéšæ„è·³è¿‡è¿™èŠ‚ã€‚

\begin{itemize}
\item do ä¸­æ‰€æœ‰ <- çš„å³è¾¹éƒ½æ˜¯ \texttt{Reader Environment String} ç±»å‹
\item do ä¸­çš„ return è¿”å›ç±»å‹ä¹Ÿå¿…é¡»ä¸º  \texttt{Reader Environment String}
\item \texttt{asks firstName} è¿”å›çš„æ˜¯ \texttt{Reader Environment String} ç±»å‹ï¼Œ \texttt{<-} å¯ä»¥ç†è§£æˆå§ monad \texttt{Reader Environment} çš„å†…å®¹æ”¾åˆ°å·¦è¾¹çš„ f, æ‰€ä»¥ f çš„ç±»å‹æ˜¯ Stringã€‚
\end{itemize}

çœ‹èµ·æ¥åƒå‘½ä»¤å¼çš„è¯­å¥ï¼Œå…¶å®åªæ˜¯ \texttt{>>=} çš„è¯­æ³•ç³–ï¼Œä½†æ˜¯æ˜æ˜¾ç”¨doå¯è¯»æ€§è¦é«˜å¾ˆå¤šã€‚
\begin{verbatim}
helloworld = (asks firstName) >>=
  \f -> (asks lastName) >>=
       \l -> return "Hello " ++ f ++ l
\end{verbatim}


\chapter{Writer å…‰å‡ºè¿›æ²¡æœ‰}
\label{sec:orgfc9110a}

é™¤äº†è¿”å›å€¼ï¼Œè®¡ç®—ä¼šéœ€è¦äº§ç”Ÿä¸€äº›é¢å¤–çš„æ•°æ®ï¼Œæ¯”å¦‚ log

æ­¤æ—¶å°±éœ€è¦ä¸€ä¸ª Writterï¼Œå…¶è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · \texttt{(result, log)} çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª å«å¹ºåŠç¾¤/monoid

\begin{verbatim}
example :: Writer String String
example  = do
  tell "How are you?"
  tell "I'm fine thank you, and you?"
  return "Hehe Da~"

output :: (String, String)
output = runWriter example
-- ("Hehe Da~", "How are you?I'm fine thank you, and you?")
\end{verbatim}

Writer çš„å®šä¹‰æ›´ç®€å•
\begin{verbatim}
newtype Writer l a = Writer { runWriter :: (a,l) }
\end{verbatim}
é‡Œé¢åªæ˜¯ä¸€ä¸ª tuple è€Œå·²
\begin{itemize}
\item w æ˜¯ log
\item a æ˜¯ è¿”å›å€¼
\end{itemize}

çœ‹çœ‹å¦‚ä½•å®ç° Writer monad
\begin{verbatim}
instance (Monoid w) => Monad (Writer w) where
    return a             = Writer (a,mempty)
    (Writer (a,l)) >>= f = let (a',l') = runWriter $ f a in
                           Writer (a',l `mappend` l')
\end{verbatim}

\begin{itemize}
\item return ä¸ä¼šæœ‰ä»»ä½• logï¼Œl æ˜¯ monoid çš„ mempty
\item f çš„ç±»å‹ä¸º \texttt{a -> Writer l a}
\item \texttt{runWriter \$ f a} è¿”å› \texttt{(a, l)}
\end{itemize}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-writer-monad.png}
\end{center}

æ‰€ä»¥åœ¨ >>= æ—¶ï¼Œæˆ‘ä»¬å…ˆæŠŠ f a è¿”å›çš„ Writer runäº†ï¼Œç„¶åæŠŠä¸¤æ¬¡ log \texttt{mappend} èµ·æ¥ã€‚
\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-writer-monad-bind.png}
\end{center}

\chapter{State å˜åŒ–ä¼šæœ‰}
\label{sec:orgf83aa9d}
è·Ÿåå­—å°±çœ‹å¾—å‡ºæ¥ State monad æ˜¯ä¸ºäº†å¤„ç†çŠ¶æ€ã€‚è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹ä¸åº”è¯¥æœ‰çŠ¶æ€ï¼Œä¸ç„¶ä¼šå¼•ç”¨é€æ˜æ€§ã€‚ä½†æ˜¯ï¼Œstate monadå¹¶ä¸æ˜¯åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹çŠ¶æ€ï¼Œè€Œæ˜¯é€šè¿‡æè¿°è¿™ç§å˜åŒ–ï¼Œç„¶åéœ€è¦æ—¶åœ¨è¿è¡Œè¿”å›æœ€ç»ˆç»“æœã€‚è¿™ä¸€ç‚¹è·Ÿ Reader å’Œ Writer è¿™ä¸¤ä¸ªçœ‹èµ·æ¥æ˜¯å‰¯ä½œç”¨çš„ IO æ˜¯ä¸€æ ·çš„ã€‚

å…ˆçœ‹ä¸‹ State ç±»å‹çš„å®šä¹‰
\begin{verbatim}
newtype State s a = State { runState :: s -> (a, s) }
\end{verbatim}

å¯ä»¥çœ‹åˆ° State åªåŒ…å«ä¸€ä¸ª ä»æ—§çŠ¶æ€ s åˆ°æ–°çŠ¶æ€ s å’Œè¿”å›å€¼ a çš„ Tuple çš„å‡½æ•°ã€‚

é€šè¿‡å®ç° Monadï¼ŒState å°±å¯ä»¥å®ç°å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„å˜é‡çš„åŠŸèƒ½ã€‚
\begin{verbatim}
instance Monad (State s) where
  return a        = State $ \s -> (a,s)
  (State x) >>= f = State $ \s -> let (v,s') = x s in
                                 runState (f v) s'
\end{verbatim}
return å¾ˆç®€å•ï¼Œå°±ä¸ç”¨è§£é‡Šäº†ã€‚

\begin{center}
\includegraphics[width=.9\linewidth]{images/p2-state-monad.png}
\end{center}

x ç±»å‹æ˜¯ \texttt{s -> (a, s)} ,æ‰€ä»¥ x s ä¹‹åä¼šè¿”å› ç»“æœå’ŒçŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¿è¡Œå½“å‰ Stateï¼ŒæŠŠç»“æœ v ä¼ ç»™å‡½æ•° fï¼Œè¿”å›çš„ State å†æ¥ç€ä¸Šæ¬¡çŠ¶æ€è¿è¡Œã€‚

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{images/p2-state-monad-bind.png}
\caption{State x >>= f årunStateçš„æ•°æ®æµï¼ˆå•Šå•Šå•Šï¼Œç”»æ­ªäº†ï¼Œæ„Ÿè§‰éœ€è¦è„‰åŠ¨ä¸€ä¸‹ï¼‰}
\end{figure}

ä½¿ç”¨èµ·æ¥ä¹Ÿå¾ˆæ–¹ä¾¿ï¼ŒState æä¾› \texttt{get} \texttt{put} \texttt{moidfy} ä¸‰ä¸ªæ–¹ä¾¿çš„å‡½æ•°å¯ä»¥ç”Ÿæˆä¿®æ”¹çŠ¶æ€çš„State monad

\begin{verbatim}
import Control.Monad.Trans.State.Strict
test :: State Int Int
test = do
  a <- get
  modify (+1)
  b <- get
  return (a + b)

main = print $ show $ runState test 3
-- (7, 4)
\end{verbatim}


\chapter{Validation æ£€æŸ¥æ£€æŸ¥}
\label{sec:org7d09bfd}
å¦‚æœä½ æœ‰æ³¨æ„åˆ°ï¼Œå‰é¢çš„ Either å¯ä»¥ç”¨åœ¨å¤„ç†é”™è¯¯å’Œæ­£ç¡®çš„è·¯å¾„åˆ†æ”¯ï¼Œä½†æ˜¯é—®é¢˜æ˜¯é”™è¯¯åªå‘ç”Ÿä¸€æ¬¡ã€‚

\begin{quote}
Validation æ²¡æœ‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œä½†æ˜¯æˆ‘è§‰å¾—å¥½æœ‰ç”¨å•Šï¼Œä½ å¯ä»¥åœ¨ ekmett çš„ \href{https://github.com/ekmett/either}{github} ä¸­æ‰¾åˆ°æºç 
\end{quote}

æƒ³è±¡ä¸€ä¸‹è¿™ç§åœºæ™¯ï¼Œç”¨æˆ·æäº¤ä¸€ä¸ªè¡¨å•ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸€ä¸ªfieldè¿›è¡ŒéªŒè¯ï¼Œå¦‚æœæœ‰é”™è¯¯ï¼Œéœ€è¦æŠŠé”™è¯¯çš„å“ªå‡ ä¸ªfieldçš„é”™è¯¯æ¶ˆæ¯è¿”å›ã€‚æ˜¾ç„¶å¦‚æœä½¿ç”¨ Either æ¥åšï¼Œåªèƒ½è¿”å›ç¬¬ä¸€ä¸ªfieldçš„é”™è¯¯ä¿¡æ¯ï¼Œåé¢çš„è®¡ç®—éƒ½ä¼šè¢«è·³è¿‡ã€‚

é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œ Validation æ›´é€‚åˆ
\begin{verbatim}
data Validation e a = Failure e | Success a
\end{verbatim}

ADTå®šä¹‰çœ‹èµ·æ¥è·Ÿ Either æ˜¯ä¸€æ ·çš„ï¼Œä¸åŒçš„æ˜¯ å·¦è¾¹/Left Failure æ˜¯ å«å¹ºåŠç¾¤/Monoid

\section{å«å¹ºåŠç¾¤/Monoid}
\label{sec:orga56ba93}
monoid é¦–å…ˆå¾—æ˜¯ åŠç¾¤/Semigroup ï¼Œç„¶åå† å«å¹ºã€‚
\begin{verbatim}
class Semigroup a where
  (<>) :: a -> a -> a
  (<>) = mappend
\end{verbatim}

åŠç¾¤éå¸¸ç®€å•ï¼Œåªè¦æ˜¯å¯ä»¥ \texttt{<>} (mappend) çš„ç±»å‹å°±æ˜¯äº†ã€‚

å«å¹ºåªéœ€è¦æœ‰ä¸€ä¸ª \texttt{mempty} çš„ å¹ºå…ƒå°±è¡Œ
\begin{verbatim}
class Monoid a where
  mempty  :: a
  mappend :: a -> a -> a
\end{verbatim}

æ¯”å¦‚ List å°±æ˜¯ Semigroup
\begin{verbatim}
instance Semigroup [a] where
  (<>) = (++)
\end{verbatim}
ä¹Ÿæ˜¯ Monoid
\begin{verbatim}
instance Monoid [a] where
  mempty  = []
  mappend = (++)
\end{verbatim}

Monoid çš„ \texttt{<>} æ»¡è¶³ï¼š
\begin{itemize}
\item mempty <> a = a
\item a <> b <> c = a <> (b <> c)
\end{itemize}
\section{å›åˆ° Validation}
\label{sec:org653eaa8}
ç°åœ¨è®© Failure e æ»¡è¶³ Monoidï¼Œå°±å¯ä»¥ \texttt{mappend} é”™è¯¯ä¿¡æ¯äº†ã€‚
\begin{verbatim}
instance Semigroup e => Semigroup (Validation e a) where
  Failure e1 <> Failure e2 = Failure (e1 <> e2)
  Failure _  <> Success a2 = Success a2
  Success a1 <> Failure _  = Success a1
  Success a1 <> Success _  = Success a1
\end{verbatim}

ä¸‹æ¥ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹çœ‹ Validation ä¸ Either æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªformï¼Œéœ€è¦è¾“å…¥å§“åä¸ç”µè¯ï¼ŒéªŒè¯éœ€è¦å§“åæ˜¯éç©ºè€Œç”µè¯æ˜¯11ä½æ•°å­—ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªå‡½æ•°å»åˆ›å»ºåŒ…å«å§“åå’Œç”µè¯çš„model
\begin{verbatim}
data Info = Info {name: String, phone: String} deriving Show
\end{verbatim}

ç„¶åæˆ‘ä»¬éœ€è¦éªŒè¯å‡½æ•°
\begin{verbatim}
notEmpty :: String -> String -> Validation [String] String
notEmpty desc "" = Failure [desc <> " cannot be empty!"]
notEmpty _ field = Success field
\end{verbatim}
notEmpty æ£€æŸ¥å­—ç¬¦æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ˜¯ç©ºè¿”å› Failure åŒ…å«é”™è¯¯ä¿¡æ¯ï¼Œè‹¥æ˜¯éç©ºåˆ™è¿”å› Success åŒ…å« field

åŒæ ·çš„å¯ä»¥åˆ›å»º 11ä½æ•°å­—çš„éªŒè¯å‡½æ•°
\begin{verbatim}
phoneNumberLength :: String -> String -> Validation [String] String
phoneNumberLength desc field | (length field) == 11 = Success field
                             | otherwise = Failure [desc <> "'s length is not 11"]
\end{verbatim}
å®ç° Validation çš„ Applicative instanceï¼Œè¿™æ ·å°±å¯ä»¥æŠŠå‡½æ•°è°ƒç”¨liftæˆå¸¦æœ‰éªŒè¯çš„ Applicative
\begin{verbatim}
instance Semigroup e => Applicative (Validation e) where
  pure = Success
  Failure e1 <*> Failure e2 = Failure e1 <> Failure e2
  Failure e1 <*> Success _  = Failure e1
  Success _  <*> Failure e2 = Failure e2
  Success f <*> Success a = Success (f a)
\end{verbatim}
\begin{itemize}
\item å¤±è´¥åº”ç”¨åˆ°å¤±è´¥ä¼š concat èµ·æ¥
\item å¤±è´¥è·Ÿåº”ç”¨æˆ–è¢«æˆåŠŸåº”ç”¨è¿˜æ˜¯å¤±è´¥
\item åªæœ‰æˆåŠŸåº”ç”¨åˆ°æˆåŠŸæ‰èƒ½æˆåŠŸï¼Œè¿™å¾ˆç¬¦åˆéªŒè¯çš„é€»è¾‘ï¼Œä¸€æ—¦éªŒè¯ä¸­å‘ç”Ÿä»»ä½•é”™è¯¯ï¼Œéƒ½åº”è¯¥è¿”å›å¤±è´¥ã€‚
\end{itemize}

\begin{verbatim}
createInfo :: String -> String -> Validation [String] Info
createInfo name phone = Info <$> notEmpty "name" name <*> phoneNumberLength "phone" phone
\end{verbatim}

ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨å¸¦validationçš„ createInfo æ¥å®‰å…¨çš„åˆ›å»º Info äº†

\begin{verbatim}
createInfo "jichao" "12345678910" -- Success Info "jichao" "12345678910"
createInfo "" "123" -- Failure ["name cannot be empty!", "phone's length is not 11"]
\end{verbatim}

\chapter{Cont æ¥ä¸‹æ¥æœ‰}
\label{sec:org11a1a3d}
Cont æ˜¯ Continuation Passing Style/CPS çš„ monadï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯åŒ…å« cps è®¡ç®— monadã€‚

å…ˆçœ‹ä¸€ä¸‹ä»€ä¹ˆæ˜¯ CPSï¼Œæ¯”å¦‚æœ‰ä¸€ä¸ªåŠ æ³•
\begin{verbatim}
add :: Int -> Int -> Int
add = (+)
\end{verbatim}

ä½†æ˜¯å¦‚æœä½ æƒ³åœ¨ç®—æ³•åŠ æ³•åï¼Œèƒ½å¤Ÿç»§ç»­è¿›è¡Œä¸€ä¸ªå…¶ä»–çš„è®¡ç®—ï¼Œé‚£ä¹ˆå°±å¯ä»¥å†™ä¸€ä¸ª cpsç‰ˆæœ¬çš„åŠ æ³•
\begin{verbatim}
addCPS :: Int -> Int -> (Int -> r) -> r
addCPS a b k = k (a + b)
\end{verbatim}

éå¸¸ç®€å•ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹çœ‹ä¸ºä»€ä¹ˆéœ€è¦ä¸€ä¸ª Cont monad æ¥åŒ…ä½ CPS è®¡ç®—ï¼Œé¦–å…ˆï¼Œæ¥çœ‹ ADT å®šä¹‰
\begin{verbatim}
newtype Cont r a = Cont { runCont :: ((a -> r) -> r) }
\end{verbatim}

åˆæ˜¯ä¸€ä¸ªåŒæ„çš„ç±»å‹ï¼ŒCont æ„é€ å™¨åªéœ€è¦ä¸€ä¸ª runCountï¼Œä¹Ÿå°±æ˜¯è®©ä»–èƒ½ç»§ç»­è®¡ç®—çš„ä¸€ä¸ªå‡½æ•°ã€‚

å®Œäº†ä¹‹åæ¥æŠŠä¹‹å‰çš„ addCPS æ”¹æˆ Cont
\begin{verbatim}
add :: Int -> Int -> Cont k Int
add a b = return (a + b)
\end{verbatim}

æ³¨æ„åˆ° addCPS æ¥æ”¶åˆ° a å’Œ b ä¹‹åè¿”å›çš„ç±»å‹æ˜¯ \texttt{(Int -> r) -> r} ï¼Œè€Œ Cont ç‰ˆæœ¬çš„ \texttt{add} è¿”å› \texttt{Cont k Int}

æ˜æ˜¾æ„é€  \texttt{Cont k Int} ä¹Ÿæ­£æ˜¯éœ€è¦ \texttt{(Int -> r) -> r} ï¼Œæ‰€ä»¥ Cont å°±æ˜¯ç®—äº† k çš„æŠ½è±¡äº†ã€‚

\begin{verbatim}
instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
\end{verbatim}

\texttt{(\$ a)} æ¯”è¾ƒæœ‰æ„æ€, æˆ‘ä»¬éƒ½çŸ¥é“ \texttt{f \$ g a} å…¶å®å°±æ˜¯ \texttt{f(g a)}, æ‰€ä»¥ \texttt{\$} å…¶å®å°±æ˜¯ä¸€ä¸ª apply å·¦è¾¹çš„å‡½æ•°åˆ°å³è¾¹è¡¨è¾¾å¼çš„ä¸­ç¼€å‡½æ•°, å¦‚æœå†™æˆå‰ç¼€åˆ™æ˜¯
\texttt{(\$ (g a) f)}. æ˜¯åçš„æ˜¯å› ä¸º \texttt{\$} æ˜¯æœ‰ç»“åˆ, éœ€è¦å³è¾¹è¡¨è¾¾å¼å…ˆæ±‚å€¼, æ‰€ä»¥åªç»™ä¸€ä¸ª a å°±ç›¸å½“äº \texttt{(\$ a) = \textbackslash{}f -> f a}

å›åˆ° Monad Cont\ldots{}

\chapter{Summary}
\label{sec:orgd1fdd56}
ç¬¬äºŒéƒ¨åˆ†é£Ÿç”¨éƒ¨åˆ†ä¹Ÿè®²å®Œäº†ï¼Œ ä¸çŸ¥æ˜¯å¦ä»¥åŠå¤§è‡´äº†è§£äº†monadçš„å°¿æ€§å„ç§åŸºæœ¬ç©æ³•å‘¢ï¼Ÿé€šè¿‡è¿™äº›å¸¸ç”¨çš„åŸºæœ¬çš„ monad instanceï¼Œè§£å†³å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„ä¸€äº›ç®€å•é—®é¢˜åº”è¯¥æ˜¯å¤Ÿäº†ã€‚

ä¸è¿‡ï¼Œæ¥ä¸‹æ¥è¿˜æœ‰æ›´å˜æ€çš„çŒ«ï¼Œå°±å…ˆå«å¥¹ \sout{æåŸº} çŒ«å‘¢å¥½äº†ã€‚

\begin{itemize}
\item ğŸ‘‰ \href{./part3.org}{ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢/ Advanced Monads}
\end{itemize}

å½“ç„¶æˆ‘åˆè¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœè¿˜æœ‰å¾ˆå¤šäººé¢„å®š/åªè¦998 Gumroad ä¸Šçš„  ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œï¼Œå°±å½“æ˜¯æˆ‘åˆè‡ªè¨€è‡ªè¯­å§ï¼Œæ€ä¹ˆåˆçªç„¶è§‰å¾—è‡ªå·±å¥½åˆ†è£‚ï¼Œè¯¶\textasciitilde{}ï¼Œä¸ºä»€ä¹ˆæˆ‘è¦è¯´åˆï¼Ÿ

\part{ç¬¬ä¸‰éƒ¨åˆ†:æåŸºçŒ«å‘¢/Advanced Monads}
\label{sec:org55db55f}
ç¬¬äºŒéƒ¨åˆ†ä»‹ç»äº†ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

é€šè¿‡å®ƒä»¬å¯ä»¥è§£å†³å¤§å¤šæ•°çš„åŸºæœ¬é—®é¢˜ï¼Œä½†æ˜¯æ­£å¯¹äºå¤æ‚ä¸šåŠ¡é€»è¾‘ï¼Œæˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦ä¸€äº›æ›´é«˜é˜¶çš„ monad æˆ–è€… patternã€‚

å½“æœ‰äº†ç¬¬ä¸€éƒ¨åˆ†çš„ç†è®ºåŸºç¡€å’Œç¬¬äºŒéƒ¨åˆ†çš„å®è·µï¼Œè¿™éƒ¨åˆ†è¦ä»‹ç»çš„çŒ«å‘¢å…¶å®å¹¶ä¸æ˜¯å¾ˆæåŸºã€‚é€šè¿‡è¿™ä¸€éƒ¨åˆ†ä»‹ç»çš„æåŸºçŒ«å‘¢ï¼Œ
æˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚

\chapter{RWS}
\label{sec:org520a90d}
RWS æ˜¯ç¼©å†™ Reader Writer State monad, æ‰€ä»¥æ˜æ˜¾æ˜¯ä¸‰ä¸ªmonadçš„åˆä½“ã€‚å¦‚æœå·²ç»å¿˜è®° Reader Writer æˆ–è€… Stateï¼Œè¯·åˆ°ç¬¬äºŒéƒ¨åˆ†å¤ä¹ ä¸€ä¸‹ã€‚

ä¸€æ—¦æŠŠä¸‰ä¸ª monad åˆä½“ï¼Œæ„å‘³ç€å¯ä»¥åœ¨åŒä¸€ä¸ª monad ä½¿ç”¨ä¸‰ä¸ª monad çš„æ–¹æ³•ï¼Œæ¯”å¦‚ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ Reader çš„ ask, State çš„ get, put, å’Œ Writer çš„ tell

\begin{verbatim}
readWriteState = do
  e <- ask
  a <- get
  let res = a + e
  put res
  tell [res]
  return res
runRWS readWriteState 1 2
-- (3 3 [3])
\end{verbatim}

æ³¨æ„åˆ°è·Ÿ Reader å’Œ State ä¸€æ ·ï¼Œrunçš„æ—¶å€™è¾“å…¥åˆå§‹å€¼

å…¶ä¸­ 1 ä¸º Reader çš„å€¼ï¼Œ2 ä¸º State çš„åˆå§‹çŠ¶æ€.

\chapter{Monad Transform}
\label{sec:org560c7f7}

ä½ ä¼šå‘ç° RWS ä¸€èµ·ç”¨æŒºå¥½çš„ï¼Œèƒ½è¯»èƒ½å†™èƒ½æ‰“ logï¼Œä½†æ˜¯å·²ç»å›ºå®šå¥½æ­é…äº†ï¼Œåªèƒ½æ˜¯ RWS ï¼Œå¦‚æœæˆ‘è¿˜æƒ³åŠ å…¥å…¶å®ƒçš„ Monadï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

è¿™æ—¶å€™ï¼Œç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åŠ ä¸ª Tï¼Œæ¯”å¦‚å¯¹äº Readerï¼Œæˆ‘ä»¬æœ‰ ReaderTï¼ŒRWSï¼Œä¹Ÿæœ‰å¯¹åº”çš„ RWSTã€‚å…¶ä¸­ T ä»£è¡¨ Transformã€‚

\section{ReaderT}
\label{sec:org69b65ad}

è®©æˆ‘æ¥é€šè¿‡ç®€å•çš„ ReaderT æ¥è§£é‡Šåˆ°åº•ä»€ä¹ˆæ˜¯ T å§, é¦–å…ˆè·Ÿ Reader ä¸€æ ·æˆ‘ä»¬æœ‰ä¸ª runReaderT

\begin{verbatim}
newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
\end{verbatim}

æ¯”è¾ƒä¸€ä¸‹ Reader çš„å®šä¹‰
\begin{verbatim}
newtype Reader e a = Reader { runReader :: (e -> a) }
\end{verbatim}

æœ‰æ²¡æœ‰å‘ç°å¤šäº†ä¸€ä¸ª m, ä¹Ÿå°±æ˜¯è¯´, \texttt{runReader e} ä¼šè¿”å› a, ä½†æ˜¯ \texttt{runReaderT e} åˆ™ä¼šè¿”å› \texttt{m a}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-ReaderT.png}
\end{center}

\begin{verbatim}
instance (Monad m) => Monad (ReaderT e m) where
    return   = lift . return
    r >>= k  = ReaderT $ \ e -> do
        a <- runReaderT r e
        runReaderT (k a) e
\end{verbatim}

å†çœ‹çœ‹ monad çš„å®ç°, ä¹Ÿæ˜¯ä¸€æ ·çš„, å…ˆ run ä¸€ä¸‹ \texttt{r e} å¾—åˆ°ç»“æœ \texttt{a}, åº”ç”¨å‡½æ•° \texttt{k} åˆ° \texttt{a}, å† run ä¸€æŠŠ.


é—®é¢˜æ˜¯, è¿™é‡Œçš„ \texttt{return} é‡Œé¢çš„ \texttt{lift} æ˜¯å“ªæ¥çš„?

\begin{verbatim}
instance MonadTrans (ReaderT e) where
  lift m = ReaderT (const m)
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-MonadTrans-ReaderT-e-m.png}
\end{center}

è¿™ä¸ªå‡½æ•° \texttt{lift} è¢«å®šä¹‰åœ¨ MonadTrans çš„å®ä¾‹ä¸­, ç®€å•çš„æŠŠ m æ”¾åˆ° ReaderT ç»“æœä¸­.

ä¾‹å¦‚, \texttt{lift (Just 1)} ä¼šå¾—åˆ° ReaderT, å…¶ä¸­ e éšæ„, m ä¸º Maybe Num

é‡ç‚¹éœ€è¦ä½“ä¼šçš„æ˜¯, Reader å¯ä»¥è¶Šè¿‡ Maybe ç›´æ¥æ“ä½œåˆ° Num, å®Œäº†å†åŒ…å›æ¥.

æœ‰äº† ReaderT, æ­é… Id Monad å°±å¾ˆå®¹æ˜“åˆ›å»ºå‡ºæ¥ Reader Monad

\begin{verbatim}
type Reader r a= ReaderT r Identity a
\end{verbatim}

è¶Šè¿‡ Id read åˆ° Id å†…éƒ¨, å®Œäº†å†ç”¨ Id åŒ…å›æ¥, ä¸å°±æ˜¯ Reader äº†ä¹ˆ

\begin{verbatim}
ReaderT { runReaderT :: r -> Identity a }
-- Identity a is a
ReaderT { runReaderT :: r -> a }
\end{verbatim}

\chapter{Alternative}
\label{sec:org615f36e}

è¿™ä¸ª typeclass æä¾› \texttt{<|>} å‡½æ•°, è¡¨ç¤ºè¦ä¹ˆè®¡ç®—å·¦è¾¹, è¦ä¹ˆè®¡ç®—å³è¾¹

\begin{verbatim}
class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-Alternative.png}
\end{center}

å…¶å®å°±æ˜¯ Applicative çš„ \texttt{æˆ–}

æ¯”å¦‚:
\begin{verbatim}
Just 1 <|> Just 2 -- Just 1
Just 1 <|> Nothing -- Just 1
Nothing <|> Just 1 -- Just 1
Nothing <|> Nothing -- Nothing
\end{verbatim}

\chapter{MonadPlus}
\label{sec:org86c6154}
è¿™è·Ÿ Alternative æ˜¯ä¸€æ¯›ä¸€æ ·çš„, åªæ˜¯é™åˆ¶çš„æ›´ç»†, å¿…é¡»æ˜¯ Monadæ‰è¡Œ

\begin{verbatim}
class (Alternative m, Monad m) => MonadPlus m where
   mzero :: m a
   mzero = empty
   mplus :: m a -> m a -> m a
   mplus = (<|>)
\end{verbatim}

çœ‹, å®ç°ä¸­ç›´æ¥å°±è°ƒç”¨äº† Alternative çš„ \texttt{empty} å’Œ \texttt{<|>}

\chapter{ST Monad}
\label{sec:orge3ecca8}
ST Monad è·Ÿ State Monad çš„åŠŸèƒ½æœ‰äº›åƒ, ä¸è¿‡æ›´å‰å®³çš„æ˜¯, ä»–ä¸æ˜¯ immutable çš„, è€Œæ˜¯ "immutable" çš„åœ¨åŸåœ°åšä¿®æ”¹. æ”¹å®Œä¹‹å runST åˆç„¶ä»–å›åˆ°äº† immutable çš„ Haskell ä¸–ç•Œ.

\begin{verbatim}
sumST :: Num a => [a] -> a
sumST xs = runST $ do           -- do åé¢çš„äº‹æƒ…ä¼šæ˜¯ä¸é”™çš„å†…å­˜æ“ä½œ, runST å¯ä»¥æŠŠå®ƒæ‹‰ä¼šçº¯çš„ä¸–ç•Œ
    n <- newSTRef 0             -- åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€å—å¹¶æŒ‡åˆ° STRef
    forM_ xs $ \x -> do         -- è¿™è·Ÿå‘½ä»¤å¼çš„forå¾ªç¯æ”¹å†™å˜é‡æ˜¯ä¸€æ¯›ä¸€æ ·çš„
        modifySTRef n (+x)
    readSTRef n                 -- è¿”å›æ”¹å®Œä¹‹åçš„ n çš„å€¼
\end{verbatim}

\chapter{Free Monad}
\label{sec:org6bb1e39}
ä¸Šä¸€ç« è¯´è¿‡çš„ RWS Monad æ¯•ç«Ÿæ˜¯å›ºå®šæ­é…ï¼Œå½“ä½ çš„ä¸šåŠ¡éœ€è¦æ›´å¤šçš„ Monad æ¥è¡¨ç¤º Effect æ—¶ï¼Œ
æˆ‘ä»¬å°±éœ€è¦æœ‰é‚£ä¹ˆä¸ªå°çŒªæ‰‹å¸®æˆ‘ä»¬å®šä¹‰è‡ªå·±çš„ Monadã€‚

é‚£å°±æ˜¯ Free, Free å¯ä»¥å°†ä»»æ„ datatype lift æˆä¸º Monad

\section{Free}
\label{sec:org304a527}
å…ˆçœ‹ Free ä»€ä¹ˆå®šä¹‰:

\begin{verbatim}
data Free f a = Roll (f (Free f a)) | Return a
\end{verbatim}

å…¶ä¸­ \texttt{f} å°±æ˜¯ä½ ä¸šåŠ¡éœ€è¦çš„ effect ç±»å‹, \texttt{a} æ˜¯è¿™ä¸ª effect æ‰€äº§ç”Ÿçš„è¿”å›å€¼ç±»å‹ã€‚

å³è¾¹ä¸¤ç§æ„é€ å‡½æ•°ï¼Œå¦‚æœæŠŠ \texttt{Role} æ”¹æˆ \texttt{Cons}, \texttt{Return} æ”¹æˆ \texttt{Nil} çš„è¯, æ˜¯ä¸æ˜¯è·Ÿ List å…¶å®æ˜¯ åŒæ„/isomophic çš„å‘¢? æ‰€ä»¥å¦‚æœæƒ³è±¡æˆ List, é‚£ä¹ˆ \texttt{f} åœ¨è¿™é‡Œå°±ç›¸å½“äº List ä¸­çš„ä¸€ä¸ªå…ƒç´ .

åˆ°é‚£æ—¶, \texttt{>>=} çš„æ“ä½œåˆè·Ÿ List ç•¥æœ‰ä¸åŒ, æˆ‘ä»¬éƒ½çŸ¥é“ \texttt{>>=} ä¼šæŠŠæ¯ä¸€ä¸ªå…ƒç´  map æˆ List, ç„¶å flatten, ä½† Free å…¶å®æ˜¯ç”¨æ¥æ„å»º
é¡ºåºçš„ effect çš„, æ‰€ä»¥:

\begin{verbatim}
instance Functor f => Monad (Free f) where
  return a        = Return a
  Return a >>= fn = fn a
  Roll ffa >>= fn = Roll $ fmap (>>= fn) ffa
\end{verbatim}

ä½ ä¼šå‘ç° \texttt{>>=} ä¼šé€’å½’çš„ \texttt{fmap} åˆ° \texttt{Roll} ä¸Š, ç›´åˆ°æœ€åä¸€ä¸ª \texttt{Return}.

æ¯”å¦‚, å¦‚æœä½ æœ‰ä¸€ä¸ª program æœ‰ä¸‰ç§å‰¯ä½œç”¨ Eff1, Eff2, Eff3

\begin{verbatim}
data Eff a = Eff1 a | Eff2 a | Eff3 a
program = do
 a <- liftF $ Eff1 1
 b <- liftF $ Eff2 2
 c <- liftF $ Eff3 3
 return a + b + c
\end{verbatim}

å¦‚æœæˆ‘ä»¬æŠŠ program å±•å¼€, æ¯ä¸€æ­¥ \texttt{>>=} å¤§æ¦‚æ˜¯è¿™æ ·:

\begin{verbatim}
liftF $ Eff1 1
\end{verbatim}

å±•å¼€æ—¢æ˜¯:

\begin{verbatim}
Roll (Eff1 (Return 1))
\end{verbatim}

ä»£å…¥åˆ° program å³:
\begin{verbatim}
program = Roll (Eff1 (Return 1)) >>= \a -> do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
\end{verbatim}

ç”¨ Free çš„ \texttt{>>=} å…¬å¼ \texttt{Roll ffa >>= fn = Roll \$ fmap (>>= fn) ffa} å»å±•å¼€ä¸Šé¢å°±å¾—åˆ°:

\begin{verbatim}
program = Roll $ Eff1 (Return 1 >>= fn1)) where
  fn1 = \a -> do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
\end{verbatim}

\texttt{Return 1 >>= fn1} æˆ‘ä»¬éƒ½çŸ¥é“æ€ä¹ˆå±•å¼€:

\begin{verbatim}
program = Roll $ Eff1 (fn1 1) where
  fn1 = \a -> do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
\end{verbatim}

å±•å¼€ \texttt{fn1}

\begin{verbatim}
program = Roll $ Eff1 do
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return 1 + b + c
\end{verbatim}


åŒæ ·çš„æ­¥éª¤å±•å¼€ Eff2
\begin{verbatim}
program = Roll $ Eff1 $ Roll $ Eff2 do
   c <- liftF $ Eff3 3
   return 1 + 2 + c
\end{verbatim}

å’Œ Eff3

\begin{verbatim}
program = Roll $ Eff1 $ Roll $ Eff2 $ Roll $ Eff3 do
   return 1 + 2 + 3
\end{verbatim}

æœ€åçš„ program æ˜¯ä¸æ˜¯å¾ˆåƒ List çš„ Cons å’Œ Nil å‘¢?

\begin{verbatim}
program = Roll $ Eff1 $ Roll $ Eff2 $ Roll $ Eff3 $ Return 1 + 2 + 3
\end{verbatim}


ä½†æ˜¯, ç»†å¿ƒçš„ä½ å¯èƒ½æ—©éƒ½å‘ç°äº† \texttt{Eff} è¿™è´§å¿…é¡»æ˜¯ä¸ª \texttt{Functor} æ‰è¡Œ. é‚£æˆ‘ä»¬å¦‚ä½•éšä¾¿å®šä¹‰ä¸€ä¸ª \texttt{data Eff} ç›´æ¥èƒ½ç”Ÿæˆ \texttt{Functor Eff} çš„å®ä¾‹å‘¢?

\section{Coyoneda}
\label{sec:orgd500d30}

å¸Œæœ›ä½ è¿˜ä¾ç„¶è®°å¾—ç¬¬ä¸€éƒ¨åˆ†çš„ç±³ç”° \sout{å…±} å¼•ç†

\begin{verbatim}
data CoYoneda f a = forall b. CoYoneda (b -> a) (f b)
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-CoYoneda.png}
\end{center}

äº‹å®ä¸Šå¾ˆç®€å•å¯ä»¥æŠŠä»»ä½• \texttt{f} å˜æˆ \texttt{CoYoneda f}

\begin{verbatim}
phi :: f a -> CoYoneda f a
phi fa = CoYoneda id fa
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-CoYoneda-phi.png}
\end{center}

è¯€çªå°±æ˜¯ \texttt{id}, ä¹Ÿå°±æ˜¯ä½ æŠŠ \texttt{b} å˜æˆ \texttt{a}, å†æŠŠ \texttt{fa} æ”¾åˆ° \texttt{CoYoneda} é‡Œå°±å¥½äº†

å½“ \texttt{f} æ˜¯ \texttt{Functor} æ—¶, åˆå¯ä»¥æŠŠ \texttt{CoYoneda} å˜æˆ \texttt{f}

\begin{verbatim}
psi :: Functor f => CoYoneda f a -> f a
psi (CoYoneda g fa) = fmap g fa
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-CoYoneda-psi.png}
\end{center}

åè¿‡æ¥çš„è¿™ä¸ªä¸é‡è¦, é‡è¦çš„æ˜¯ \texttt{phi}, å› ä¸ºå¦‚æœä½ å¯ä»¥æŠŠä»»ä½• \texttt{f} å˜æˆ \texttt{CoYoneda f}, è€Œ \texttt{CoYoneda f} åˆæ˜¯ \texttt{Functor},
æˆ‘ä»¬ä¸å°±å…è´¹å¾—åˆ°ä¸€ä¸ª \texttt{Functor}?

\begin{verbatim}
instance Functor (Coyoneda f) where
  fmap f (Coyoneda g fb) = Coyoneda (f . g) fb
\end{verbatim}

\section{Free Functor}
\label{sec:org5d9ab27}
æ¯”å¦‚æˆ‘ä»¬çš„ \texttt{Eff} å°±å¯ä»¥ç›´æ¥é€šè¿‡ \texttt{phi} å˜æˆ \texttt{CoYoneda Eff}, ä»è€Œå¾—åˆ°å…è´¹çš„ Functor

\begin{verbatim}
data Eff a = Eff1 a | Eff2 a | Eff3 a
program = Roll (phi (Eff1 (Roll (phi (Eff2 (Return Int))))))
\end{verbatim}

\begin{center}
\includegraphics[width=.9\linewidth]{images/p3-Free.png}
\end{center}

\section{Interpreter}
\label{sec:orgf423a52}
æ„é€ å®Œä¸€ä¸ª free program å,æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªåµŒå¥—çš„æ•°æ®ç»“æ„, å½“æˆ‘ä»¬éœ€è¦ run è¿™ä¸ª program æ—¶, æˆ‘ä»¬éœ€è¦ foldMap ä¸€ä¸ª
Interpreter å»ä¸€å±‚å±‚æ‹¨å¼€ è¿™ä¸ª free program.

\begin{verbatim}
foldMap :: Monad m => (forall x . f x -> m x) -> Free f a -> m a
foldMap _ (Return a)  = return a
foldMap f (Roll a) = f a >>= foldMap f
\end{verbatim}

\chapter{Free Monoid}
\label{sec:orgd4188f6}
\chapter{Eff}
\label{sec:org77d9013}

\chapter{Comonad}
\label{sec:org14523aa}
\end{document}
