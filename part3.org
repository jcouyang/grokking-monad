#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad
#+Date: <2018-07-28 Fri>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+OPTIONS: ^:t
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

- [[./part1.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šçŒ«è®º]]
- [[./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]
- *[[./part3.org][ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢*]] ğŸ‘ˆ

* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ob-haskell)
#+END_SRC

#+RESULTS:
: ob-haskell

* ç¬¬ä¸‰éƒ¨åˆ†:{{{ruby(æåŸºçŒ«å‘¢,Advanced Monads)}}}
ç¬¬äºŒéƒ¨åˆ†ä»‹ç»äº†ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

é€šè¿‡å®ƒä»¬å¯ä»¥è§£å†³å¤§å¤šæ•°çš„åŸºæœ¬é—®é¢˜ï¼Œä½†æ˜¯æ­£å¯¹äºå¤æ‚ä¸šåŠ¡é€»è¾‘ï¼Œæˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦ä¸€äº›æ›´é«˜é˜¶çš„ monad æˆ–è€… patternã€‚

å½“æœ‰äº†ç¬¬ä¸€éƒ¨åˆ†çš„ç†è®ºåŸºç¡€å’Œç¬¬äºŒéƒ¨åˆ†çš„å®è·µï¼Œè¿™éƒ¨åˆ†è¦ä»‹ç»çš„çŒ«å‘¢å…¶å®å¹¶ä¸æ˜¯å¾ˆæåŸºã€‚é€šè¿‡è¿™ä¸€éƒ¨åˆ†ä»‹ç»çš„æåŸºçŒ«å‘¢ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚

** RWS
RWS æ˜¯ç¼©å†™ Reader Writer State monad, æ‰€ä»¥æ˜æ˜¾æ˜¯ä¸‰ä¸ªmonadçš„åˆä½“ã€‚å¦‚æœå·²ç»å¿˜è®° Reader Writer æˆ–è€… Stateï¼Œè¯·åˆ°ç¬¬äºŒéƒ¨åˆ†å¤ä¹ ä¸€ä¸‹ã€‚

ä¸€æ—¦æŠŠä¸‰ä¸ª monad åˆä½“ï¼Œæ„å‘³ç€å¯ä»¥åœ¨åŒä¸€ä¸ª monad ä½¿ç”¨ä¸‰ä¸ª monad çš„æ–¹æ³•ï¼Œæ¯”å¦‚ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ Reader çš„ ask, State çš„ get, put, å’Œ Writer çš„ tell

#+BEGIN_SRC haskell
  readWriteState = do
    e <- ask
    a <- get
    let res = a + e
    put res
    tell [res]
    return res
  runRWS readWriteState 1 2
  -- (3 3 [3])
#+END_SRC

æ³¨æ„åˆ°è·Ÿ Reader å’Œ State ä¸€æ ·ï¼Œrunçš„æ—¶å€™è¾“å…¥åˆå§‹å€¼

å…¶ä¸­ 1 ä¸º Reader çš„å€¼ï¼Œ2 ä¸º State çš„

** DONE Monad Transform
:LOGBOOK:
- State "DONE"       from "IN PROGRESS" [2017-10-26 Thu 21:44]
- State "IN PROGRESS" from "TODO"       [2017-06-09 Fri 21:33]
:END:
ä½ ä¼šå‘ç° RWS ä¸€èµ·ç”¨æŒºå¥½çš„ï¼Œèƒ½è¯»èƒ½å†™èƒ½æ‰“ logï¼Œä½†æ˜¯å·²ç»å›ºå®šå¥½æ­é…äº†ï¼Œåªèƒ½æ˜¯ RWS ï¼Œå¦‚æœæˆ‘è¿˜æƒ³åŠ å…¥å…¶å®ƒçš„ Monadï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

è¿™æ—¶å€™ï¼Œç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åŠ ä¸ª Tï¼Œæ¯”å¦‚å¯¹äº Readerï¼Œæˆ‘ä»¬æœ‰ ReaderTï¼ŒRWSï¼Œä¹Ÿæœ‰å¯¹åº”çš„ RWSTã€‚å…¶ä¸­ T ä»£è¡¨ Transformã€‚

*** ReaderT

è®©æˆ‘æ¥é€šè¿‡ç®€å•çš„ ReaderT æ¥è§£é‡Šåˆ°åº•ä»€ä¹ˆæ˜¯ T å§, é¦–å…ˆè·Ÿ Reader ä¸€æ ·æˆ‘ä»¬æœ‰ä¸ª runReaderT

#+BEGIN_SRC haskell
newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
#+END_SRC

æ¯”è¾ƒä¸€ä¸‹ Reader çš„å®šä¹‰
#+BEGIN_SRC haskell
newtype Reader e a = Reader { runReader :: (e -> a) }
#+END_SRC

æœ‰æ²¡æœ‰å‘ç°å¤šäº†ä¸€ä¸ª m, ä¹Ÿå°±æ˜¯è¯´, =runReader e= ä¼šè¿”å› a, ä½†æ˜¯ =runReaderT e= åˆ™ä¼šè¿”å› =m a=

[[file:images/p3-ReaderT.png]]

#+BEGIN_SRC haskell
instance (Monad m) => Monad (ReaderT e m) where
    return   = lift . return
    r >>= k  = ReaderT $ \ e -> do
        a <- runReaderT r e
        runReaderT (k a) e
#+END_SRC

å†çœ‹çœ‹ monad çš„å®ç°, ä¹Ÿæ˜¯ä¸€æ ·çš„, å…ˆ run ä¸€ä¸‹ =r e= å¾—åˆ°ç»“æœ =a=, åº”ç”¨å‡½æ•° =k= åˆ° =a=, å† run ä¸€æŠŠ.


é—®é¢˜æ˜¯, è¿™é‡Œçš„ =return= é‡Œé¢çš„ =lift= æ˜¯å“ªæ¥çš„?

#+BEGIN_SRC haskell
  instance MonadTrans (ReaderT e) where
    lift m = ReaderT (const m)
#+END_SRC

[[file:images/p3-MonadTrans-ReaderT-e-m.png]]

è¿™ä¸ªå‡½æ•° =lift= è¢«å®šä¹‰åœ¨ MonadTrans çš„å®ä¾‹ä¸­, ç®€å•çš„æŠŠ m æ”¾åˆ° ReaderT ç»“æœä¸­.

ä¾‹å¦‚, =lift (Just 1)= ä¼šå¾—åˆ° ReaderT, å…¶ä¸­ e éšæ„, m ä¸º Maybe Num

é‡ç‚¹éœ€è¦ä½“ä¼šçš„æ˜¯, Reader å¯ä»¥è¶Šè¿‡ Maybe ç›´æ¥æ“ä½œåˆ° Num, å®Œäº†å†åŒ…å›æ¥.

æœ‰äº† ReaderT, æ­é… Id Monad å°±å¾ˆå®¹æ˜“åˆ›å»ºå‡ºæ¥ Reader Monad

#+BEGIN_SRC haskell
type Reader r a= ReaderT r Identity a
#+END_SRC

è¶Šè¿‡ Id read åˆ° Id å†…éƒ¨, å®Œäº†å†ç”¨ Id åŒ…å›æ¥, ä¸å°±æ˜¯ Reader äº†ä¹ˆ

#+BEGIN_SRC haskell
ReaderT { runReaderT :: r -> Identity a }
-- Identity a is a
ReaderT { runReaderT :: r -> a }
#+END_SRC

** Alternative
#+BEGIN_SRC haskell
class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
#+END_SRC

[[file:images/p3-Alternative.png]]

å…¶å®å°±æ˜¯ Applicative çš„ =æˆ–=

æ¯”å¦‚:
#+BEGIN_SRC haskell
Just 1 <|> Just 2 -- Just 1
Just 1 <|> Nothing -- Just 1
Nothing <|> Just 1 -- Just 1
Nothing <|> Nothing -- Nothing
#+END_SRC

** MonadPlus
è¿™è·Ÿ Alternative æ˜¯ä¸€æ¯›ä¸€æ ·çš„, åªæ˜¯é™åˆ¶çš„æ›´ç»†, å¿…é¡»æ˜¯ Monadæ‰è¡Œ

#+BEGIN_SRC haskell
class (Alternative m, Monad m) => MonadPlus m where
   mzero :: m a
   mzero = empty
   mplus :: m a -> m a -> m a
   mplus = (<|>)
#+END_SRC

çœ‹, å®ç°ä¸­ç›´æ¥å°±è°ƒç”¨äº† Alternative çš„ =empty= å’Œ =<|>=

** ST Monad
ST Monad è·Ÿ State Monad çš„åŠŸèƒ½æœ‰äº›åƒ, ä¸è¿‡æ›´å‰å®³çš„æ˜¯, ä»–ä¸æ˜¯ immutable çš„, è€Œæ˜¯ "immutable" çš„åœ¨åŸåœ°åšä¿®æ”¹. æ”¹å®Œä¹‹å runST åˆç„¶ä»–å›åˆ°äº† immutable çš„ Haskell ä¸–ç•Œ.

#+BEGIN_SRC haskell
  sumST :: Num a => [a] -> a
  sumST xs = runST $ do           -- do åé¢çš„äº‹æƒ…ä¼šæ˜¯ä¸é”™çš„å†…å­˜æ“ä½œ, runST å¯ä»¥æŠŠå®ƒæ‹‰ä¼šçº¯çš„ä¸–ç•Œ
      n <- newSTRef 0             -- åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€å—å¹¶æŒ‡åˆ° STRef
      forM_ xs $ \x -> do         -- è¿™è·Ÿå‘½ä»¤å¼çš„forå¾ªç¯æ”¹å†™å˜é‡æ˜¯ä¸€æ¯›ä¸€æ ·çš„
          modifySTRef n (+x)
      readSTRef n                 -- è¿”å›æ”¹å®Œä¹‹åçš„ n çš„å€¼
#+END_SRC

** Free Monad
ä¸Šä¸€ç« è¯´è¿‡çš„ RWS Monad æ¯•ç«Ÿæ˜¯å›ºå®šæ­é…ï¼Œå½“ä½ çš„ä¸šåŠ¡éœ€è¦æ›´å¤šçš„ Monad æ¥è¡¨ç¤º Effect æ—¶ï¼Œæˆ‘ä»¬å°±éœ€è¦æœ‰é‚£ä¹ˆä¸ªå°çŒªæ‰‹å¸®æˆ‘ä»¬å®šä¹‰è‡ªå·±çš„ Monadã€‚

é‚£å°±æ˜¯ Free, Free å¯ä»¥å°†ä»»æ„ datatype lift æˆä¸º Monad

*** Free
å…ˆçœ‹ Free ä»€ä¹ˆå®šä¹‰:

#+BEGIN_SRC haskell
data Free f a = Roll (f (Free f a)) | Return a
#+END_SRC

å…¶ä¸­ =f= å°±æ˜¯ä½ ä¸šåŠ¡éœ€è¦çš„ effect ç±»å‹, =a= æ˜¯è¿™ä¸ª effect æ‰€äº§ç”Ÿçš„è¿”å›å€¼ç±»å‹ã€‚

å³è¾¹ä¸¤ç§æ„é€ å‡½æ•°ï¼Œå¦‚æœæŠŠ =Role= æ”¹æˆ =Cons=, =Return= æ”¹æˆ =Nil= çš„è¯, æ˜¯ä¸æ˜¯è·Ÿ List å…¶å®æ˜¯ {{{ruby(åŒæ„,isomophic)}}} çš„å‘¢? æ‰€ä»¥å¦‚æœæƒ³è±¡æˆ List, é‚£ä¹ˆ =f= åœ¨è¿™é‡Œå°±ç›¸å½“äº List ä¸­çš„ä¸€ä¸ªå…ƒç´ .

åˆ°é‚£æ—¶, ~>>=~ çš„æ“ä½œåˆè·Ÿ List ç•¥æœ‰ä¸åŒ, æˆ‘ä»¬éƒ½çŸ¥é“ ~>>=~ ä¼šæŠŠæ¯ä¸€ä¸ªå…ƒç´  map æˆ List, ç„¶å flatten, ä½† Free å…¶å®æ˜¯ç”¨æ¥æ„å»º
é¡ºåºçš„ effect çš„, æ‰€ä»¥:

#+BEGIN_SRC haskell
instance Functor f => Monad (Free f) where
  return a        = Return a
  Return a >>= fn = fn a
  Roll ffa >>= fn = Roll $ fmap (>>= fn) ffa
#+END_SRC

ä½ ä¼šå‘ç° ~>>=~ ä¼šé€’å½’çš„ =fmap= åˆ° =Roll= ä¸Š, ç›´åˆ°æœ€åä¸€ä¸ª =Return=.

å¦‚æœä½ æœ‰ä¸€ä¸ª
#+BEGIN_SRC haskell
data Eff a = Eff1 a | Eff2 a | Eff3 a
program = Roll Eff1 (Roll Eff2 (Return Int))
#+END_SRC

~>>=~ ä¸€ä¸ªå‡½æ•° =Int => Free Eff3 Int= åˆ° =program= ä¼šæ˜¯ä»€ä¹ˆ?

#+BEGIN_SRC haskell
Roll Eff1 (Roll Eff2 (Roll Eff3 (Return Int))
#+END_SRC

çœŸçš„è¿™ä¹ˆç¥å¥‡å—?

ç»†å¿ƒçš„ä½ å¯èƒ½æ—©éƒ½å‘ç°äº† =Eff= è¿™è´§å¿…é¡»æ˜¯ä¸ª =Functor= æ‰è¡Œ. é‚£æˆ‘ä»¬å¦‚ä½•éšä¾¿å®šä¹‰ä¸€ä¸ª =data Eff= ç›´æ¥èƒ½ç”Ÿæˆ =Functor Eff= çš„å®ä¾‹å‘¢?

*** Coyoneda
å¸Œæœ›ä½ è¿˜ä¾ç„¶è®°å¾—ç¬¬ä¸€éƒ¨åˆ†çš„ç±³ç”° +å…±+ å¼•ç†
#+BEGIN_SRC haskell
data CoYoneda f a = forall b. CoYoneda (b -> a) (f b)
#+END_SRC

[[file:images/p3-CoYoneda.png]]

äº‹å®ä¸Šå¾ˆç®€å•å¯ä»¥æŠŠä»»ä½• =f= å˜æˆ =CoYoneda f=

#+BEGIN_SRC haskell
phi :: f a -> CoYoneda f a
phi fa = CoYoneda id fa
#+END_SRC

[[file:images/p3-CoYoneda-phi.png]]

è¯€çªå°±æ˜¯ =id=, ä¹Ÿå°±æ˜¯ä½ æŠŠ =b= å˜æˆ =a=, å†æŠŠ =fa= æ”¾åˆ° =CoYoneda= é‡Œå°±å¥½äº†

å½“ =f= æ˜¯ =Functor= æ—¶, åˆå¯ä»¥æŠŠ =CoYoneda= å˜æˆ =f=

#+BEGIN_SRC haskell
psi :: Functor f => CoYoneda f a -> f a
psi (CoYoneda g fa) = fmap g fa
#+END_SRC

[[file:images/p3-CoYoneda-psi.png]]

åè¿‡æ¥çš„è¿™ä¸ªä¸é‡è¦, é‡è¦çš„æ˜¯ =phi=, å› ä¸ºå¦‚æœä½ å¯ä»¥æŠŠä»»ä½• =f= å˜æˆ =CoYoneda f=, è€Œ =CoYoneda f= åˆæ˜¯ =Functor=,
æˆ‘ä»¬ä¸å°±å…è´¹å¾—åˆ°ä¸€ä¸ª =Functor=?

#+BEGIN_SRC haskell
instance Functor (Coyoneda f) where
  fmap f (Coyoneda g fb) = Coyoneda (f . g) fb
#+END_SRC

*** Free Functor
æ¯”å¦‚æˆ‘ä»¬çš„ =Eff= å°±å¯ä»¥ç›´æ¥é€šè¿‡ =phi= å˜æˆ =CoYoneda Eff=, ä»è€Œå¾—åˆ°å…è´¹çš„ Functor

#+BEGIN_SRC haskell
data Eff a = Eff1 a | Eff2 a | Eff3 a
program = Roll (phi (Eff1 (Roll (phi (Eff2 (Return Int))))))
#+END_SRC

[[file:images/p3-Free.png]]

*** Interpreter
æ„é€ å®Œä¸€ä¸ª free program å,æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªåµŒå¥—çš„æ•°æ®ç»“æ„, å½“æˆ‘ä»¬éœ€è¦ run è¿™ä¸ª program æ—¶, æˆ‘ä»¬éœ€è¦ foldMap ä¸€ä¸ª
Interpreter å»ä¸€å±‚å±‚æ‹¨å¼€ è¿™ä¸ª free program.

#+BEGIN_SRC haskell
foldMap :: Monad m => (forall x . f x -> m x) -> Free f a -> m a
foldMap _ (Return a)  = return a
foldMap f (Roll a) = f a >>= foldMap f
#+END_SRC

** TODO Eff
