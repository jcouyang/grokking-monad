* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ob-haskell)
#+END_SRC

#+RESULTS:
: ob-haskell


* {{{ruby(é£Ÿç”¨çŒ«å‘¢,Practical Monads)}}}

[[./images/Alice_through_the_looking_glass.jpg]]
[fn:6]
#+BEGIN_QUOTE
â€œIf I had a world of my own, everything would be nonsense. 
Nothing would be what it is, because everything would be what it isn't.
And contrary wise, what is, it wouldn't be. And what it wouldn't be, it would. You see?â€
â€• Lewis Carroll, Alice's Adventures in Wonderland & Through the Looking-Glass [fn:6]
#+END_QUOTE

å¦‚æœæœ‰ä¸€ä¸ªå•å­çš„ä¸–ç•Œ, é‚£ä¸€åˆ‡éƒ½è¯´ä¸é€šäº†.
æ²¡æœ‰ä»€ä¹ˆæ˜¯åº”è¯¥çš„, å› ä¸ºæ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯å®ƒä¸æ˜¯çš„ä¸œè¥¿.
åè¿‡æ¥è¯´, æ˜¯åˆä¸ä¼šæ˜¯, è€Œä¸ä¼šæ˜¯çš„åˆä¼šæ˜¯. æ‡‚æ²¡?

åˆ°åº•ä»€ä¹ˆæ˜¯, ä»€ä¹ˆä¸æ˜¯, æˆ‘ä»¬çœ‹ç¼–ç¨‹ä¸–ç•Œé‡Œåˆ°åº•ä»€ä¹ˆæ˜¯å•å­ï¼Ÿ

è¿™ä¸€éƒ¨åˆ†å°†ä»‹ç»ç”±ä¸€äº›å®ç”¨çš„{{{ruby(å•å­å®ä¾‹,monad instances)}}}ï¼Œé€šè¿‡è¿™äº›å•å­å®ä¾‹ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨, ä»¥åŠç»„åˆæ€§çš„é—®é¢˜ã€‚

** COMMENT Applicative
*** Alternative
*** Arrow
*** Bifunctor

** Identity æœ¬èº«å°±æœ‰

{{{ruby(æœ¬èº«å°±æœ‰å•å­, Identity Monad)}}}[fn:1] å¯èƒ½æ˜¯æœ€ç®€å•çš„å•å­äº†ã€‚æœ¬èº«ä¸åŒ…å«ä»»ä½•è®¡ç®—, ä¸”åªæœ‰ä¸€ä¸ªæ„é€ å™¨:
#+BEGIN_SRC haskell :session part2
newtype Identity a = Identity { runIdentity :: a }
#+END_SRC

#+BEGIN_SRC scala
case class Identity[A](run: A)
#+END_SRC

- è¿™é‡Œå–å =Identity= å« *æœ¬èº«å°±æœ‰* ï¼Œæ‰€ä»¥ =Identity a= å°±æ˜¯ *æœ¬èº«å°±æœ‰ a*
- è¿™é‡Œä½¿ç”¨ =newtype= è€Œä¸æ˜¯ =data= æ˜¯å› ä¸º =Identity= ä¸ =runIdentity= æ˜¯ /åŒæ„/ çš„[fn:2].

#+BEGIN_SRC haskell
Identity :: a -> Identity a
runIdentity :: Identity a -> a
#+END_SRC

ä½ çœ‹ ~runIdentity . Identity = id~ ï¼Œæ‰€ä»¥ä»–ä»¬æ˜¯åŒæ„çš„ã€‚

å·¦è¾¹çš„ =Identity= æ˜¯ /ç±»å‹æ„é€ å™¨/[fn:3], æ¥æ”¶ç±»å‹ =a= è¿”å› =Identity a= ç±»å‹ã€‚

å¦‚æœ =a= æ˜¯ =Int=, é‚£ä¹ˆå°±å¾—åˆ°ä¸€ä¸ª =Identity Int= ç±»å‹ã€‚

å³è¾¹çš„ =Identity= æ˜¯æ•°æ®æ„é€ å™¨ï¼Œä¹Ÿå°±æ˜¯æ„é€ å€¼ï¼Œæ¯”å¦‚ =Identity 1= ä¼šæ„é€ å‡ºä¸€ä¸ªå€¼ï¼Œå…¶ç±»å‹ä¸º =Identity Int= ã€‚

å¤§æ‹¬å·æ¯”è¾ƒè¯¡å¼‚ï¼Œå¯ä»¥æƒ³è±¡æˆç»™ =a= è‡ªåŠ¨ç”Ÿæˆäº†ä¸€ä¸ª =Identity a -> a= çš„å‡½æ•°ï¼Œ æ¯”å¦‚:

#+BEGIN_SRC haskell :session part2
runIdentity (Identity 1)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC scala
Identity(1).run
#+END_SRC

ä¼šè¿”å› 1

*æœ¬èº«å°±æœ‰* å¯ä»¥å®ç° Functor å’Œ Monadï¼Œå°±å¾—åˆ° Identity functor å’Œ Identity monad:

#+BEGIN_SRC haskell
  instance Functor Identity where
    fmap f (Identity a) = Identity (f a)

  instance Monad Identity where
    return a = Identity a
    Identity a >>= f = f a
#+END_SRC

è€Œ Scala åˆ™ç”¨ =given= æ¥å®ç° typeclass:

#+BEGIN_SRC scala
  given Functor[Identity]:
    def fmap[A, B](f: A => B): Identity[A] => Identity[B] =
      case Identity(a) => Identity(f(a))


  given Monad[Identity]:
    def pure[A](a: A): Id[A] = Identity(a)
    def flatMap[A, B](f: A => Identity[B]): Identity[A] => Identity[B] =
      case Identity(a) => f(a)
#+END_SRC

å¯ä»¥çœ‹åˆ° =Identity= å³æ˜¯{{{ruby(æ„é€ å™¨,constructor)}}}ï¼Œä¹Ÿæ˜¯{{{ruby(è§£æ„å™¨,destructure)}}}ï¼Œåˆ©ç”¨æ¨¡å¼åŒ¹é…æ˜¯å¯ä»¥è§£æ„å‡ºå€¼çš„ã€‚

ä¸Šé¢å‡½å­å®ç°ä¸­çš„ =fmap f (Identity a)=, å‡å¦‚ =fmap= çš„æ˜¯ =Identity 1=,
é‚£ä¹ˆè¿™ä¸ªæ¨¡å¼åŒ¹é…åˆ° =(Identity a)= æ—¶ä¼šé€šè¿‡è§£æ„å™¨æŠŠ =1= æ”¾åˆ° =a= çš„ä½ç½®ã€‚

*æœ¬æ¥å°±æœ‰* çœ‹èµ·æ¥ä»€ä¹ˆä¹Ÿæ²¡æœ‰å¹²ï¼Œå°±è·Ÿ =identity= å‡½æ•°ä¸€æ ·ï¼Œä½†æ˜¯å®é™…ä¸Š, å®ƒä¹Ÿè·Ÿ identity ç›¸å¯¹äºå‡½æ•°ä¸€æ ·ï¼Œåœ¨æŸäº›åœºæ™¯åº•ä¸‹éå¸¸æœ‰ç”¨ï¼Œæ¯”å¦‚åä¸€éƒ¨åˆ†æåŸºçŒ«å‘¢ä¼š
æçš„é«˜è¾¾çŒ«ã€‚

** Maybe å¯èƒ½ä¼šæœ‰
{{{ruby(å¯èƒ½ä¼šæœ‰å•å­,Maybe Monad)}}}æ˜¯ä¸€ä¸ªè¶…çº§ç®€å•çš„ä½†æ¯”æœ¬èº«å°±æœ‰ç¨ç¨å¤æ‚çš„å•å­.

å› ä¸ºå®ƒæ‹¥æœ‰æ¯”æœ¬èº«å°±æœ‰å¤šä¸€ä¸ªçš„ç±»å‹æ„é€ å™¨ï¼Œç±»ä¼¼è¿™æ ·çš„å«åš {{{ruby(ä»£æ•°æ•°æ®ç±»å‹, Algebra Data Type(ADT))}}}

#+BEGIN_SRC haskell
data Maybe a = Just a | Nothing
#+END_SRC

å…¶ä¸­ =a= [fn:4]è¡¨ç¤ºæ˜¯ä»»æ„ç±»å‹.

ä½ çœ‹, ä¸ç®¡æ˜¯ =Just= è¿˜æ˜¯ =Nothing= éƒ½å¯ä»¥æ„é€ å‡ºä¸€ä¸ª =Maybe= ç±»å‹çš„æ•°æ®æ¥.

ADT åœ¨ Scala å¯ä»¥ç”¨ enum è¡¨ç¤º, è€Œä¸”, Scala ä¸­çš„ =Maybe= å«åš =Option=:

#+BEGIN_SRC scala
  enum Option[+A]:
    case Some(a: A)
    case None
#+END_SRC


æ‰€ä»¥ =Just 1= ä¼šå¾—åˆ°ä¸€ä¸ª =Num a => Mabye a= ç±»å‹[fn:5]ï¼Œ
=Nothing= ä¹Ÿä¼šå¾—åˆ°ä¸€ä¸ª =Maybe a= åªä¸è¿‡ =a= æ²¡æœ‰ç±»å‹çº¦æŸã€‚

æ€»ä¹‹æˆ‘ä»¬æœ‰äº†æ„é€ å™¨å¯ä»¥æ„é€ å‡º =Maybe= ç±»å‹ï¼Œè€Œè¿™ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ï¼Œå°±è¦å–å†³å®ƒå®ç°äº†å“ªäº› typeclass çš„å®ä¾‹ äº†ã€‚æ¯”å¦‚å®ƒå¯ä»¥æ˜¯ä¸€ä¸ªå‡½å­.
#+BEGIN_SRC haskell
  instance Functor Maybe where
    fmap f (Just a) = Just (f a)
    fmap f Nothing = Nothing
#+END_SRC

#+BEGIN_SRC scala
  given Functor[Option]:
    def fmap[A, B](f: A => B): Option[A] => Option[B] =
      case Some(a) => Some(f(a))
      case None => None
#+END_SRC

#+CAPTION: fmap :: (a -> b) -> f a -> f b
[[file:images/p2-maybe-functor.png]]

çœ‹æ¸…æ¥šäº†, è™šçº¿ç®­å¤´å³ =fmap=, å›¾ä¸Šè¡¨ç¤ºçš„ =fmap= æ˜¯ =(a -> b) - - -> (Maybe a -> Maybe b)= ç”±äºè¿™é‡Œçš„ç®­å¤´éƒ½æ˜¯åœ¨ =->= èŒƒç•´, æ‰€ä»¥ =- - ->= å°±æ˜¯ =->= äº†.

å³: =fmap :: (a -> b) -> f a -> f b=

ä¸ä»…å¦‚æ­¤ï¼Œè¿˜å¯ä»¥å®ç°å•å­:
#+BEGIN_SRC haskell
  instance Monad Maybe where
    return a = Just a
    (Just a) >>= f = f a
    Nothing >>= f = Nothing
#+END_SRC

#+BEGIN_SRC scala
  implicit val optionMonad: Monad[Option] = new Monad[Option] {
    def flatMap[A, B](f: A => Option[B]): Option[A] => Option[B] = {
      case Some(a) => f(a)
      case None => None
    }
  }
#+END_SRC

#+CAPTION: è¿˜è®°å¾—ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„ Kleisli èŒƒç•´å—ï¼Ÿ
[[file:images/p2-maybe-kleisli.png]]

Maybe æœ‰ç”¨åœ¨äºèƒ½åˆé€‚çš„å¤„ç† /{{{ruby(åå‡½æ•°, Partial Function)}}}/ çš„è¿”å›å€¼ã€‚
åå‡½æ•°ç›¸å¯¹äº /{{{ruby(å…¨å‡½æ•°, Total Function)}}}/ æ˜¯æŒ‡åªèƒ½å¯¹éƒ¨åˆ†è¾“å…¥è¿”å›è¾“å‡ºçš„å‡½æ•°ã€‚

æ¯”å¦‚ä¸€ä¸ªå–æ•°ç»„æŸä¸€ä½ä¸Šçš„å€¼çš„å‡½æ•°ï¼Œå°±æ˜¯åå‡½æ•°ï¼Œå› ä¸ºå‡è®¾ä½ æƒ³å–ç¬¬4ä½çš„å€¼ï¼Œä½†ä¸æ˜¯æ‰€æœ‰æ•°ç»„é•¿åº¦éƒ½å¤§äº4ï¼Œå°±ä¼šæœ‰è·å–ä¸äº†çš„å°´å°¬æƒ…å†µã€‚
#+BEGIN_SRC haskell
[1,2,3] !! 4
#+END_SRC

#+BEGIN_SRC scala
List(1,2,3).get(4)
#+END_SRC

å¦‚æœä½¿ç”¨ Maybe æŠŠåå‡½æ•°å¤„ç†ä¸äº†çš„è¾“å…¥éƒ½è¿”å›æˆ Nothingï¼Œè¿™æ ·ç»“æœä¾ç„¶ä¿æŒ Maybe ç±»å‹ï¼Œä¸å½±å“åé¢çš„è®¡ç®—ã€‚

** Either è¦ä¹ˆæœ‰è¦ä¹ˆæœ‰

Either çš„å®šä¹‰ä¹Ÿå¾ˆç®€å•
#+BEGIN_SRC haskell
data Either a b = Left a | Right b
#+END_SRC

#+BEGIN_SRC scala
trait Either[+A, +B]
case class Left[+A, +B](a: A) extends Either[A, B]
case class Right[+A, +B](b: B) extends Either[A, B]
#+END_SRC


*** Product & Coproduct
çœ‹è¿‡ç¬¬ä¸€éƒ¨åˆ†åº”è¯¥è¿˜èƒ½è®°å¾—æœ‰ä¸€ä¸ªä¸œè¥¿å« Duelï¼Œæ‰€ä»¥è§åˆ°å¦‚æœèŒƒç•´ä¸Šæœ‰ Coproduct é‚£ä¹ˆè‚¯å®šåœ¨duelèŒƒç•´ä¸Šä¼šæœ‰åŒæ ·çš„ä¸œè¥¿å« Productã€‚

é‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯ Coproduct

#+CAPTION: Coproduct
[[file:images/p2-coproduct.png]]

åƒè¿™æ ·ï¼Œèƒ½é€šè¿‡ä¸¤ä¸ªç®­å¤´åˆ°è¾¾åŒä¸€ä¸ªä¸œè¥¿ï¼Œå°±æ˜¯ Coproductã€‚è¿™é‡Œç®­å¤´ =Left= èƒ½è®© =a= åˆ° =Either a b= ï¼Œ ç®­å¤´ =Right= ä¹Ÿèƒ½è®© =b= åˆ°è¾¾ =Either a b=

æœ‰æ„æ€çš„æ˜¯è¿˜è‚¯å®šå­˜åœ¨ä¸€ä¸ª Coproduct å’Œ ç®­å¤´ï¼Œä½¿å¾—ä¸‹å›¾æˆç«‹
[[file:images/p2-coproduct-law.png]]

ç®­å¤´åè¿‡æ¥ï¼Œå°±æ˜¯ Product, æ¯”å¦‚ Tuple

#+CAPTION: Product
[[file:images/p2-product.png]]

Tuple çš„ =fst= ç®­å¤´èƒ½è®© =(a, b)= åˆ°è¾¾ =a= å¯¹è±¡ï¼Œè€Œç®­å¤´ =snd= èƒ½è®©å…¶åˆ°è¾¾ =b= å¯¹è±¡ã€‚

*** Either Monad
ç¡®åˆ‡çš„è¯´ï¼ŒEither ä¸æ˜¯ monadï¼Œ =Either a= æ‰æ˜¯ã€‚è¿˜è®°å¾— monad çš„ class å®šä¹‰å—ï¼Ÿ
#+BEGIN_SRC haskell
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
#+END_SRC
æ‰€ä»¥ m å¿…é¡»æ˜¯ä¸ª Endofunctorï¼Œä¹Ÿå°±æ˜¯è¦æ»¡è¶³ Functor
#+BEGIN_SRC haskell
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
#+END_SRC
t a çš„ kind æ˜¯ *ï¼Œæ‰€ä»¥ t å¿…é¡»æ˜¯ kind * -> *
ä¹Ÿå°±æ˜¯è¯´ï¼Œm å¿…é¡»æ˜¯æ¥æ”¶ä¸€ä¸ªç±»å‹å‚æ•°çš„ç±»å‹æ„é€ å™¨

è€Œ Either çš„ kind æ˜¯ * -> * -> *, Either a æ‰æ˜¯ * -> *

æ‰€ä»¥åªèƒ½å®šä¹‰ Either a çš„ Monad
#+BEGIN_SRC haskell
  instance Monad (Either a) where
    Left  l >>= _ = Left l
    Right r >>= k = k r
#+END_SRC

å¾ˆæ˜æ˜¾çš„ï¼Œ>>= ä»»ä½•å‡½æ•°åˆ°{{{ruby(å·¦è¾¹, Left)}}} éƒ½ä¸ä¼šæ”¹å˜ï¼Œåªæœ‰ >>= å³è¾¹æ‰èƒ½äº§ç”Ÿæ–°çš„è®¡ç®—ã€‚


** Reader å·®ä¸€ç‚¹å°±æœ‰
Reader çš„ä½œç”¨æ˜¯ç»™ä¸€ä¸ªè®¡ç®—å–‚æ•°æ®ã€‚

åœ¨æè¿°è®¡ç®—çš„æ—¶å€™ï¼Œå¹¶ä¸éœ€è¦å…³å¿ƒè¾“å…¥æ—¶ä»€ä¹ˆï¼Œåªéœ€è¦ asks å°±å¯ä»¥æ‹¿åˆ°è¾“å…¥å€¼

è€ŒçœŸæ­£çš„è¾“å…¥ï¼Œä¼šåœ¨è¿è¡Œè®¡ç®—æ—¶ç»™äºˆã€‚

è·Ÿ Identity ä¸€æ ·ï¼Œæˆ‘ä»¬ç”¨ newtype æ¥å®šä¹‰ä¸€ä¸ªåŒæ„çš„ Reader ç±»å‹
#+BEGIN_SRC haskell
newtype Reader e a = Reader { runReader :: (e -> a) }
#+END_SRC

å…¶ä¸­
- e æ˜¯è¾“å…¥
- a æ˜¯ç»“æœ
- æ„é€  Reader ç±»å‹éœ€è¦ç¡®å®š è¾“å…¥çš„ç±»å‹ e ä¸è¾“å‡ºçš„ç±»å‹ a
- =runReader= çš„ç±»å‹æ˜¯ =runReader:: (Reader e a) -> (e -> a)=

ä¹Ÿå°±æ˜¯è¯´åœ¨æè¿°å®Œä¸€ä¸ª Reader çš„è®¡ç®—åï¼Œä½¿ç”¨ runReader å¯ä»¥å¾—åˆ°ä¸€ä¸ª e -> a çš„å‡½æ•°ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå°±å¯ä»¥æ¥æ”¶è¾“å…¥ï¼Œé€šè¿‡æ„é€ å¥½çš„è®¡ç®—ï¼Œç®—å‡ºç»“æœ a è¿”å›ã€‚

é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬æ¥å®ç° Reader çš„ monad instanceï¼Œå°±å¯ä»¥æè¿°ä¸€ä¸ªå¯ä»¥ ask çš„è®¡ç®—äº†ã€‚

#+BEGIN_SRC haskell
instance Monad (Reader e) where
    return a         = Reader $ \_ -> a
    (Reader g) >>= f = Reader $ \e -> runReader (f (g e)) e
#+END_SRC

è·ŸEitherä¸€æ ·ï¼Œæˆ‘ä»¬åªèƒ½å®šä¹‰ Reader e çš„ monad instanceã€‚

æ³¨æ„è¿™é‡Œçš„
- f ç±»å‹æ˜¯ =(a -> Reader e a)=
- g å…¶å®å°±æ˜¯æ˜¯ destructure å‡ºæ¥çš„ runReaderï¼Œä¹Ÿå°±æ˜¯ e -> a
- æ‰€ä»¥ (g e) è¿”å› a
- f (g e) å°±æ˜¯ =Reader e a=
- å† run ä¸€æŠŠæœ€åå¾—åˆ° a

#+CAPTION: f å‡½æ•°ï¼Œæ¥æ”¶ a è¿”å›ä¸€ä¸ª ä» e åˆ° a çš„ Reader
[[file:images/p2-reader-monad.png]]

è®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ Reader
#+BEGIN_SRC haskell
  import Control.Monad.Reader

  data Environment = Env
    { fistName :: String
    , lastName :: String
    } deriving (Show)

  helloworld :: Reader Environment String
  helloworld = do
    f <- asks firstName
    l <- asks lastName
    return "Hello " ++ f ++ l

  runHelloworld :: String
  runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"
#+END_SRC

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œhelloworld è´Ÿè´£æ‰“æ‹›å‘¼ï¼Œä¹Ÿå°±æ˜¯åœ¨åå­—å‰é¢åŠ ä¸ª "Hello"ï¼Œè€Œè·Ÿè°æ‰“æ‹›å‘¼ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸å…³å¿ƒï¼Œè€Œå•çº¯çš„æ˜¯å‘ Environment {{{ruby(é—®,asks)}}} å°±å¥½ã€‚

#+CAPTION: asks å¯ä»¥å°† e -> a çš„å‡½æ•°å˜æ¢æˆ Reader e a
[[file:images/p2-reader-monad-ask.png]]

åœ¨è¿è¡Œæ—¶ï¼Œå¯ä»¥æä¾›ç»™ Reader çš„è¾“å…¥ Env fistname lastnameã€‚
[[file:images/p2-reader-monad-run.png]]

*** do notation
è¿™å¯èƒ½æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° =do= å’Œ =<-=. å¦‚æœä¸æ˜¯ï¼Œéšæ„è·³è¿‡è¿™èŠ‚ã€‚

- do ä¸­æ‰€æœ‰ <- çš„å³è¾¹éƒ½æ˜¯ =Reader Environment String= ç±»å‹
- do ä¸­çš„ return è¿”å›ç±»å‹ä¹Ÿå¿…é¡»ä¸º  =Reader Environment String=
- =asks firstName= è¿”å›çš„æ˜¯ =Reader Environment String= ç±»å‹ï¼Œ =<-= å¯ä»¥ç†è§£æˆå§ monad =Reader Environment= çš„å†…å®¹æ”¾åˆ°å·¦è¾¹çš„ f, æ‰€ä»¥ f çš„ç±»å‹æ˜¯ Stringã€‚

çœ‹èµ·æ¥åƒå‘½ä»¤å¼çš„è¯­å¥ï¼Œå…¶å®åªæ˜¯ ~>>=~ çš„è¯­æ³•ç³–ï¼Œä½†æ˜¯æ˜æ˜¾ç”¨doå¯è¯»æ€§è¦é«˜å¾ˆå¤šã€‚
#+BEGIN_SRC haskell
  helloworld = (asks firstName) >>=
    \f -> (asks lastName) >>=
         \l -> return "Hello " ++ f ++ l
#+END_SRC


** Writer å…‰å‡ºè¿›æ²¡æœ‰

é™¤äº†è¿”å›å€¼ï¼Œè®¡ç®—ä¼šéœ€è¦äº§ç”Ÿä¸€äº›é¢å¤–çš„æ•°æ®ï¼Œæ¯”å¦‚ log

æ­¤æ—¶å°±éœ€è¦ä¸€ä¸ª Writterï¼Œå…¶è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · =(result, log)= çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª {{{ruby(å«å¹ºåŠç¾¤,monoid)}}}

#+BEGIN_SRC haskell
example :: Writer String String
example  = do
  tell "How are you?"
  tell "I'm fine thank you, and you?"
  return "Hehe Da~"

output :: (String, String)
output = runWriter example
-- ("Hehe Da~", "How are you?I'm fine thank you, and you?")
#+END_SRC

Writer çš„å®šä¹‰æ›´ç®€å•
#+BEGIN_SRC haskell
newtype Writer l a = Writer { runWriter :: (a,l) }
#+END_SRC
é‡Œé¢åªæ˜¯ä¸€ä¸ª tuple è€Œå·²
- w æ˜¯ log
- a æ˜¯ è¿”å›å€¼

çœ‹çœ‹å¦‚ä½•å®ç° Writer monad
#+BEGIN_SRC haskell
  instance (Monoid w) => Monad (Writer w) where
      return a             = Writer (a,mempty)
      (Writer (a,l)) >>= f = let (a',l') = runWriter $ f a in
                             Writer (a',l `mappend` l')
#+END_SRC

- return ä¸ä¼šæœ‰ä»»ä½• logï¼Œl æ˜¯ monoid çš„ mempty
- f çš„ç±»å‹ä¸º =a -> Writer l a=
- =runWriter $ f a= è¿”å› =(a, l)=

[[file:images/p2-writer-monad.png]]

æ‰€ä»¥åœ¨ >>= æ—¶ï¼Œæˆ‘ä»¬å…ˆæŠŠ f a è¿”å›çš„ Writer runäº†ï¼Œç„¶åæŠŠä¸¤æ¬¡ log =mappend= èµ·æ¥ã€‚
[[file:images/p2-writer-monad-bind.png]]

** State å˜åŒ–ä¼šæœ‰
è·Ÿåå­—å°±çœ‹å¾—å‡ºæ¥ State monad æ˜¯ä¸ºäº†å¤„ç†çŠ¶æ€ã€‚è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹ä¸åº”è¯¥æœ‰çŠ¶æ€ï¼Œä¸ç„¶ä¼šå¼•ç”¨é€æ˜æ€§ã€‚ä½†æ˜¯ï¼Œstate monadå¹¶ä¸æ˜¯åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹çŠ¶æ€ï¼Œè€Œæ˜¯é€šè¿‡æè¿°è¿™ç§å˜åŒ–ï¼Œç„¶åéœ€è¦æ—¶åœ¨è¿è¡Œè¿”å›æœ€ç»ˆç»“æœã€‚è¿™ä¸€ç‚¹è·Ÿ Reader å’Œ Writer è¿™ä¸¤ä¸ªçœ‹èµ·æ¥æ˜¯å‰¯ä½œç”¨çš„ IO æ˜¯ä¸€æ ·çš„ã€‚

å…ˆçœ‹ä¸‹ State ç±»å‹çš„å®šä¹‰
#+BEGIN_SRC haskell
newtype State s a = State { runState :: s -> (a, s) }
#+END_SRC

å¯ä»¥çœ‹åˆ° State åªåŒ…å«ä¸€ä¸ª ä»æ—§çŠ¶æ€ s åˆ°æ–°çŠ¶æ€ s å’Œè¿”å›å€¼ a çš„ Tuple çš„å‡½æ•°ã€‚

é€šè¿‡å®ç° Monadï¼ŒState å°±å¯ä»¥å®ç°å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„å˜é‡çš„åŠŸèƒ½ã€‚
#+BEGIN_SRC haskell
  instance Monad (State s) where
    return a        = State $ \s -> (a,s)
    (State x) >>= f = State $ \s -> let (v,s') = x s in
                                   runState (f v) s'
#+END_SRC
return å¾ˆç®€å•ï¼Œå°±ä¸ç”¨è§£é‡Šäº†ã€‚

[[file:images/p2-state-monad.png]]

x ç±»å‹æ˜¯ =s -> (a, s)= ,æ‰€ä»¥ x s ä¹‹åä¼šè¿”å› ç»“æœå’ŒçŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¿è¡Œå½“å‰ Stateï¼ŒæŠŠç»“æœ v ä¼ ç»™å‡½æ•° fï¼Œè¿”å›çš„ State å†æ¥ç€ä¸Šæ¬¡çŠ¶æ€è¿è¡Œã€‚

#+CAPTION: State x >>= f årunStateçš„æ•°æ®æµï¼ˆå•Šå•Šå•Šï¼Œç”»æ­ªäº†ï¼Œæ„Ÿè§‰éœ€è¦è„‰åŠ¨ä¸€ä¸‹ï¼‰
[[file:images/p2-state-monad-bind.png]]

ä½¿ç”¨èµ·æ¥ä¹Ÿå¾ˆæ–¹ä¾¿ï¼ŒState æä¾› =get= =put= =moidfy= ä¸‰ä¸ªæ–¹ä¾¿çš„å‡½æ•°å¯ä»¥ç”Ÿæˆä¿®æ”¹çŠ¶æ€çš„State monad

#+BEGIN_SRC haskell :results output
  import Control.Monad.Trans.State.Strict
  test :: State Int Int
  test = do
    a <- get
    modify (+1)
    b <- get
    return (a + b)

  main = print $ show $ runState test 3
  -- (7, 4)
#+END_SRC


** Validation æ£€æŸ¥æ£€æŸ¥
å¦‚æœä½ æœ‰æ³¨æ„åˆ°ï¼Œå‰é¢çš„ Either å¯ä»¥ç”¨åœ¨å¤„ç†é”™è¯¯å’Œæ­£ç¡®çš„è·¯å¾„åˆ†æ”¯ï¼Œä½†æ˜¯é—®é¢˜æ˜¯é”™è¯¯åªå‘ç”Ÿä¸€æ¬¡ã€‚

#+BEGIN_QUOTE
Validation æ²¡æœ‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œä½†æ˜¯æˆ‘è§‰å¾—å¥½æœ‰ç”¨å•Šï¼Œä½ å¯ä»¥åœ¨ ekmett çš„ [[https://github.com/ekmett/either][github]] ä¸­æ‰¾åˆ°æºç 
#+END_QUOTE

æƒ³è±¡ä¸€ä¸‹è¿™ç§åœºæ™¯ï¼Œç”¨æˆ·æäº¤ä¸€ä¸ªè¡¨å•ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸€ä¸ªfieldè¿›è¡ŒéªŒè¯ï¼Œå¦‚æœæœ‰é”™è¯¯ï¼Œéœ€è¦æŠŠé”™è¯¯çš„å“ªå‡ ä¸ªfieldçš„é”™è¯¯æ¶ˆæ¯è¿”å›ã€‚æ˜¾ç„¶å¦‚æœä½¿ç”¨ Either æ¥åšï¼Œåªèƒ½è¿”å›ç¬¬ä¸€ä¸ªfieldçš„é”™è¯¯ä¿¡æ¯ï¼Œåé¢çš„è®¡ç®—éƒ½ä¼šè¢«è·³è¿‡ã€‚

é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œ Validation æ›´é€‚åˆ
#+BEGIN_SRC haskell
data Validation e a = Failure e | Success a
#+END_SRC

ADTå®šä¹‰çœ‹èµ·æ¥è·Ÿ Either æ˜¯ä¸€æ ·çš„ï¼Œä¸åŒçš„æ˜¯ {{{ruby(å·¦è¾¹,Left)}}} Failure æ˜¯ {{{ruby(å«å¹ºåŠç¾¤,Monoid)}}}

*** {{{ruby(å«å¹ºåŠç¾¤,Monoid)}}}
monoid é¦–å…ˆå¾—æ˜¯ {{{ruby(åŠç¾¤,Semigroup)}}} ï¼Œç„¶åå† å«å¹ºã€‚
#+BEGIN_SRC haskell
  class Semigroup a where
    (<>) :: a -> a -> a
    (<>) = mappend
#+END_SRC

åŠç¾¤éå¸¸ç®€å•ï¼Œåªè¦æ˜¯å¯ä»¥ =<>= (mappend) çš„ç±»å‹å°±æ˜¯äº†ã€‚

å«å¹ºåªéœ€è¦æœ‰ä¸€ä¸ª =mempty= çš„ å¹ºå…ƒå°±è¡Œ
#+BEGIN_SRC haskell
  class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
#+END_SRC

æ¯”å¦‚ List å°±æ˜¯ Semigroup
#+BEGIN_SRC haskell
instance Semigroup [a] where
  (<>) = (++)
#+END_SRC
ä¹Ÿæ˜¯ Monoid
#+BEGIN_SRC haskell
  instance Monoid [a] where
    mempty  = []
    mappend = (++)
#+END_SRC

Monoid çš„ =<>= æ»¡è¶³ï¼š
- mempty <> a = a
- a <> b <> c = a <> (b <> c)
*** å›åˆ° Validation
ç°åœ¨è®© Failure e æ»¡è¶³ Monoidï¼Œå°±å¯ä»¥ =mappend= é”™è¯¯ä¿¡æ¯äº†ã€‚
#+BEGIN_SRC haskell
instance Semigroup e => Semigroup (Validation e a) where
  Failure e1 <> Failure e2 = Failure (e1 <> e2)
  Failure _  <> Success a2 = Success a2
  Success a1 <> Failure _  = Success a1
  Success a1 <> Success _  = Success a1
#+END_SRC

ä¸‹æ¥ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹çœ‹ Validation ä¸ Either æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªformï¼Œéœ€è¦è¾“å…¥å§“åä¸ç”µè¯ï¼ŒéªŒè¯éœ€è¦å§“åæ˜¯éç©ºè€Œç”µè¯æ˜¯11ä½æ•°å­—ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªå‡½æ•°å»åˆ›å»ºåŒ…å«å§“åå’Œç”µè¯çš„model
#+BEGIN_SRC haskell
data Info = Info {name: String, phone: String} deriving Show
#+END_SRC

ç„¶åæˆ‘ä»¬éœ€è¦éªŒè¯å‡½æ•°
#+BEGIN_SRC haskell
notEmpty :: String -> String -> Validation [String] String
notEmpty desc "" = Failure [desc <> " cannot be empty!"]
notEmpty _ field = Success field
#+END_SRC
notEmpty æ£€æŸ¥å­—ç¬¦æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ˜¯ç©ºè¿”å› Failure åŒ…å«é”™è¯¯ä¿¡æ¯ï¼Œè‹¥æ˜¯éç©ºåˆ™è¿”å› Success åŒ…å« field

åŒæ ·çš„å¯ä»¥åˆ›å»º 11ä½æ•°å­—çš„éªŒè¯å‡½æ•°
#+BEGIN_SRC haskell
  phoneNumberLength :: String -> String -> Validation [String] String
  phoneNumberLength desc field | (length field) == 11 = Success field
                               | otherwise = Failure [desc <> "'s length is not 11"]
#+END_SRC
å®ç° Validation çš„ Applicative instanceï¼Œè¿™æ ·å°±å¯ä»¥æŠŠå‡½æ•°è°ƒç”¨liftæˆå¸¦æœ‰éªŒè¯çš„ Applicative
#+BEGIN_SRC haskell
instance Semigroup e => Applicative (Validation e) where
  pure = Success
  Failure e1 <*> Failure e2 = Failure e1 <> Failure e2
  Failure e1 <*> Success _  = Failure e1
  Success _  <*> Failure e2 = Failure e2
  Success f <*> Success a = Success (f a)
#+END_SRC
- å¤±è´¥åº”ç”¨åˆ°å¤±è´¥ä¼š concat èµ·æ¥
- å¤±è´¥è·Ÿåº”ç”¨æˆ–è¢«æˆåŠŸåº”ç”¨è¿˜æ˜¯å¤±è´¥
- åªæœ‰æˆåŠŸåº”ç”¨åˆ°æˆåŠŸæ‰èƒ½æˆåŠŸï¼Œè¿™å¾ˆç¬¦åˆéªŒè¯çš„é€»è¾‘ï¼Œä¸€æ—¦éªŒè¯ä¸­å‘ç”Ÿä»»ä½•é”™è¯¯ï¼Œéƒ½åº”è¯¥è¿”å›å¤±è´¥ã€‚

#+BEGIN_SRC haskell
createInfo :: String -> String -> Validation [String] Info
createInfo name phone = Info <$> notEmpty "name" name <*> phoneNumberLength "phone" phone
#+END_SRC

ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨å¸¦validationçš„ createInfo æ¥å®‰å…¨çš„åˆ›å»º Info äº†

#+BEGIN_SRC haskell
createInfo "jichao" "12345678910" -- Success Info "jichao" "12345678910"
createInfo "" "123" -- Failure ["name cannot be empty!", "phone's length is not 11"]
#+END_SRC

** Cont æ¥ä¸‹æ¥æœ‰
Cont æ˜¯ {{{ruby(Continuation Passing Style,CPS)}}} çš„ monadï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯åŒ…å« cps è®¡ç®— monadã€‚

å…ˆçœ‹ä¸€ä¸‹ä»€ä¹ˆæ˜¯ CPSï¼Œæ¯”å¦‚æœ‰ä¸€ä¸ªåŠ æ³•
#+BEGIN_SRC haskell
add :: Int -> Int -> Int
add = (+)
#+END_SRC

ä½†æ˜¯å¦‚æœä½ æƒ³åœ¨ç®—æ³•åŠ æ³•åï¼Œèƒ½å¤Ÿç»§ç»­è¿›è¡Œä¸€ä¸ªå…¶ä»–çš„è®¡ç®—ï¼Œé‚£ä¹ˆå°±å¯ä»¥å†™ä¸€ä¸ª cpsç‰ˆæœ¬çš„åŠ æ³•
#+BEGIN_SRC haskell
addCPS :: Int -> Int -> (Int -> r) -> r
addCPS a b k = k (a + b)
#+END_SRC

éå¸¸ç®€å•ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹çœ‹ä¸ºä»€ä¹ˆéœ€è¦ä¸€ä¸ª Cont monad æ¥åŒ…ä½ CPS è®¡ç®—ï¼Œé¦–å…ˆï¼Œæ¥çœ‹ ADT å®šä¹‰
#+BEGIN_SRC haskell
newtype Cont r a = Cont { runCont :: ((a -> r) -> r) }
#+END_SRC

åˆæ˜¯ä¸€ä¸ªåŒæ„çš„ç±»å‹ï¼ŒCont æ„é€ å™¨åªéœ€è¦ä¸€ä¸ª runCountï¼Œä¹Ÿå°±æ˜¯è®©ä»–èƒ½ç»§ç»­è®¡ç®—çš„ä¸€ä¸ªå‡½æ•°ã€‚

å®Œäº†ä¹‹åæ¥æŠŠä¹‹å‰çš„ addCPS æ”¹æˆ Cont
#+BEGIN_SRC haskell
add :: Int -> Int -> Cont k Int
add a b = return (a + b)
#+END_SRC

æ³¨æ„åˆ° addCPS æ¥æ”¶åˆ° a å’Œ b ä¹‹åè¿”å›çš„ç±»å‹æ˜¯ =(Int -> r) -> r= ï¼Œè€Œ Cont ç‰ˆæœ¬çš„ =add= è¿”å› =Cont k Int=

æ˜æ˜¾æ„é€  =Cont k Int= ä¹Ÿæ­£æ˜¯éœ€è¦ =(Int -> r) -> r= ï¼Œæ‰€ä»¥ Cont å°±æ˜¯ç®—äº† k çš„æŠ½è±¡äº†ã€‚

#+BEGIN_SRC haskell
instance Monad (Cont r) where
    return a = Cont ($ a)
    m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
#+END_SRC

=($ a)= æ¯”è¾ƒæœ‰æ„æ€, æˆ‘ä»¬éƒ½çŸ¥é“ =f $ g a= å…¶å®å°±æ˜¯ =f(g a)=, æ‰€ä»¥ =$= å…¶å®å°±æ˜¯ä¸€ä¸ª apply å·¦è¾¹çš„å‡½æ•°åˆ°å³è¾¹è¡¨è¾¾å¼çš„ä¸­ç¼€å‡½æ•°, å¦‚æœå†™æˆå‰ç¼€åˆ™æ˜¯
=($ (g a) f)=. æ˜¯åçš„æ˜¯å› ä¸º =$= æ˜¯æœ‰ç»“åˆ, éœ€è¦å³è¾¹è¡¨è¾¾å¼å…ˆæ±‚å€¼, æ‰€ä»¥åªç»™ä¸€ä¸ª a å°±ç›¸å½“äº =($ a) = \f -> f a=

å›åˆ° Monad Cont...

** Summary
ç¬¬äºŒéƒ¨åˆ†é£Ÿç”¨éƒ¨åˆ†ä¹Ÿè®²å®Œäº†ï¼Œ ä¸çŸ¥æ˜¯å¦ä»¥åŠå¤§è‡´äº†è§£äº†monadçš„å°¿æ€§å„ç§åŸºæœ¬ç©æ³•å‘¢ï¼Ÿé€šè¿‡è¿™äº›å¸¸ç”¨çš„åŸºæœ¬çš„ monad instanceï¼Œè§£å†³å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„ä¸€äº›ç®€å•é—®é¢˜åº”è¯¥æ˜¯å¤Ÿäº†ã€‚

ä¸è¿‡ï¼Œæ¥ä¸‹æ¥è¿˜æœ‰æ›´å˜æ€çš„çŒ«ï¼Œå°±å…ˆå«å¥¹ +æåŸº+ çŒ«å‘¢å¥½äº†ã€‚

- ğŸ‘‰ [[./part3.org][ç¬¬ä¸‰éƒ¨åˆ†ï¼š{{{ruby(æåŸºçŒ«å‘¢, Advanced Monads)}}}]]

å½“ç„¶æˆ‘åˆè¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœè¿˜æœ‰å¾ˆå¤šäºº{{{ruby(é¢„å®š,åªè¦998)}}} Gumroad ä¸Šçš„ @@html: <script src="https://gumroad.com/js/gumroad.js"></script><a class="gumroad-button" href="https://gum.co/grokking-monad" target="_blank">Grokking Monad</a>@@ ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œï¼Œå°±å½“æ˜¯æˆ‘åˆè‡ªè¨€è‡ªè¯­å§ï¼Œæ€ä¹ˆåˆçªç„¶è§‰å¾—è‡ªå·±å¥½åˆ†è£‚ï¼Œè¯¶~ï¼Œä¸ºä»€ä¹ˆæˆ‘è¦è¯´åˆï¼Ÿ

* Footnotes

[fn:6] https://en.wikipedia.org/wiki/Through_the_Looking-Glass

[fn:1] ä»æ¥æ²¡è§è¿‡æœ‰äººç»™è¿™äº›æ•°æ®ç±»å‹æŒ‰è¿‡ä¸­æ–‡åå­—, ä¸ç„¶æˆ‘æ¥, è¿™æ ·ä¹Ÿæ›´å¥½çš„ä½“ä¼šè¿™äº›æ•°æ®ç±»å‹çš„æ„å›¾.

[fn:5] æ„æ€å°±æ˜¯ =Maybe a= ä½†æ˜¯ =a= çš„ç±»å‹çº¦æŸä¸º =Num=

[fn:4] ä¸€å®šè¦è®°å¾—å°å†™å“¦

[fn:2] è§ [[file:part1.org::*/Adjunction%20Functor/%20%E4%BC%B4%E9%9A%8F%E5%87%BD%E5%AD%90][ç¬¬ä¸€éƒ¨åˆ† ä¼´éšå‡½å­]]

[fn:3] ä¹Ÿå°±æ˜¯ Kind * -> *, å› ä¸ºå®ƒéå¸¸çš„ nice, ä¸€å®šè¦ç­‰åˆ° a æ‰å‡ºç±»å‹
