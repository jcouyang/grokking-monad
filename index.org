# Created 2019-04-02 Tue 00:13
#+OPTIONS: ^:t todo:nil toc:t num:3
#+OPTIONS: ^:t
#+OPTIONS: ^:t
#+OPTIONS: ^:t
#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad
#+DATE: <2017-02-10 Fri> <2017-02-10 Fri> <2017-02-10 Fri> <2018-07-28 Sat>
#+AUTHOR: æ¬§é˜³ç»§è¶… æ¬§é˜³ç»§è¶… æ¬§é˜³ç»§è¶… æ¬§é˜³ç»§è¶…
#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [a5paper]
#+LATEX_HEADER: \usepackage[unicode,dvipdfm]{hyperref}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{STXihei}
#+DESCRIPTION: å…¨å·
#+INDEX: Catergory Theory!èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ å…¨

#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@
#+EXPORT_FILE_NAME: index.org
#+BEGIN_CENTER
FBI Warning
#+HTML: æœ¬æ–‡æ‰€æœ‰æ–‡å­—ä¸å›¾ç‰‡éµå¾ª <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">CC ç½²å-éå•†ä¸šæ€§ä½¿ç”¨-ç¦æ­¢æ¼”ç» 3.0 è®¸å¯åè®®</a><br/><a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a>
#+END_CENTER

ğŸ‘‡PDFï¼Œkindleï¼Œ epubæ ¼å¼çš„ä¹¦ç°å·²å¼€æ”¾è´­ä¹°...

è´­ä¹°é“¾æ¥æ˜¯ gumroadï¼Œéœ€è¦ç§‘å­¦ä¸Šç½‘æ‰èƒ½ç‚¹å¼€ï¼Œå¦‚æœä½ ä¸èƒ½ç§‘å­¦ä¸Šç½‘ï¼Œå°±ä¸è¦ä¹°äº†ï¼ˆå½“ç„¶ä¹Ÿæ²¡æ³•ä¹°ï¼‰ï¼ŒæŠŠè¿™å…­å—é’±æŠ•èµ„åˆ°ç§‘å­¦ä¸Šç½‘ä¸Šå§ã€‚

#+HTML: <script src="https://gumroad.com/js/gumroad-embed.js"></script><div class="gumroad-product-embed" data-gumroad-product-id="grokking-monad"><a href="https://gumroad.com/l/grokking-monad"><img src="https://blog.oyanglul.us/grokking-monad/cover.jpg"></img></a></div>


#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@
#+PROPERTY: header-args :eval never-export
#+DESCRIPTION: å·ä¸€ çŒ«è®º
#+INDEX: Catergory Theory!èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ å·ä¸€

- *[[file:./part1.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šçŒ«è®º]]* ğŸ‘ˆ
- [[file:./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]
- [[file:./part3.org][ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢]]
* ç¬¬ä¸€éƒ¨åˆ†ï¼š@@html:<ruby>çŒ«è®º<rt>Catergory Theory</rt></ruby>@@

https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/De_Alice%27s_Abenteuer_im_Wunderland_Carroll_pic_23_edited_1_of_2.png/1920px-De_Alice%27s_Abenteuer_im_Wunderland_Carroll_pic_23_edited_1_of_2.png [fn:-1-1]

#+BEGIN_QUOTE
`But I donâ€™t want to go among mad people,â€™ Alice remarked.

`Oh, you canâ€™t help that,â€™ said the Cat: `weâ€™re all mad here. Iâ€™m mad. Youâ€™re mad.â€™

`How do you know Iâ€™m mad?â€™ said Alice.
`You must be,â€™ said the Cat, `or you wouldnâ€™t have come here.â€™

Alice didnâ€™t think that proved it at all; however, she went on `And how do you know that youâ€™re mad?â€™

-- Alice's Adventures in Wonderland
#+END_QUOTE

æ˜¯ä»€ä¹ˆ? ä½ ä¹Ÿä¸æ‡‚, æˆ‘ä¹Ÿä¸æ‡‚, æˆ‘ä»¬éƒ½ä¸æ‡‚.

è¯è¯´, æˆ‘åˆæ€ä¹ˆçŸ¥é“ä½ ä¸æ‡‚å‘¢?

å½“ç„¶ä¸æ‡‚, ä¸ç„¶, ä½ æ€ä¹ˆä¼šæ¥åˆ°è¿™é‡Œ?

æˆ‘åˆæ˜¯æ€ä¹ˆçŸ¥é“è‡ªå·±ä¸æ‡‚å‘¢?

å› ä¸º, æˆ‘çŸ¥é“æ‡‚çš„äººä»€ä¹ˆæ ·å­. æ˜¾ç„¶, æˆ‘ä¸æ˜¯.

æ‡‚çš„äººä¸€å®šçŸ¥é“.

æ‡‚çŒ«è®ºçš„äººåˆä¸ä¸€å®šçŸ¥é“ç¼–ç¨‹. ä½†æ˜¯æ‡‚ç¼–ç¨‹çš„äººå¯ä»¥ç•¥æ‡‚çŒ«è®º.

ç¼–ç¨‹æ˜¯é¡¹æŠ€æœ¯, å³ç†è®ºçš„é™ç»´. æ‰€ä»¥è¦é™ä½é—¨æ§›, æ¯”å¦‚æˆ‘åœ¨ä¹¦ä¸­ä¹Ÿ[[https://book.douban.com/subject/26883736/][å†™è¿‡ä¸€ç« ]]ç”¨JavaScriptæ¥è§£é‡Šï¼ŒæŸäººä¹Ÿå°è¯•è¿‡[[http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html][å†™åšå®¢è§£é‡Š]]ï¼Œ[fn:-1-2]æ²¡æƒ³åˆ°é‚£äº›ä¹Ÿä¸çŸ¥é“ä¼šä¸ä¼š Haskell/Scala çš„äººå°±è·‘å‡ºæ¥å–·ä½ ä»¬å‰ç«¯[fn:-1-3]è¿™äº›ä¸æ‡‚å‡½æ•°å¼çš„æ¸£æ¸£ä¹±æå‡ºæ¥çš„ä¸œè¥¿æ ¹æœ¬å°±ä¸æ˜¯å•å­ã€‚

æˆ‘ä¹Ÿç”»è¿‡ä¸€äº›å›¾æ¥è§£é‡Šï¼Œåˆä¼šè¢«å«Œå¼ƒç”»é£ä¸å¥½ã€‚ä½†æ˜¯ï¼Œä½œä¸ºçµé­‚ç”»å¸ˆï¼Œæˆ‘åª +æ˜¯è§‰å¾—è‡ªå·±èŒèŒçš„å•Š+ åœ¨ä¹ç”»çš„çµé­‚æ˜¯å¦èƒ½å¤Ÿç»™ä½ ä¸€ç‚¹å¯å‘ã€‚å¥½å§ï¼Œè®²è¿™ä¹ˆå­¦æœ¯çš„ä¸œè¥¿ï¼Œè¿˜æ˜¯ç”¨dotæ¥ç”»å§ï¼Œçœ‹èµ·æ¥å¥½æ­£è§„å‘¢ã€‚

å¥½äº†ï¼Œå®‰å…¨å¸¦ç³»å¥½ï¼Œæˆ‘çœŸçš„è¦å¼€è½¦äº†ã€‚ä¸ºäº†é˜²æ­¢ï¼Œå°±ç”¨ Haskell/Scala å¥½äº†[fn:-1-4]ï¼Œå…¶å®ä¹Ÿä¸éš¾è§£é‡Šæ¸…æ¥š +æ‰æ€ª+ ã€‚

è¿™é‡Œé¢å¾ˆå¤šå¾ˆè£…é€¼çš„å•è¯ï¼Œå®ƒä»¬éƒ½æ˜¯ /æ–œä½“/ ï¼Œå°±ç®—æ²¡çœ‹æ‡‚ï¼ŒæŠŠè¿™äº›è¯èƒŒä¸‹æ¥ä¹Ÿè¶³å¤Ÿã€‚

è¿™é‡Œè¿˜æœ‰å¾ˆå¤šä»£ç , å®ƒä»¬éƒ½æˆå¯¹å‡ºç°, ç¬¬ä¸€æ®µæ˜¯ Haskell, ç¬¬äºŒæ®µæ˜¯ Scala.

[fn:-1-1] https://en.wikipedia.org/wiki/Cheshire_Cat

[fn:-1-2] å¦‚æœæ²¡çœ‹å°±åˆšå¥½ä¸è¦çœ‹äº†, ç¡®å®æœ‰äº›è¯¯å¯¼

[fn:-1-3] ç­‰ç­‰, å†™å‰ç«¯æ€ä¹ˆäº†? JavaScript åªæ˜¯æˆ‘è§‰å¾—é¡ºæ‰‹çš„è‹¥å¹²è¯­è¨€ä¹‹ä¸€, JSç”¨æˆ·é‚£ä¹ˆå¤š, å†™ä¹¦å½“ç„¶è¦ç”¨ JS å•¦, éš¾é“ç”¨ Idris é‚£è¿˜èƒ½å–å¾—æ‰å—? +å½“ç„¶æœ€åç”¨JSä¹Ÿæ²¡æ€ä¹ˆå–æ‰...+

[fn:-1-4] å¹¶ä¸æ˜¯è¯´è¿™ä¸¤é—¨è¯­è¨€ä¸€å®šåœ¨é„™è§†é“¾é¡¶ç«¯, è€Œæ˜¯æ‹¥æœ‰å¼ºå¤§ç±»å‹ç³»ç»Ÿçš„è¯­è¨€æ‰èƒ½ä½“ç°å‡ºèŒƒç•´è®ºçš„å†…å®¹

** /Category/
#+INDEX: Catergory
#+INDEX: èŒƒç•´

ä¸€ä¸ª // åŒ…å«ä¸¤ä¸ªç©æ„
- ä¸œè¥¿ =O= ï¼ˆObjectï¼‰
- ä¸¤ä¸ªä¸œè¥¿çš„å…³ç³»ï¼Œç®­å¤´ =~>= ï¼ˆ // ï¼‰

è¿˜å¿…é¡»å¸¦ä¸Šä¸€äº›å±æ€§: 
- ä¸€å®šæœ‰ä¸€ä¸ªå« id çš„ç®­å¤´ï¼Œä¹Ÿå«åš 1
- ç®­å¤´å¯ä»¥ //

æ©, å°±æ˜¯è¿™ä¹ˆç®€å•!

#+CAPTION: æœ‰ä¸œè¥¿ a, b, c å’Œç®­å¤´ f, g çš„ Categoryï¼Œå…¶ä¸­ f . g è¡¨ç¤º compose f å’Œ g
#+RESULTS: 
[[file:images/category.svg]]


#+BEGIN_QUOTE
æ³¨æ„åˆ°ä¸ºä»€ä¹ˆæˆ‘ä¼šç®­å¤´ä»å³å¾€å·¦ï¼Œæ¥ç€çœ‹ä»£ç , ä½ ä¼šå‘ç°è¿™ä¸ªæ–¹å‘è·Ÿ compose çš„æ–¹å‘åˆšå¥½ä¸€è‡´!
#+END_QUOTE

è¿™äº›ç©æ„å¯¹åº”åˆ° haskell çš„ typeclass å¤§è‡´å°±æ˜¯è¿™æ ·:

#+BEGIN_SRC haskell
  class Category (c :: * -> * -> *) where
    id :: c a a
    (.) :: c y z -> c x y -> c x z
#+END_SRC


è€Œ Scala å¯ä»¥ç”¨ trait æ¥è¡¨ç¤ºè¿™ä¸ª typeclass:
#+BEGIN_SRC scala
  trait Category[C[_, _]] {
    val id[A]: C[A, A]
    def <<<(a: C[Y, Z], b: C[X, Y]): C[X, Z] 
  }
#+END_SRC

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° Haskell ä»£ç ï¼Œæ²¡æœ‰å…³ç³»ï¼Œè¯­æ³•çœŸçš„å¾ˆç®€å• +æ‰æ€ª+
- =class= å®šä¹‰äº†ä¸€ä¸ª TypeClassï¼Œ =Category= æ˜¯è¿™ä¸ª TypeClass çš„åå­—
- Type class ç±»ä¼¼äºå®šä¹‰ç±»å‹çš„è§„èŒƒï¼Œè§„èŒƒä¸º =where= åé¢é‚£ä¸€å¨
- ç±»å‹è§„èŒƒçš„å¯¹è±¡æ˜¯å‚æ•° ~(c:: * -> * -> *)~ ï¼Œ =::= åé¢æ˜¯cçš„ç±»å‹
- c æ˜¯ /higher kind/ =* -> *= ï¼Œè·Ÿhigher order functionçš„å®šä¹‰å·®ä¸å¤šï¼Œå®ƒæ˜¯æ¥æ”¶ç±»å‹ï¼Œæ„é€ æ–°ç±»å‹çš„ç±»å‹ã€‚è¿™é‡Œçš„ c æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå†æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå°±å¯ä»¥è¿”å›ä¸ªç±»å‹ã€‚
#+INDEX: Kind
- ~id:: c a a~ è¡¨ç¤º c èŒƒç•´ä¸Šçš„ a åˆ° a çš„ç®­å¤´
- =.= çš„æ„æ€ c èŒƒç•´ä¸Šï¼Œå¦‚æœå–‚ä¸€ä¸ª y åˆ° z çš„ç®­å¤´ï¼Œå†å–‚ä¸€ä¸ª x åˆ° y çš„ç®­å¤´ï¼Œé‚£ä¹ˆå°±è¿”å› x åˆ° z çš„ç®­å¤´ã€‚

å¦å¤– compose åœ¨ haskell ä¸­ç›´æ¥æ˜¯å¥å· =.=

scala ä¸­ç”¨ =<<<= æˆ–è€… =compose=

æ€»ä¹‹, ç”¨æ–‡å­—å†è¯»ä¸€éä¸Šé¢è¿™äº›ä»£ç å°±äº†ç„¶äº†.

èŒƒç•´ C å…¶å®å°±åŒ…å«
1. è¿”å› A å¯¹è±¡åˆ° A å¯¹è±¡çš„ id ç®­å¤´
2. å¯ä»¥ç»„åˆ Y å¯¹è±¡åˆ° Z å¯¹è±¡ å’Œ X å¯¹è±¡åˆ° Y å¯¹è±¡çš„ç®­å¤´ compose

?è¿˜æ²¡æœ‰é«˜æ•°æŠ½è±¡å‘¢ã€‚

*** /Hask/
Haskell ç±»å‹ç³»ç»ŸèŒƒç•´å«åš Hask
#+INDEX: Hask

åœ¨ Hask èŒƒç•´ä¸Šï¼š

- ä¸œè¥¿å°±æ˜¯ç±»å‹
- ç®­å¤´æ˜¯ç±»å‹çš„å˜æ¢ï¼Œå³ =->=
- id å°±æ˜¯ id å‡½æ•°çš„ç±»å‹ =a -> a=
- compose å½“ç„¶å°±æ˜¯å‡½æ•°ç»„åˆçš„ç±»å‹

#+BEGIN_SRC haskell
  type Hask = (->)
  instance Category (Hask:: * -> * -> *) where
    (f . g) x = f (g x)
#+END_SRC

æˆ‘ä»¬çœ‹è§æ–°çš„å…³é”®å­— =instance= ï¼Œè¿™è¡¨ç¤º Hask æ˜¯ Type class Category çš„å®ä¾‹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹ä»»æ„Haskç±»å‹, é‚£ä¹ˆå°±èƒ½æ‰¾åˆ°å®ƒçš„ id å’Œ compose

#+BEGIN_SRC scala
  implicit val haskCat: Category[Hask[_, _]] = new Category[Hask] {
    val id[A] = identity[A]
    def <<<[X, Y, Z](a: Hask[Y, Z], b: Hask[X, Y]) = a compose b
  }
#+END_SRC

Scala ä¸­, åªéœ€è¦ new è¿™ä¸ª trait å°±å¯ä»¥å®ç°è¿™ä¸ª typeclass

å…¶ä¸­: identity =Hask a a= å°±æ˜¯
#+BEGIN_SRC haskell
  (->) a a -- or
  a -> a -- å› ä¸º -> æ˜¯ä¸­ç¼€æ„é€ å™¨
#+END_SRC

#+BEGIN_SRC scala
  A => A
#+END_SRC


*** /Duel/
#+INDEX: Duel
æ¯ä¸ª Category è¿˜æœ‰ä¸€ä¸ªé•œåƒï¼Œä»€ä¹ˆéƒ½ä¸€æ ·ï¼Œé™¤äº†ç®­å¤´æ˜¯åçš„

** å‡½å­ / Functor
#+INDEX: Functor
#+INDEX: å‡½å­
ä¸¤ä¸ªèŒƒç•´ä¸­é—´å¯ä»¥ç”¨å« Functor çš„ä¸œè¥¿æ¥è¿æ¥èµ·æ¥ï¼Œç®€ç§° Tã€‚

#+CAPTION: Functor C D T, ä» C åˆ° D èŒƒç•´çš„Functor T
#+RESULTS: 
[[file:images/functor.svg]]

æ‰€ä»¥å¤§éƒ¨åˆ†æŠŠ Functor/Monad æ¯”å–»æˆç›’å­å…¶å®åœ¨å®šä¹‰ä¸Šæ˜¯é”™çš„ï¼Œè™½ç„¶è¿™æ ·æ¯”å–»æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œåœ¨ä½¿ç”¨ä¸Šé—®é¢˜ä¹Ÿä¸å¤§ã€‚ä½†æ˜¯ï¼ŒFunctor åªæ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„æ˜ å°„å…³ç³»è€Œå·²ã€‚

- èŒƒç•´é—´ ä¸œè¥¿çš„ Functor æ ‡è®°ä¸º =T(O)=
- èŒƒç•´é—´ ç®­å¤´çš„ Functor æ ‡è®°ä¸º =T(~>)=
- ä»»ä½•èŒƒç•´Cä¸Šå­˜åœ¨ä¸€ä¸ª T æŠŠæ‰€æœ‰çš„ O å’Œ ~> éƒ½æ˜ å°„åˆ°è‡ªå·±ï¼Œæ ‡è®°ä¸ºid functor 1_C
  - 1_C(O) = O
  - 1_C(~>) = ~>

#+BEGIN_SRC haskell
  class (Category c, Category d) => Functor c d t where
    fmap :: c a b -> d (t a) (t b)
#+END_SRC

#+BEGIN_SRC scala
  trait Functor[C[_, _], D[_, _], T[_]] {
    def fmap[A, B](c: C[A, B]): D[T[A], T[B]]
  }
#+END_SRC

=Functor c d t= è¿™è¡¨ç¤ºä»èŒƒç•´ c åˆ°èŒƒç•´ d çš„ä¸€ä¸ª Functor t

å¦‚æœæŠŠèŒƒç•´ c å’Œ d éƒ½é™åˆ¶åˆ° Hask èŒƒç•´

#+BEGIN_SRC haskell
  class Functor (->) (->) t where
    fmap :: (->) a b -> (->) (t a) (t b)
#+END_SRC

#+BEGIN_SRC scala
  trait Functor[=>[_, _], =>[_, _], T[_]] {
   def fmap[A, B](c: =>[A, B]): =>[T[A], T[B]]
  }
#+END_SRC
=->= åœ¨ Haskell ä¸­æ˜¯ä¸­ç¼€ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥å†™åœ¨ä¸­é—´çš„

è¿™æ ·å°±ä¼šå˜æˆæˆ‘ä»¬ç†Ÿæ‚‰çš„ Funtor çš„ Typeclass[fn:-1-5]

#+BEGIN_SRC haskell
  class Functor t where
    fmap :: (a -> b) -> (t a -> t b)
#+END_SRC

#+BEGIN_SRC scala
  trait Functor[T[_]] {
   def fmap[A, B](c: A => B): T[A] => T[B]
  }
#+END_SRC

è€Œ // å°±æ˜¯è¿™ç§è¿æ¥ç›¸åŒèŒƒç•´çš„ Functorï¼Œå› ä¸ºå®ƒä»èŒƒç•´ Hask åˆ°è¾¾åŒæ ·çš„èŒƒç•´ Hask
#+INDEX: endofunctor
#+INDEX: è‡ªå‡½å­

è¿™å›çœ‹ä»£ç å°±å¾ˆå®¹æ˜“å¯¹åº”ä¸Šå›¾å’Œæ¦‚å¿µäº†, è¿™é‡Œçš„è‡ªå‡½å­åªæ˜¯æ˜ å°„èŒƒç•´ ~->~ åˆ° ~->~, ç®­å¤´å‡½æ•°é‚£ä¸ªç®­å¤´, ç±»å‹å´å˜æˆäº† t a

è¿™é‡Œçš„ fmap å°±æ˜¯ T(~>)ï¼Œåœ¨ Hask èŒƒç•´ä¸Šï¼Œæ‰€ä»¥æ˜¯ T(->), è¿™ä¸ªç®­å¤´æ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿèƒ½è¡¨ç¤ºæˆ T(f) å¦‚æœ =f:: a -> b=

[fn:-1-5] è¿™é‡Œå¯ä»¥æŠŠ Functor çš„ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°æ¶ˆæ‰, å› ä¸ºå·²ç»çŸ¥é“æ˜¯åœ¨ Hask èŒƒç•´äº†

** /@@html:<ruby>Cat<rt> +çŒ«+</rt></ruby>@@/

é€’å½’çš„, å½“æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ª Category çœ‹æˆä¸€ä¸ª objectï¼Œfunctor çœ‹æˆç®­å¤´ï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆå¾—åˆ°äº†ä¸€ä¸ª Categoryï¼Œè¿™ç§ object æ˜¯ category çš„ category æˆ‘ä»¬å«å®ƒ -- /Cat/

å·²ç»çš„åŠæ³•ç”¨è¯­è¨€æè¿°è¿™ä¹ˆé«˜ç»´åº¦çš„äº‹æƒ…äº†ï¼Œçœ‹å›¾å§...

** è‡ªç„¶å˜æ¢ / Natural Transformations <<NT>>

Functor æ˜¯èŒƒç•´é—´çš„æ˜ å°„ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ª Cat èŒƒç•´ä¸­, æŠŠèŒƒç•´çœ‹æˆæ˜¯å¯¹è±¡, é‚£ä¹ˆ Functor åœ¨ Cat èŒƒç•´åˆæ˜¯ä¸ªç®­å¤´
#+INDEX: Natural Transformations
#+INDEX: è‡ªç„¶å˜æ¢

#+CAPTION: Functor Få’ŒGï¼Œä»¥åŠ F åˆ° G çš„è‡ªç„¶å˜åŒ– \eta
#+RESULTS: 
[[file:images/natrual-transformation.svg]]

è€Œ Functor é—´ä¹Ÿæœ‰æ˜ å°„ï¼Œå«åš +å–µçš„å˜æ¢+ /è‡ªç„¶å˜æ¢/

èŒƒç•´ c ä¸Šçš„å‡½å­ f åˆ° g çš„è‡ªç„¶å˜åŒ–å°±å¯ä»¥è¡¨ç¤ºæˆ
#+BEGIN_SRC haskell
  type Nat c f g = c (f a) (g a)
#+END_SRC

Scala æ²¡æœ‰ rank n type[fn:-1-6], åªèƒ½é  apply æ¥ meme äº†
#+BEGIN_SRC scala
  trait Nat[C[_, _], F[_], G[_]] {
    def apply[A]: C[F[A], G[A]]
  }
#+END_SRC

Hask èŒƒç•´ä¸Šçš„è‡ªç„¶å˜åŒ–å°±å˜æˆäº†

#+BEGIN_SRC haskell
  type NatHask f g = f a -> g a
#+END_SRC

#+BEGIN_SRC scala
  trait NatHask[F[_], G[_]] {
    def apply[A]: F[A] => G[A]
  }
#+END_SRC

æœ‰è¶£çš„æ˜¯, è¿˜å¯ä»¥ç»§ç»­å‡ç»´åº¦, æ¯”å¦‚

- ä¸œè¥¿æ˜¯å‡½å­
- ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

æ­å–œä½ åˆ°è¾¾ Functor èŒƒç•´.

å½“ç„¶, è¦æˆä¸ºèŒƒç•´ï¼Œè¿˜æœ‰ä¸¤ä¸ªå±æ€§:
- id ä¸º f a åˆ° f a çš„è‡ªç„¶å˜æ¢
- è‡ªç„¶å˜æ¢çš„ç»„åˆ

#+RESULTS: 
[[file:images/functor-category.svg]]

åˆ«ç€æ€¥, æˆ‘ä»¬æ¥æ¢³ç†ä¸€ä¸‹ï¼Œå¦‚æœå·²ç»ä¸çŸ¥é“å‡äº†å‡ ä¸ªç»´åº¦äº†ï¼Œæˆ‘ä»¬å‡è®¾ç±»å‹æ‰€åœ¨èŒƒç•´æ˜¯ç¬¬ä¸€ç»´åº¦
- ä¸€ç»´ï¼š Haskï¼Œ ä¸œè¥¿æ˜¯ç±»å‹ï¼Œç®­å¤´æ˜¯ ->
- äºŒç»´ï¼š Catï¼Œ ä¸œè¥¿æ˜¯ Haskï¼Œ ç®­å¤´æ˜¯ Functor
- ä¸‰ç»´ï¼š FunctorèŒƒç•´ï¼Œ ä¸œè¥¿æ˜¯Functorï¼Œ ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

æ„Ÿè§‰åˆ°è¾¾ä¸‰ç»´å·²ç»æ˜¯æé™äº†ï¼Œå°¼ç›è¿˜æœ‰å®Œæ²¡å®Œäº†ï¼Œæ¯å‡ä¸€ä¸ªç»´åº¦è¿˜è¦èµ·è¿™ä¹ˆå¤šè£…é€¼çš„åå­—ï¼Œå†å‡ç»´åº¦è€å­å°±ç”»ä¸å‡ºæ¥äº†

æ‰€ä»¥è¿™æ—¶å€™, éœ€è¦å¼•å…¥ String Diagramã€‚

[fn:-1-6] åˆ«æ€¥, åé¢é©¬ä¸Šè®²åˆ°
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@
#+DESCRIPTION: å·äºŒ é£Ÿç”¨çŒ«å‘¢
#+INDEX: Catergory Theory!èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ å·äºŒ

- [[file:./part1.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šèŒƒç•´è®º]]
- *[[file:./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]* ğŸ‘ˆ
- [[file:./part3.org][ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢]]

** String Diagram

String Diagram çš„æ¦‚å¿µå¾ˆç®€å•ï¼Œå°±æ˜¯ç‚¹å˜çº¿çº¿å˜ç‚¹ã€‚

è¿˜è®°å¾—å½“æœ‰äº†è‡ªç„¶å˜æ¢ä¹‹åï¼Œä¸‰ä¸ªç»´åº¦å·²ç»æ²¡æ³•è¡¨ç¤ºäº†ï¼Œé‚£åŸæ¥çš„ç‚¹å’Œçº¿éƒ½å‡ä¸€ç»´åº¦ï¼Œå˜æˆçº¿å’Œé¢ï¼Œè¿™æ ·ï¼Œå°±è…¾å‡ºä¸€ä¸ªç‚¹æ¥è¡¨ç¤ºè‡ªç„¶å˜æ¢äº†ã€‚

#+CAPTION: String Diagramï¼šè‡ªç„¶å˜æ¢æ˜¯ç‚¹ï¼ŒFunctoræ˜¯çº¿ï¼ŒèŒƒç•´æ˜¯é¢
[[file:images/p1-string-diagram.png]]

composeçš„æ–¹å‘æ˜¯ä»å³å¾€å·¦ï¼Œä»ä¸‹åˆ°ä¸Šã€‚

** /Adjunction Functor/ ä¼´éšå‡½å­
#+INDEX: Adjunction Functor
èŒƒç•´Cå’ŒDç›´æ¥æœ‰æ¥æœ‰å›çš„å‡½å­ï¼Œä¸ºä»€ä¹ˆè¦ä»‹ç»è¿™ä¸ªï¼Œå› ä¸ºå®ƒç›´æ¥å¯ä»¥æ¨å‡º Monad

è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä»€ä¹ˆå«æœ‰æ¥å›ã€‚

[[file:images/p1-adjunction-functor.png]]

å…¶ä¸­ï¼š

- ä¸€ä¸ªèŒƒç•´ C å¯ä»¥é€šè¿‡å‡½å­ G åˆ° Dï¼Œå†é€šè¿‡å‡½å­ F å›åˆ° Cï¼Œé‚£ä¹ˆ F å’Œ G å°±æ˜¯ä¼´éšå‡½å­ã€‚
- \eta æ˜¯ GF åˆ° 1_D çš„è‡ªç„¶å˜æ¢
- \epsilon æ˜¯ 1_C åˆ° FG çš„è‡ªç„¶å˜æ¢

åŒæ—¶æ ¹æ®åŒæ„çš„å®šä¹‰ï¼ŒG ä¸ F æ˜¯ /åŒæ„/ çš„ã€‚
#+INDEX: isomorphic
#+INDEX: åŒæ„

åŒæ„æŒ‡çš„æ˜¯è‹¥æ˜¯æœ‰
#+BEGIN_SRC haskell
  f :: a -> b
  f':: b -> a
#+END_SRC

é‚£ä¹ˆ f ä¸ f' åŒæ„ï¼Œå› ä¸º f . f' = id = f' . f

ä¼´éšå‡½å­çš„ FG ç»„åˆæ˜¯ C èŒƒç•´çš„ id å‡½å­ F . G = 1_c

#+CAPTION: ä¼´éšå‡½å­çš„ä¸¤ä¸ªFunctorç»„åˆ, å·¦ä¾§ä¸º F \eta, å³ä¾§ä¸º \epsilon F
[[file:images/p1-ajunction-functor-compose.png]]

Functor ä¸ä»…æ¨ªç€å¯ä»¥ç»„åˆï¼Œç«–ç€(è‡ªç„¶å˜æ¢ç»´åº¦)ä¹Ÿæ˜¯å¯ä»¥ç»„åˆçš„ï¼Œå› ä¸ºè‡ªç„¶å˜æ¢æ˜¯ Functor èŒƒç•´çš„ç®­å¤´ã€‚

#+CAPTION: F \eta . \epsilon F  = F
[[file:images/p1-ajunction-functor-compose-nat.png]]

å½“åˆ°ç»„åˆ F \eta . \epsilon F å¾—åˆ°ä¸€ä¸ªå¼¯å¼¯æ›²æ›²çš„ F æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æ‹½ç€Fçš„ä¸¤æ®µä¸€æ‹‰ï¼Œå°±å¾—åˆ°äº†ç›´çš„ Fã€‚

String Diagram ç¥å¥‡çš„åœ°æ–¹æ˜¯æ‰€æœ‰çº¿éƒ½å¯ä»¥æ‹‰ä¸Šä¸‹ä¸¤ç«¯ï¼Œè¿™ä¸ªæŠ€å·§éå¸¸æœ‰ç”¨ï¼Œåœ¨ä¹‹åçš„å•å­æ¨å¯¼è¿˜éœ€è¦ç”¨åˆ°ã€‚

** ä»ä¼´éšå‡½å­åˆ° @@html:<ruby>å•å­<rt> Monad</rt></ruby>@@
æœ‰äº†ä¼´éšå‡½å­ï¼Œå¾ˆå®¹æ˜“æ¨å‡ºå•å­ï¼Œè®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯å•å­

- é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ª endofunctor T
- æœ‰ä¸€ä¸ªä» i_c åˆ° T çš„è‡ªç„¶å˜åŒ– \eta (eta)
- æœ‰ä¸€ä¸ªä» T^2 åˆ° T çš„è‡ªç„¶å˜åŒ– \mu (mu)

[[file:images/p1-monad-properties.png]]

#+BEGIN_SRC haskell
  class Endofunctor c t => Monad c t where
    eta :: c a (t a)
    mu  :: c (t (t a)) (t a)
#+END_SRC

#+BEGIN_SRC scala
  trait Monad[C[_, _], T[_]]] extends Endofunctor[C, T] {
    def eta[A]: C[A, T[A]]
    def mu[A]: C[T[T[A]], T[A]]
  }
#+END_SRC
åŒæ ·ï¼ŒæŠŠ c = Hask æ›¿æ¢è¿›å»ï¼Œå°±å¾—åˆ°æ›´ç±»ä¼¼æˆ‘ä»¬ Haskell ä¸­ Monad çš„å®šä¹‰
#+BEGIN_SRC haskell
  class Endofunctor m => Monad m where
    eta :: a -> (m a)
    mu :: m m a -> m a
#+END_SRC

#+BEGIN_SRC scala
  trait Monad[M[_]] extends Endofunctor[M] {
    def eta[A]: A => M[A]
    def mu[A]: M[M[A]] => M[A]
  }
#+END_SRC
è¦æ¨å‡ºå•å­çš„ \eta å˜æ¢ï¼Œåªéœ€è¦è®© FG = T
#+CAPTION: ä¼´éšå‡½å­çš„ \epsilon å°±æ˜¯å•å­çš„ \eta
[[file:images/p1-ajunction-functor-to-monad-eta.png]]

åŒæ ·çš„ï¼Œå½“ FG = T, F \eta G å°±å¯ä»¥å˜æˆ \mu
#+CAPTION: ä¼´éšå‡½å­çš„ F \eta G æ˜¯å‡½å­çš„ \mu
[[file:images/p1-ajunction-functor-to-monad-mu.png]]

*** ä¸‰è§’ç­‰å¼

ä¸‰è§’ç­‰å¼æ˜¯æŒ‡ \mu . T \eta = T = \mu . \eta T

è¦æ¨å‡ºä¸‰è§’ç­‰å¼åªéœ€è¦ç»„åˆ F \eta G å’Œ \epsilon F G
#+CAPTION: F \eta G  . \epsilon F G = F G
[[file:images/p1-adjunction-functor-triangle.png]]
#+CAPTION: F \eta G  . \epsilon F G= F G å¯¹åº”åˆ°Monadå°±æ˜¯ \mu . \eta T = T
[[file:images/p1-monad-triangle.png]]

æ¢åˆ°ä»£ç ä¸Šæ¥è¯´
#+BEGIN_SRC haskell
  (mu . eta) m = m
#+END_SRC

åŒæ ·çš„ï¼Œå·¦å³ç¿»è½¬ä¹Ÿæˆç«‹

#+CAPTION: F \eta G . F G \epsilon = F G
[[file:images/p1-adjunction-functor-triangle-reverse.png]]
#+CAPTION: F \eta G . F G \epsilon = F G å¯¹åº”åˆ° Monadæ˜¯ \mu . T \eta = T
[[file:images/p1-monad-triangle-reverse.png]]
T \eta å°±æ˜¯ fmap eta
#+BEGIN_SRC haskell
  (mu . fmap eta) m = m
#+END_SRC

å¦‚æœæŠŠ ~mu . fmap~ å†™æˆ ~>>=~ , å°±æœ‰äº†

#+BEGIN_SRC haskell
  m >>= eta = m
#+END_SRC

*** ç»“åˆå¾‹

å•å­å¦ä¸€å¤§å®šå¾‹æ˜¯ç»“åˆå¾‹ï¼Œè®©æˆ‘ä»¬ä»ä¼´éšå‡½å­æ¨èµ·

å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰å‡½å­ F \eta G å’Œ å‡½å­ F \eta G F G, compose èµ·æ¥ä¼šå˜æˆ  F \eta G . F \eta G F G
[[file:images/p1-ajunction-functor-monad-laws-1.png]]

ç”¨ F G = T ï¼Œ F \eta G = \mu ä»£æ¢é‚£ä¹ˆå°±å¾—åˆ°äº†å•å­çš„ \mu . \mu T
[[file:images/p1-ajunction-functor-monad-laws-2.png]]

å½“ç»„åˆ F \eta G å’Œ F G F \mu G åï¼Œä¼šå¾—åˆ°ä¸€ä¸ªé•œåƒçš„å›¾
[[file:images/p1-ajunction-functor-monad-laws-3.png]]

å¯¹åº”åˆ°å•å­çš„ \mu . T \mu

ç»“åˆå¾‹æ˜¯è¯´ \mu . \mu T = \mu . T \mu , å³å›¾å·¦å³ç¿»è½¬ç»“æœæ˜¯ç›¸ç­‰çš„ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿçœ‹å•å­çš„String Diagram ä¸å¤ªå¥½çœ‹å‡ºæ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ä¼´éšå‡½å­

å¦‚æœæŠŠå·¦å›¾çš„å·¦è¾¹çš„ \mu å¾€ä¸ŠæŒªä¸€ç‚¹ï¼Œå³è¾¹çš„ \mu å¾€ä¸‹æŒªä¸€ç‚¹ï¼Œæ˜¯ä¸æ˜¯è·Ÿå³å›¾å°±ä¸€æ ·äº†
[[file:images/p1-ajunction-functor-monad-laws-4.png]]

ç»“åˆå¾‹åæ˜ åˆ°ä»£ç ä¸­å°±æ˜¯
#+BEGIN_SRC haskell
  mu . fmap mu = mu . mu
#+END_SRC

ä»£ç å¾ˆéš¾çœ‹å‡ºç»“åˆåœ¨å“ªé‡Œï¼Œå› ä¸ºæ­£å¸¸çš„ç»“åˆå¾‹åº”è¯¥æ˜¯è¿™æ ·çš„ (1+2)+3 = 1+(2+3)ï¼Œä½†æ˜¯ä¸æƒ³åŠ æ³•çš„ç»´åº¦ä¸ä¸€æ ·ï¼Œè¿™é‡Œè¯´çš„æ˜¯è‡ªç„¶å˜æ¢ç»´åº¦çš„ç»“åˆï¼Œå¯ä»¥é€šè¿‡String Diagram å¾ˆæ¸…æ¥šçš„çœ‹è§ç»“åˆçš„è¿‡ç¨‹ï¼Œå³ \mu å·¦è¾¹çš„ä¸¤ä¸ªTå’Œå…ˆ \mu å³è¾¹ä¸¤ä¸ª T æ˜¯ç›¸ç­‰çš„ã€‚

** Yoneda lemma / +ç±³ç”°å…±+ ç±³ç”°å¼•ç†
#+INDEX: ç±³ç”°å¼•ç†
#+INDEX: Yoneda Lemma

ç±³ç”°å¼•ç†æ˜¯è¯´æ‰€æœ‰Functor =f a= ä¸€å®šå­˜åœ¨ embed å’Œ unembedï¼Œä½¿å¾— =f a= å’Œ =(a -> b) -> F b= isomorphic åŒæ„

haskellè¿˜è¦å…ˆæ‰“å¼€ RankNTypes çš„ feature

#+BEGIN_SRC haskell
  {-# LANGUAGE RankNTypes #-}
  
  embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
  embed x f = fmap f x
  
  unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
  unembed f = f id
#+END_SRC

Scala è¯­è¨€æ²¡æœ‰ Rank N Typeæ”¯æŒ, ä½†æ˜¯ [[NT][]] æåˆ°è¿‡å¯ä»¥ç”¨ =apply= æ¥æ¨¡æ‹Ÿ. å…¶å®å¯ä»¥ä½¿ç”¨ Cats çš„ [[https://typelevel.org/cats/datatypes/functionk.html][FunctionK(~>)]] æ›´æ–¹ä¾¿:
#+BEGIN_SRC scala
  def embed[F[_], A](fa: F[A])(implicit f: Functor[F]): (A => ?) ~> F =
    Lambda[(A => ?) ~> F](f.fmap(_)(fa))
  def unembed[F[_]](fnk: (A => ?) ~> F): F[A] =
    fnk(identity)
#+END_SRC

embed å¯ä»¥æŠŠ functor =f a= å˜æˆ =(a -> b) -> f b=

unembed æ˜¯åè¿‡æ¥ï¼Œ =(a -> b) -> f b= å˜æˆ =f a=

ä¸Šä¸ªå›¾å°±æ˜ç™½äº†
#+CAPTION: ä¹Ÿå°±æ˜¯è¯´ï¼Œå›¾ä¸­æ— è®ºçŸ¥é“a->b å†åŠ ä¸Šä»»æ„ä¸€ä¸ª F xï¼Œéƒ½èƒ½æ¨å‡ºå¦å¤–ä¸€ä¸ª F
#+RESULTS: 
[[file:images/yoneda-lemma.svg]]

*** Rank N Type
#+INDEX: Arbitrary-rank polymorphism
#+INDEX: Rank N Type

è¯´å¥½çš„è¦è§£é‡Š Rank N Type

Haskell ä¸­å¯ä»¥ä¸ç”¨å£°æ˜ç±»å‹, ä½†æ˜¯å…¶å®æ˜¯çœç•¥æ‰ universally quantified =forall=, å¦‚æœæŠŠ forall å…¨éƒ¨åŠ å›æ¥,
å°±æ˜äº†å¾ˆå¤š:

- Monomorphic Rank 0 / 0çº§å•æ€[fn:-1-7]: t
- Polymorphic Rank 1 / 1çº§ +å˜æ€+ å¤šæ€: forall a b. a -> b
- Polymorphic Rank 2 / 2çº§å¤šæ€: forall c. (forall a b. a -> b) -> c
- Polymorphic Rank 3 / 3çº§å¤šæ€: forall d . (forall c . (forall a b . a -> b) -> c) -> d

çœ‹ rank å‡ åªè¦æ•°å·¦è¾¹ forall çš„ä¸ªæ•°å°±å¥½äº†.

ä¸€çº§å¤šæ€åªé”å®šä¸€æ¬¡ç±»å‹ a å’Œ b

äºŒçº§å¤šæ€å¯ä»¥åˆ†ä¸¤æ¬¡ç¡®å®šç±»å‹, ç¬¬ä¸€æ¬¡ç¡®å®š c, ç¬¬äºŒæ¬¡ç¡®å®š a b

ä¸‰çº§å¤šå°åˆ†ä¸‰æ¬¡: ç¬¬ä¸€æ¬¡ d, ç¬¬äºŒæ¬¡ c, ç¬¬ä¸‰æ¬¡ a b

æ¯”å¦‚:

#+BEGIN_SRC haskell
  rank2 :: forall b c . b -> c -> (forall a. a -> a) -> (b, c)
  rank2 b c f = (f b, f c)
  
  rank2 True 'a' id
  -- (True, 'a')
#+END_SRC

#+BEGIN_SRC scala
  def rank2[B, C](b: B, c: C)(fnk: Id ~> Id): (B, C) =
    (fnk(b), fnk(c))
  rank2(true, 'a')(FunctionK.id[Id])
#+END_SRC

- f åœ¨ =f True= æ—¶ç±»å‹ =Boolean -> Boolean= æ˜¯ç¬¦åˆ =forall a. a->a= çš„
- ä¸æ­¤åŒæ—¶ =f 'a'= æ—¶ç±»å‹ç¡®å®æ˜¯ =Char -> Char= ä½†ä¹Ÿç¬¦åˆ =forall a. a->a=

å¦‚æœæ˜¯ rank1 ç±»å‹ç³»ç»Ÿå°±æ‡µé€¼äº†:
#+BEGIN_SRC haskell
  rank1 :: forall a b c . b -> c -> (a -> a) -> (b, c)
  rank1 b c f = (f b, f c)
#+END_SRC

#+BEGIN_SRC scala
  def rank1[A, B, C](b: B, c: C)(fn: A => A): (B, C) =
    (fn(b), fn(c))
#+END_SRC
f åœ¨ =f True= æ˜¯ç¡®å®š a æ˜¯ Booleanï¼Œåœ¨rank1å¤šæ€æ˜¯æ—¶å°±ç¡®å®šäº† =a->a= çš„ç±»å‹ä¸€å®šæ˜¯ =Boolean -> Boolean=

æ‰€ä»¥åˆ° =f 'a'= ç±»å‹å°±æŒ‚äº†ã€‚

[fn:-1-7] ä¹Ÿå°±ä¸æ˜¯ä¸å˜æ€

** /Kleisli Catergory/
#+INDEX: Kleisi Catergory

#+CAPTION: æ³¨æ„è§‚å¯Ÿå¤§ç«ç®­ <=< çš„è½¨è¿¹ï¼ˆä¸çŸ¥é“dotä¸ºä»€ä¹ˆä¼šæŠŠè¿™æ ¹çº¿æè¿™ä¹ˆåˆå¼¯åˆéªšçš„ï¼‰ å’Œ >>= ã€‚æ‰€ä»¥ Kleisli å…¶å®å°±æ˜¯æ–œç€èµ°çš„ä¸€ä¸ªèŒƒç•´ï¼Œä½†æ˜¯ >>= æŠŠå®ƒç¡¬ç”Ÿç”Ÿæ° +å¼¯+ ç›´äº†ã€‚
#+RESULTS: 
[[file:images/kleisli.svg]]

 çš„èŒƒç•´å«åš , è‡ªç„¶å˜æ¢æ˜¯å…¶ç®­å¤´ã€‚é‚£ä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªèŒƒç•´å—?[fn:-1-8]

æ˜¯çš„, è¿™ä¸ªèŒƒç•´åå­—å«åš +å•å­èŒƒç•´+[fn:-1-9] [fn:-1-10]ï¼Œé‚£ä¹ˆ Kleisli çš„ç®­å¤´æ˜¯ä»€ä¹ˆï¼Ÿ
æˆ‘ä»¬çœ‹å®šä¹‰ï¼ŒKleisli Catergory

1. ç®­å¤´æ˜¯ Kleisli ç®­å¤´ =a -> T b=
2. ä¸œè¥¿å°±æ˜¯cèŒƒç•´ä¸­çš„ä¸œè¥¿. å› ä¸º a å’Œ b éƒ½æ˜¯ c èŒƒç•´ä¸Šçš„ï¼Œ ç”±äºTæ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ T b ä¹Ÿæ˜¯ c èŒƒç•´çš„

çœ‹åˆ°å›¾ä¸Šçš„  å’Œ \mu äº†æ²¡ï¼Ÿ[fn:-1-11]

#+BEGIN_SRC haskell
  f :: b -> T c
  fmap f :: T b -> T T c
  mu :: T T c -> T c
#+END_SRC

#+BEGIN_SRC scala
  def f[T[_], B, C](b: B): T[C]
  def fmap[T[_], B, C](f: B => C)(tb: T[B]): T[T[C]]
  def mu[T[_], C](ttc: T[T[C]]): T[C]
#+END_SRC

ç´«è‰²çš„ç®­å¤´ =T f=[fn:-1-12] å’Œç´«è‰²çš„è™šçº¿ç®­å¤´ \mu è¿èµ·æ¥å°±æ˜¯ =T f'=, é‚£ä¹ˆæœ€å‡ºåçš„ ~>>=~ ç¬¦å·ç»ˆäºå‡ºæ¥äº†:
#+BEGIN_SRC haskell
  tb >>= f = (mu . fmap f) tb
#+END_SRC

#+BEGIN_SRC scala
  def flatMap[T[_], B, C](f: B => T[C])(tb: T[B]): T[C] = (mu compose fmap(f))(tb)
#+END_SRC

ä¸‹é¢è¿™ä¸ªå¤§ç«ç®­ ~<=<~ å¯ä»¥æŠŠè“è‰²ç®­å¤´ç»„åˆèµ·æ¥.
#+BEGIN_SRC haskell
  (f <=< g) = mu . T f . g = mu . fmap f . g
#+END_SRC

#+BEGIN_SRC scala
  def <=<[T[_], A, B, C](f: B => T[C])(g: A => T[B]): A => T[C] =
    mu compose fmap(f) compose g
#+END_SRC

å› æ­¤å¤§ç«ç®­å°±æ˜¯ Kleisli èŒƒç•´çš„ =compose=

#+BEGIN_SRC haskell
  (<=<) :: Monad T => (b -> T c) -> (a -> T b) -> (a -> T c)
#+END_SRC

[fn:-1-8] å½“ç„¶, å•å­æ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥æ˜¯è‡ªå‡½å­èŒƒç•´

[fn:-1-9] æ€ä¹ˆè¯´ä¹Ÿæ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„æ ¸å¿ƒ,æ€ä¹ˆå¯ä»¥å«çš„è¿™ä¹ˆlowè¿™ä¹ˆç›´æ¥

[fn:-1-10] è¿™ä¸ªæ˜¯æˆ‘çç¿»è¯‘çš„, ä½†æ˜¯è¯»å‡ºæ¥å°±æ˜¯è¿™ä¹ˆä¸ªæ„æ€, çœŸçš„, ä¸éª—ä½ , ç…§è¿™ä¹ˆè¯»ç»å¯¹è£…çš„ä¸€æ‰‹å¥½é€¼, ä¸ä¼šè¢«å˜²ç¬‘çš„

[fn:-1-11] (æ•²é»‘æ¿) å°±æ˜¯ç´«è‰²é‚£æ ¹å˜›!

[fn:-1-12] å³ =fmap f=

** Summary
ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›çš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad

- ğŸ‘‰ [[file:./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼š]]
- [[file:./part3.org][ç¬¬ä¸‰éƒ¨åˆ†ï¼š]]

å½“ç„¶æˆ‘è¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœæœ‰å¾ˆå¤šäºº Gumroad ä¸Šçš„  ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œï¼Œå°±å½“æ˜¯è‡ªè¨€è‡ªè¯­å§ï¼Œæ€ä¹ˆçªç„¶è§‰å¾—è‡ªå·±å¥½åˆ†è£‚ã€‚

* ç¬¬äºŒéƒ¨åˆ†ï¼š@@html:<ruby>é£Ÿç”¨çŒ«å‘¢<rt> Practical Monads</rt></ruby>@@
ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›åŠç‚¸å¤©çš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿ

ç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»ç”±è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

æœ€åä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚

** Identity
è¿™å¯èƒ½æ˜¯æœ€ç®€å•çš„ monad äº†ã€‚ä¸åŒ…å«ä»»ä½•è®¡ç®—
#+BEGIN_SRC haskell
  newtype Identity a = Identity { runIdentity :: a }
#+END_SRC

è¿™é‡Œä½¿ç”¨ =newtype= è€Œä¸æ˜¯ =data= æ˜¯å› ä¸º =Identity= ä¸ =runIdentity= æ˜¯ isomorphic ï¼ˆåŒæ„ï¼Œå¿˜äº†çš„è¯å›å»ç¿»ç¬¬ä¸€éƒ¨åˆ†ï¼‰

#+BEGIN_SRC haskell
  Identity :: a -> Identity a
  runIdentity :: Identity a -> a
#+END_SRC

æ‰€ä»¥ ~runIdentity . Identity = id~ ï¼Œæ‰€ä»¥ä»–ä»¬æ˜¯åŒæ„çš„ã€‚

å·¦è¾¹çš„ =Identity= æ˜¯ç±»å‹æ„é€ å™¨, æ¥æ”¶ç±»å‹ =a= è¿”å› =Identity a= ç±»å‹

å¦‚æœ a æ˜¯ Intï¼Œé‚£ä¹ˆå°±å¾—åˆ°ä¸€ä¸ª =Identity Int= ç±»å‹ã€‚

å³è¾¹çš„ =Identity= æ˜¯æ•°æ®æ„é€ å™¨ï¼Œä¹Ÿå°±æ˜¯æ„é€ å€¼ï¼Œæ¯”å¦‚ =Identity 1= ä¼šæ„é€ å‡ºä¸€ä¸ªå€¼ï¼Œå…¶ç±»å‹ä¸º =Identity Int=

å¤§æ‹¬å·æ¯”è¾ƒè¯¡å¼‚ï¼Œå¯ä»¥æƒ³è±¡æˆç»™ =a= ä¸€ä¸ª keyï¼ŒåŒè¿‡è¿™ä¸ª key å¯ä»¥æŠŠ a å–å‡ºæ¥ï¼Œæ¯”å¦‚
#+BEGIN_SRC haskell
  runIdentity (Identity 1)
#+END_SRC

ä¼šè¿”å› 1

Identity å¯ä»¥å®ç° Functor å’Œ Monadï¼Œå°±å¾—åˆ° Identity functor å’Œ Identity monad
#+BEGIN_SRC haskell
  instance Functor Identity where
    fmap f (Identity a) = Identity (f a)
  
  instance Monad Identity where
    return a = Identity a
    Identity a >>= f = f a
#+END_SRC

å¯ä»¥çœ‹åˆ° Identity å³æ˜¯æ„é€ å™¨ï¼Œä¹Ÿæ˜¯è§£æ„å™¨ï¼Œåœ¨æ¨¡å¼åŒ¹é…æ˜¯å¯ä»¥ destructure å€¼ã€‚ä¾‹å¦‚ä¸Šé¢Functor å®ç°ä¸­çš„ =fmap f (Identity a)= , å‡å¦‚fmapçš„æ˜¯ =Identity 1=, é‚£ä¹ˆè¿™ä¸ªæ¨¡å¼åŒ¹é…åˆ° =(Identity a)= æ—¶ä¼šæŠŠ =1= æ”¾åˆ° =a= çš„ä½ç½®ã€‚

Identity çœ‹èµ·æ¥ä»€ä¹ˆä¹Ÿæ²¡æœ‰å¹²ï¼Œå°±è·Ÿ identity å‡½æ•°ä¸€æ ·ï¼Œä½†æ˜¯åœ¨åé¢è®²åˆ° State monadæ—¶ä½ ä¼šå‘ç°ä»–çš„ä»·å€¼ã€‚

** Maybe
è¿™æ˜¯ä¸€ä¸ªè¶…çº§ç®€å•çš„ Monadï¼Œé¦–å…ˆï¼Œéœ€è¦å®šä¹‰è¿™ä¸ªä¸€ä¸ª 
#+BEGIN_SRC haskell
  data Maybe a = Just a | Nothing
#+END_SRC
Haskellä¸­å®šä¹‰ä¸€ä¸ªADTååˆ†ç®€å•ï¼Œä¸åƒScalaé‚£ä¹ˆå•°å—¦ã€‚å·¦è¾¹æ˜¯ç±»å‹æ„é€ å™¨ï¼Œå³è¾¹æœ‰æ•°æ®æ„é€ å™¨ï¼Œä½ ä¼šå‘ç°æœ‰ä¸€æ ¹ç«–çº¿ =|= ï¼Œ å®ƒåˆ†éš”ç€ä¸¤ä¸ªæ„é€ å™¨
- Just
- Nothing
å…¶ä¸­ a ï¼ˆä¸€å®šè¦å°å†™ï¼‰å¯ä»¥æ˜¯ä»»æ„ç±»å‹

æ‰€ä»¥ =Just 1= ä¼šå¾—åˆ°ä¸€ä¸ª =Num a => Mabye a= ç±»å‹ï¼ˆæ„æ€å°±æ˜¯ =Maybe a= ä½†æ˜¯ =a= çš„ç±»å‹çº¦æŸä¸º =Num= ï¼‰ï¼Œ =Nothing= ä¹Ÿä¼šå¾—åˆ°ä¸€ä¸ª =Maybe a= åªä¸è¿‡ =a= æ²¡æœ‰ç±»å‹çº¦æŸã€‚

æ€»ä¹‹æˆ‘ä»¬æœ‰äº†æ„é€ å™¨å¯ä»¥æ„é€ å‡º Maybe ç±»å‹ï¼Œè€Œè¿™ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ï¼Œå°±è¦å–å†³å®ƒå®ç°äº†å“ªäº› class çš„ instance äº†ã€‚æ¯”å¦‚å®ƒå¯ä»¥æ˜¯ä¸€ä¸ª Functor
#+BEGIN_SRC haskell
  instance Functor Maybe where
    fmap f (Just a) = Just (f a)
#+END_SRC

#+CAPTION: fmap :: (a -> b) -> f a -> f b
[[file:images/p2-maybe-functor.png]]

ç„¶åï¼Œè¿˜å®ç° Monad
#+BEGIN_SRC haskell
  instance Monad Maybe where
    return a = Just a
    (Just a) >>= f = f a
    Nothing >>= f = Nothing
#+END_SRC

#+CAPTION: è¿˜è®°å¾—ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„ Kleisli èŒƒç•´å—ï¼Ÿ
[[file:images/p2-maybe-kleisli.png]]

Maybe æœ‰ç”¨åœ¨äºèƒ½åˆé€‚çš„å¤„ç† // çš„è¿”å›å€¼ã€‚åå‡½æ•°ç›¸å¯¹äºï¼Œæ˜¯æŒ‡åªèƒ½å¯¹éƒ¨åˆ†è¾“å…¥è¿”å›è¾“å‡ºçš„å‡½æ•°ã€‚

æ¯”å¦‚ä¸€ä¸ªå–æ•°ç»„æŸä¸€ä½ä¸Šçš„å€¼çš„å‡½æ•°ï¼Œå°±æ˜¯åå‡½æ•°ï¼Œå› ä¸ºå‡è®¾ä½ æƒ³å–ç¬¬4ä½çš„å€¼ï¼Œä½†ä¸æ˜¯æ‰€æœ‰æ•°ç»„é•¿åº¦éƒ½å¤§äº4ï¼Œå°±ä¼šæœ‰è·å–ä¸äº†çš„å°´å°¬æƒ…å†µã€‚
#+BEGIN_SRC haskell
  [1,2,3] !! 4
#+END_SRC

å¦‚æœä½¿ç”¨ Maybe æŠŠåå‡½æ•°å¤„ç†ä¸äº†çš„è¾“å…¥éƒ½è¿”å›æˆ Nothingï¼Œè¿™æ ·ç»“æœä¾ç„¶ä¿æŒ Maybe ç±»å‹ï¼Œä¸å½±å“åé¢çš„è®¡ç®—ã€‚

** Either

Either çš„å®šä¹‰ä¹Ÿå¾ˆç®€å•
#+BEGIN_SRC haskell
  data Either a b = Left a | Right b
#+END_SRC

*** Product & Coproduct
çœ‹è¿‡ç¬¬ä¸€éƒ¨åˆ†åº”è¯¥è¿˜èƒ½è®°å¾—æœ‰ä¸€ä¸ªä¸œè¥¿å« Duelï¼Œæ‰€ä»¥è§åˆ°å¦‚æœèŒƒç•´ä¸Šæœ‰ Coproduct é‚£ä¹ˆè‚¯å®šåœ¨duelèŒƒç•´ä¸Šä¼šæœ‰åŒæ ·çš„ä¸œè¥¿å« Productã€‚

é‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯ Coproduct

#+CAPTION: Coproduct
[[file:images/p2-coproduct.png]]

åƒè¿™æ ·ï¼Œèƒ½é€šè¿‡ä¸¤ä¸ªç®­å¤´åˆ°è¾¾åŒä¸€ä¸ªä¸œè¥¿ï¼Œå°±æ˜¯ Coproductã€‚è¿™é‡Œç®­å¤´ =Left= èƒ½è®© =a= åˆ° =Either a b= ï¼Œ ç®­å¤´ =Right= ä¹Ÿèƒ½è®© =b= åˆ°è¾¾ =Either a b=

æœ‰æ„æ€çš„æ˜¯è¿˜è‚¯å®šå­˜åœ¨ä¸€ä¸ª Coproduct å’Œ ç®­å¤´ï¼Œä½¿å¾—ä¸‹å›¾æˆç«‹
[[file:images/p2-coproduct-law.png]]

ç®­å¤´åè¿‡æ¥ï¼Œå°±æ˜¯ Product, æ¯”å¦‚ Tuple

#+CAPTION: Product
[[file:images/p2-product.png]]

Tuple çš„ =fst= ç®­å¤´èƒ½è®© =(a, b)= åˆ°è¾¾ =a= å¯¹è±¡ï¼Œè€Œç®­å¤´ =snd= èƒ½è®©å…¶åˆ°è¾¾ =b= å¯¹è±¡ã€‚

*** Either Monad
ç¡®åˆ‡çš„è¯´ï¼ŒEither ä¸æ˜¯ monadï¼Œ =Either a= æ‰æ˜¯ã€‚è¿˜è®°å¾— monad çš„ class å®šä¹‰å—ï¼Ÿ
#+BEGIN_SRC haskell
  class Endofunctor m => Monad m where
    eta :: a -> (m a)
    mu :: m m a -> m a
#+END_SRC
æ‰€ä»¥ m å¿…é¡»æ˜¯ä¸ª Endofunctorï¼Œä¹Ÿå°±æ˜¯è¦æ»¡è¶³Functor
#+BEGIN_SRC haskell
  class Functor t where
    fmap :: (a -> b) -> (t a -> t b)
#+END_SRC
t a çš„ kind æ˜¯ *ï¼Œæ‰€ä»¥ t å¿…é¡»æ˜¯ kind * -> *
ä¹Ÿå°±æ˜¯è¯´ï¼Œm å¿…é¡»æ˜¯æ¥æ”¶ä¸€ä¸ªç±»å‹å‚æ•°çš„ç±»å‹æ„é€ å™¨

è€Œ Either çš„ kind æ˜¯ * -> * -> *, Either a æ‰æ˜¯ * -> *

æ‰€ä»¥åªèƒ½å®šä¹‰ Either a çš„ Monad
#+BEGIN_SRC haskell
  instance Monad (Either a) where
    Left  l >>= _ = Left l
    Right r >>= k = k r
#+END_SRC

å¾ˆæ˜æ˜¾çš„ï¼Œ>>= ä»»ä½•å‡½æ•°åˆ° éƒ½ä¸ä¼šæ”¹å˜ï¼Œåªæœ‰ >>= å³è¾¹æ‰èƒ½äº§ç”Ÿæ–°çš„è®¡ç®—ã€‚


** Reader
Reader çš„ä½œç”¨æ˜¯ç»™ä¸€ä¸ªè®¡ç®—å–‚æ•°æ®ã€‚

åœ¨æè¿°è®¡ç®—çš„æ—¶å€™ï¼Œå¹¶ä¸éœ€è¦å…³å¿ƒè¾“å…¥æ—¶ä»€ä¹ˆï¼Œåªéœ€è¦ asks å°±å¯ä»¥æ‹¿åˆ°è¾“å…¥å€¼

è€ŒçœŸæ­£çš„è¾“å…¥ï¼Œä¼šåœ¨è¿è¡Œè®¡ç®—æ—¶ç»™äºˆã€‚

è·Ÿ Identity ä¸€æ ·ï¼Œæˆ‘ä»¬ç”¨ newtype æ¥å®šä¹‰ä¸€ä¸ªåŒæ„çš„ Reader ç±»å‹
#+BEGIN_SRC haskell
  newtype Reader e a = Reader { runReader :: (e -> a) }
#+END_SRC

å…¶ä¸­
- e æ˜¯è¾“å…¥
- a æ˜¯ç»“æœ
- æ„é€  Reader ç±»å‹éœ€è¦ç¡®å®š è¾“å…¥çš„ç±»å‹ e ä¸è¾“å‡ºçš„ç±»å‹ a
- =runReader= çš„ç±»å‹æ˜¯ =runReader:: (Reader e a) -> (e -> a)=

ä¹Ÿå°±æ˜¯è¯´åœ¨æè¿°å®Œä¸€ä¸ª Reader çš„è®¡ç®—åï¼Œä½¿ç”¨ runReader å¯ä»¥å¾—åˆ°ä¸€ä¸ª e -> a çš„å‡½æ•°ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå°±å¯ä»¥æ¥æ”¶è¾“å…¥ï¼Œé€šè¿‡æ„é€ å¥½çš„è®¡ç®—ï¼Œç®—å‡ºç»“æœ a è¿”å›ã€‚

é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬æ¥å®ç° Reader çš„ monad instanceï¼Œå°±å¯ä»¥æè¿°ä¸€ä¸ªå¯ä»¥ ask çš„è®¡ç®—äº†ã€‚

#+BEGIN_SRC haskell
  instance Monad (Reader e) where
      return a         = Reader $ \_ -> a
      (Reader g) >>= f = Reader $ \e -> runReader (f (g e)) e
#+END_SRC

è·ŸEitherä¸€æ ·ï¼Œæˆ‘ä»¬åªèƒ½å®šä¹‰ Reader e çš„ monad instanceã€‚

æ³¨æ„è¿™é‡Œçš„
- f ç±»å‹æ˜¯ =(a -> Reader e a)=
- g å…¶å®å°±æ˜¯æ˜¯ destructure å‡ºæ¥çš„ runReaderï¼Œä¹Ÿå°±æ˜¯ e -> a
- æ‰€ä»¥ (g e) è¿”å› a
- f (g e) å°±æ˜¯ =Reader e a=
- å† run ä¸€æŠŠæœ€åå¾—åˆ° a

#+CAPTION: f å‡½æ•°ï¼Œæ¥æ”¶ a è¿”å›ä¸€ä¸ª ä» e åˆ° a çš„ Reader
[[file:images/p2-reader-monad.png]]

è®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ Reader
#+BEGIN_SRC haskell
  import Control.Monad.Reader
  
  data Environment = Env
    { fistName :: String
    , lastName :: String
    } deriving (Show)
  
  helloworld :: Reader Environment String
  helloworld = do
    f <- asks firstName
    l <- asks lastName
    return "Hello " ++ f ++ l
  
  runHelloworld :: String
  runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"
#+END_SRC

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œhelloworld è´Ÿè´£æ‰“æ‹›å‘¼ï¼Œä¹Ÿå°±æ˜¯åœ¨åå­—å‰é¢åŠ ä¸ª "Hello"ï¼Œè€Œè·Ÿè°æ‰“æ‹›å‘¼ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸å…³å¿ƒï¼Œè€Œå•çº¯çš„æ˜¯å‘ Environment  å°±å¥½ã€‚

#+CAPTION: asks å¯ä»¥å°† e -> a çš„å‡½æ•°å˜æ¢æˆ Reader e a
[[file:images/p2-reader-monad-ask.png]]

åœ¨è¿è¡Œæ—¶ï¼Œå¯ä»¥æä¾›ç»™ Reader çš„è¾“å…¥ Env fistname lastnameã€‚
[[file:images/p2-reader-monad-run.png]]

*** do notation
è¿™å¯èƒ½æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° =do= å’Œ =<-=. å¦‚æœä¸æ˜¯ï¼Œéšæ„è·³è¿‡è¿™èŠ‚ã€‚

- do ä¸­æ‰€æœ‰ <- çš„å³è¾¹éƒ½æ˜¯ =Reader Environment String= ç±»å‹
- do ä¸­çš„ return è¿”å›ç±»å‹ä¹Ÿå¿…é¡»ä¸º  =Reader Environment String=
- =asks firstName= è¿”å›çš„æ˜¯ =Reader Environment String= ç±»å‹ï¼Œ =<-= å¯ä»¥ç†è§£æˆå§ monad =Reader Environment= çš„å†…å®¹æ”¾åˆ°å·¦è¾¹çš„ f, æ‰€ä»¥ f çš„ç±»å‹æ˜¯ Stringã€‚

çœ‹èµ·æ¥åƒå‘½ä»¤å¼çš„è¯­å¥ï¼Œå…¶å®åªæ˜¯ ~>>=~ çš„è¯­æ³•ç³–ï¼Œä½†æ˜¯æ˜æ˜¾ç”¨doå¯è¯»æ€§è¦é«˜å¾ˆå¤šã€‚
#+BEGIN_SRC haskell
  helloworld = (asks firstName) >>=
    \f -> (asks lastName) >>=
         \l -> return "Hello " ++ f ++ l
#+END_SRC


** Writer

é™¤äº†è¿”å›å€¼ï¼Œè®¡ç®—ä¼šéœ€è¦äº§ç”Ÿä¸€äº›é¢å¤–çš„æ•°æ®ï¼Œæ¯”å¦‚ log

æ­¤æ—¶å°±éœ€è¦ä¸€ä¸ª Writterï¼Œå…¶è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · =(result, log)= çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª 

#+BEGIN_SRC haskell
  example :: Writer String String
  example  = do
    tell "How are you?"
    tell "I'm fine thank you, and you?"
    return "Hehe Da~"
  
  output :: (String, String)
  output = runWriter example
  -- ("Hehe Da~", "How are you?I'm fine thank you, and you?")
#+END_SRC

Writer çš„å®šä¹‰æ›´ç®€å•
#+BEGIN_SRC haskell
  newtype Writer l a = Writer { runWriter :: (a,l) }
#+END_SRC
é‡Œé¢åªæ˜¯ä¸€ä¸ª tuple è€Œå·²
- w æ˜¯ log
- a æ˜¯ è¿”å›å€¼

çœ‹çœ‹å¦‚ä½•å®ç° Writer monad
#+BEGIN_SRC haskell
  instance (Monoid w) => Monad (Writer w) where
      return a             = Writer (a,mempty)
      (Writer (a,l)) >>= f = let (a',l') = runWriter $ f a in
                             Writer (a',l `mappend` l')
#+END_SRC

- return ä¸ä¼šæœ‰ä»»ä½• logï¼Œl æ˜¯ monoid çš„ mempty
- f çš„ç±»å‹ä¸º =a -> Writer l a=
- =runWriter $ f a= è¿”å› =(a, l)=

[[file:images/p2-writer-monad.png]]

æ‰€ä»¥åœ¨ >>= æ—¶ï¼Œæˆ‘ä»¬å…ˆæŠŠ f a è¿”å›çš„ Writer runäº†ï¼Œç„¶åæŠŠä¸¤æ¬¡ log =mappend= èµ·æ¥ã€‚
[[file:images/p2-writer-monad-bind.png]]

** State
è·Ÿåå­—å°±çœ‹å¾—å‡ºæ¥ State monad æ˜¯ä¸ºäº†å¤„ç†çŠ¶æ€ã€‚è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹ä¸åº”è¯¥æœ‰çŠ¶æ€ï¼Œä¸ç„¶ä¼šå¼•ç”¨é€æ˜æ€§ã€‚ä½†æ˜¯ï¼Œstate monadå¹¶ä¸æ˜¯åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹çŠ¶æ€ï¼Œè€Œæ˜¯é€šè¿‡æè¿°è¿™ç§å˜åŒ–ï¼Œç„¶åéœ€è¦æ—¶åœ¨è¿è¡Œè¿”å›æœ€ç»ˆç»“æœã€‚è¿™ä¸€ç‚¹è·Ÿ Reader å’Œ Writer è¿™ä¸¤ä¸ªçœ‹èµ·æ¥æ˜¯å‰¯ä½œç”¨çš„ IO æ˜¯ä¸€æ ·çš„ã€‚

å…ˆçœ‹ä¸‹ State ç±»å‹çš„å®šä¹‰
#+BEGIN_SRC haskell
  newtype State s a = State { runState :: s -> (a, s) }
#+END_SRC

å¯ä»¥çœ‹åˆ° State åªåŒ…å«ä¸€ä¸ª ä»æ—§çŠ¶æ€ s åˆ°æ–°çŠ¶æ€ s å’Œè¿”å›å€¼ a çš„ Tuple çš„å‡½æ•°ã€‚

é€šè¿‡å®ç° Monadï¼ŒState å°±å¯ä»¥å®ç°å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„å˜é‡çš„åŠŸèƒ½ã€‚
#+BEGIN_SRC haskell
  instance Monad (State s) where
    return a        = State $ \s -> (a,s)
    (State x) >>= f = State $ \s -> let (v,s') = x s in
                                   runState (f v) s'
#+END_SRC
return å¾ˆç®€å•ï¼Œå°±ä¸ç”¨è§£é‡Šäº†ã€‚

[[file:images/p2-state-monad.png]]

x ç±»å‹æ˜¯ =s -> (a, s)= ,æ‰€ä»¥ x s ä¹‹åä¼šè¿”å› ç»“æœå’ŒçŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¿è¡Œå½“å‰ Stateï¼ŒæŠŠç»“æœ v ä¼ ç»™å‡½æ•° fï¼Œè¿”å›çš„ State å†æ¥ç€ä¸Šæ¬¡çŠ¶æ€è¿è¡Œã€‚

#+CAPTION: State x >>= f årunStateçš„æ•°æ®æµï¼ˆå•Šå•Šå•Šï¼Œç”»æ­ªäº†ï¼Œæ„Ÿè§‰éœ€è¦è„‰åŠ¨ä¸€ä¸‹ï¼‰
[[file:images/p2-state-monad-bind.png]]

ä½¿ç”¨èµ·æ¥ä¹Ÿå¾ˆæ–¹ä¾¿ï¼ŒState æä¾› =get= =put= =moidfy= ä¸‰ä¸ªæ–¹ä¾¿çš„å‡½æ•°å¯ä»¥ç”Ÿæˆä¿®æ”¹çŠ¶æ€çš„State monad

#+BEGIN_SRC haskell
  import Control.Monad.Trans.State.Strict
  test :: State Int Int
  test = do
    a <- get
    modify (+1)
    b <- get
    return (a + b)
  
  main = print $ show $ runState test 3
  -- (7, 4)
#+END_SRC


** Validation
å¦‚æœä½ æœ‰æ³¨æ„åˆ°ï¼Œå‰é¢çš„ Either å¯ä»¥ç”¨åœ¨å¤„ç†é”™è¯¯å’Œæ­£ç¡®çš„è·¯å¾„åˆ†æ”¯ï¼Œä½†æ˜¯é—®é¢˜æ˜¯é”™è¯¯åªå‘ç”Ÿä¸€æ¬¡ã€‚

#+BEGIN_QUOTE
Validation æ²¡æœ‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œä½†æ˜¯æˆ‘è§‰å¾—å¥½æœ‰ç”¨å•Šï¼Œä½ å¯ä»¥åœ¨ ekmett çš„ [[https://github.com/ekmett/either][github]] ä¸­æ‰¾åˆ°æºç 
#+END_QUOTE

æƒ³è±¡ä¸€ä¸‹è¿™ç§åœºæ™¯ï¼Œç”¨æˆ·æäº¤ä¸€ä¸ªè¡¨å•ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸€ä¸ªfieldè¿›è¡ŒéªŒè¯ï¼Œå¦‚æœæœ‰é”™è¯¯ï¼Œéœ€è¦æŠŠé”™è¯¯çš„å“ªå‡ ä¸ªfieldçš„é”™è¯¯æ¶ˆæ¯è¿”å›ã€‚æ˜¾ç„¶å¦‚æœä½¿ç”¨ Either æ¥åšï¼Œåªèƒ½è¿”å›ç¬¬ä¸€ä¸ªfieldçš„é”™è¯¯ä¿¡æ¯ï¼Œåé¢çš„è®¡ç®—éƒ½ä¼šè¢«è·³è¿‡ã€‚

é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œ Validation æ›´é€‚åˆ
#+BEGIN_SRC haskell
  data Validation e a = Failure e | Success a
#+END_SRC

ADTå®šä¹‰çœ‹èµ·æ¥è·Ÿ Either æ˜¯ä¸€æ ·çš„ï¼Œä¸åŒçš„æ˜¯  Failure æ˜¯ 

*** @@html:<ruby>å«å¹ºåŠç¾¤<rt>Monoid</rt></ruby>@@
monoid é¦–å…ˆå¾—æ˜¯  ï¼Œç„¶åå† å«å¹ºã€‚
#+BEGIN_SRC haskell
  class Semigroup a where
    (<>) :: a -> a -> a
    (<>) = mappend
#+END_SRC

åŠç¾¤éå¸¸ç®€å•ï¼Œåªè¦æ˜¯å¯ä»¥ =<>= (mappend) çš„ç±»å‹å°±æ˜¯äº†ã€‚

å«å¹ºåªéœ€è¦æœ‰ä¸€ä¸ª =mempty= çš„ å¹ºå…ƒå°±è¡Œ
#+BEGIN_SRC haskell
  class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
#+END_SRC

æ¯”å¦‚ List å°±æ˜¯ Semigroup
#+BEGIN_SRC haskell
  instance Semigroup [a] where
    (<>) = (++)
#+END_SRC
ä¹Ÿæ˜¯ Monoid
#+BEGIN_SRC haskell
  instance Monoid [a] where
    mempty  = []
    mappend = (++)
#+END_SRC

Monoid çš„ =<>= æ»¡è¶³ï¼š
- mempty <> a = a
- a <> b <> c = a <> (b <> c)
*** å›åˆ° Validation
ç°åœ¨è®© Failure e æ»¡è¶³ Monoidï¼Œå°±å¯ä»¥ =mappend= é”™è¯¯ä¿¡æ¯äº†ã€‚
#+BEGIN_SRC haskell
  instance Semigroup e => Semigroup (Validation e a) where
    Failure e1 <> Failure e2 = Failure (e1 <> e2)
    Failure _  <> Success a2 = Success a2
    Success a1 <> Failure _  = Success a1
    Success a1 <> Success _  = Success a1
#+END_SRC

ä¸‹æ¥ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹çœ‹ Validation ä¸ Either æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªformï¼Œéœ€è¦è¾“å…¥å§“åä¸ç”µè¯ï¼ŒéªŒè¯éœ€è¦å§“åæ˜¯éç©ºè€Œç”µè¯æ˜¯11ä½æ•°å­—ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æœ‰ä¸€ä¸ªå‡½æ•°å»åˆ›å»ºåŒ…å«å§“åå’Œç”µè¯çš„model
#+BEGIN_SRC haskell
  data Info = Info {name: String, phone: String} deriving Show
#+END_SRC

ç„¶åæˆ‘ä»¬éœ€è¦éªŒè¯å‡½æ•°
#+BEGIN_SRC haskell
  notEmpty :: String -> String -> Validation [String] String
  notEmpty desc "" = Failure [desc <> " cannot be empty!"]
  notEmpty _ field = Success field
#+END_SRC
notEmpty æ£€æŸ¥å­—ç¬¦æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ˜¯ç©ºè¿”å› Failure åŒ…å«é”™è¯¯ä¿¡æ¯ï¼Œè‹¥æ˜¯éç©ºåˆ™è¿”å› Success åŒ…å« field

åŒæ ·çš„å¯ä»¥åˆ›å»º 11ä½æ•°å­—çš„éªŒè¯å‡½æ•°
#+BEGIN_SRC haskell
  phoneNumberLength :: String -> String -> Validation [String] String
  phoneNumberLength desc field | (length field) == 11 = Success field
                               | otherwise = Failure [desc <> "'s length is not 11"]
#+END_SRC
å®ç° Validation çš„ Applicative instanceï¼Œè¿™æ ·å°±å¯ä»¥æŠŠå‡½æ•°è°ƒç”¨liftæˆå¸¦æœ‰éªŒè¯çš„ Applicative
#+BEGIN_SRC haskell
  instance Semigroup e => Applicative (Validation e) where
    pure = Success
    Failure e1 <*> Failure e2 = Failure e1 <> Failure e2
    Failure e1 <*> Success _  = Failure e1
    Success _  <*> Failure e2 = Failure e2
    Success f <*> Success a = Success (f a)
#+END_SRC
- å¤±è´¥åº”ç”¨åˆ°å¤±è´¥ä¼š concat èµ·æ¥
- å¤±è´¥è·Ÿåº”ç”¨æˆ–è¢«æˆåŠŸåº”ç”¨è¿˜æ˜¯å¤±è´¥
- åªæœ‰æˆåŠŸåº”ç”¨åˆ°æˆåŠŸæ‰èƒ½æˆåŠŸï¼Œè¿™å¾ˆç¬¦åˆéªŒè¯çš„é€»è¾‘ï¼Œä¸€æ—¦éªŒè¯ä¸­å‘ç”Ÿä»»ä½•é”™è¯¯ï¼Œéƒ½åº”è¯¥è¿”å›å¤±è´¥ã€‚

#+BEGIN_SRC haskell
  createInfo :: String -> String -> Validation [String] Info
  createInfo name phone = Info <$> notEmpty "name" name <*> phoneNumberLength "phone" phone
#+END_SRC

ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨å¸¦validationçš„ createInfo æ¥å®‰å…¨çš„åˆ›å»º Info äº†

#+BEGIN_SRC haskell
  createInfo "jichao" "12345678910" -- Success Info "jichao" "12345678910"
  createInfo "" "123" -- Failure ["name cannot be empty!", "phone's length is not 11"]
#+END_SRC

** Cont
Cont æ˜¯  çš„ monadï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯åŒ…å« cps è®¡ç®— monadã€‚

å…ˆçœ‹ä¸€ä¸‹ä»€ä¹ˆæ˜¯ CPSï¼Œæ¯”å¦‚æœ‰ä¸€ä¸ªåŠ æ³•
#+BEGIN_SRC haskell
  add :: Int -> Int -> Int
  add = (+)
#+END_SRC

ä½†æ˜¯å¦‚æœä½ æƒ³åœ¨ç®—æ³•åŠ æ³•åï¼Œèƒ½å¤Ÿç»§ç»­è¿›è¡Œä¸€ä¸ªå…¶ä»–çš„è®¡ç®—ï¼Œé‚£ä¹ˆå°±å¯ä»¥å†™ä¸€ä¸ª cpsç‰ˆæœ¬çš„åŠ æ³•
#+BEGIN_SRC haskell
  addCPS :: Int -> Int -> (Int -> r) -> r
  addCPS a b k = k (a + b)
#+END_SRC

éå¸¸ç®€å•ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹çœ‹ä¸ºä»€ä¹ˆéœ€è¦ä¸€ä¸ª Cont monad æ¥åŒ…ä½ CPS è®¡ç®—ï¼Œé¦–å…ˆï¼Œæ¥çœ‹ ADT å®šä¹‰
#+BEGIN_SRC haskell
  newtype Cont r a = Cont { runCont :: ((a -> r) -> r) }
#+END_SRC

åˆæ˜¯ä¸€ä¸ªåŒæ„çš„ç±»å‹ï¼ŒCont æ„é€ å™¨åªéœ€è¦ä¸€ä¸ª runCountï¼Œä¹Ÿå°±æ˜¯è®©ä»–èƒ½ç»§ç»­è®¡ç®—çš„ä¸€ä¸ªå‡½æ•°ã€‚

å®Œäº†ä¹‹åæ¥æŠŠä¹‹å‰çš„ addCPS æ”¹æˆ Cont
#+BEGIN_SRC haskell
  add :: Int -> Int -> Cont k Int
  add a b = return (a + b)
#+END_SRC

æ³¨æ„åˆ° addCPS æ¥æ”¶åˆ° a å’Œ b ä¹‹åè¿”å›çš„ç±»å‹æ˜¯ =(Int -> r) -> r= ï¼Œè€Œ Cont ç‰ˆæœ¬çš„ =add= è¿”å› =Cont k Int=

æ˜æ˜¾æ„é€  =Cont k Int= ä¹Ÿæ­£æ˜¯éœ€è¦ =(Int -> r) -> r= ï¼Œæ‰€ä»¥ Cont å°±æ˜¯ç®—äº† k çš„æŠ½è±¡äº†ã€‚

#+BEGIN_SRC haskell
  instance Monad (Cont r) where
      return a = Cont ($ a)
      m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
#+END_SRC

=($ a)= æ¯”è¾ƒæœ‰æ„æ€, æˆ‘ä»¬éƒ½çŸ¥é“ =f $ g a= å…¶å®å°±æ˜¯ =f(g a)=, æ‰€ä»¥ =$= å…¶å®å°±æ˜¯ä¸€ä¸ª apply å·¦è¾¹çš„å‡½æ•°åˆ°å³è¾¹è¡¨è¾¾å¼çš„ä¸­ç¼€å‡½æ•°, å¦‚æœå†™æˆå‰ç¼€åˆ™æ˜¯
=($ (g a) f)=. æ˜¯åçš„æ˜¯å› ä¸º =$= æ˜¯æœ‰ç»“åˆ, éœ€è¦å³è¾¹è¡¨è¾¾å¼å…ˆæ±‚å€¼, æ‰€ä»¥åªç»™ä¸€ä¸ª a å°±ç›¸å½“äº =($ a) = \f -> f a=

å›åˆ° Monad Cont...

** Summary
ç¬¬äºŒéƒ¨åˆ†é£Ÿç”¨éƒ¨åˆ†ä¹Ÿè®²å®Œäº†ï¼Œ ä¸çŸ¥æ˜¯å¦ä»¥åŠå¤§è‡´äº†è§£äº†monadçš„å°¿æ€§å„ç§åŸºæœ¬ç©æ³•å‘¢ï¼Ÿé€šè¿‡è¿™äº›å¸¸ç”¨çš„åŸºæœ¬çš„ monad instanceï¼Œè§£å†³å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„ä¸€äº›ç®€å•é—®é¢˜åº”è¯¥æ˜¯å¤Ÿäº†ã€‚

ä¸è¿‡ï¼Œæ¥ä¸‹æ¥è¿˜æœ‰æ›´å˜æ€çš„çŒ«ï¼Œå°±å…ˆå«å¥¹ +æåŸº+ çŒ«å‘¢å¥½äº†ã€‚

- ğŸ‘‰ [[file:./part3.org][ç¬¬ä¸‰éƒ¨åˆ†ï¼š]]

å½“ç„¶æˆ‘åˆè¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœè¿˜æœ‰å¾ˆå¤šäºº Gumroad ä¸Šçš„  ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œï¼Œå°±å½“æ˜¯æˆ‘åˆè‡ªè¨€è‡ªè¯­å§ï¼Œæ€ä¹ˆåˆçªç„¶è§‰å¾—è‡ªå·±å¥½åˆ†è£‚ï¼Œè¯¶~ï¼Œä¸ºä»€ä¹ˆæˆ‘è¦è¯´åˆï¼Ÿ
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@
#+DESCRIPTION: å·ä¸‰ æåŸºçŒ«å‘¢
#+INDEX: Catergory Theory!èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ å·ä¸‰

- [[file:./part1.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šçŒ«è®º]]
- [[file:./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]
- [[file:./part3.org][*ç¬¬ä¸‰éƒ¨åˆ†ï¼šæåŸºçŒ«å‘¢*]] ğŸ‘ˆ

* ç¬¬ä¸‰éƒ¨åˆ†:@@html:<ruby>æåŸºçŒ«å‘¢<rt>Advanced Monads</rt></ruby>@@
ç¬¬äºŒéƒ¨åˆ†ä»‹ç»äº†ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

é€šè¿‡å®ƒä»¬å¯ä»¥è§£å†³å¤§å¤šæ•°çš„åŸºæœ¬é—®é¢˜ï¼Œä½†æ˜¯æ­£å¯¹äºå¤æ‚ä¸šåŠ¡é€»è¾‘ï¼Œæˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦ä¸€äº›æ›´é«˜é˜¶çš„ monad æˆ–è€… patternã€‚

å½“æœ‰äº†ç¬¬ä¸€éƒ¨åˆ†çš„ç†è®ºåŸºç¡€å’Œç¬¬äºŒéƒ¨åˆ†çš„å®è·µï¼Œè¿™éƒ¨åˆ†è¦ä»‹ç»çš„çŒ«å‘¢å…¶å®å¹¶ä¸æ˜¯å¾ˆæåŸºã€‚é€šè¿‡è¿™ä¸€éƒ¨åˆ†ä»‹ç»çš„æåŸºçŒ«å‘¢ï¼Œ
æˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚

** RWS
RWS æ˜¯ç¼©å†™ Reader Writer State monad, æ‰€ä»¥æ˜æ˜¾æ˜¯ä¸‰ä¸ªmonadçš„åˆä½“ã€‚å¦‚æœå·²ç»å¿˜è®° Reader Writer æˆ–è€… Stateï¼Œè¯·åˆ°ç¬¬äºŒéƒ¨åˆ†å¤ä¹ ä¸€ä¸‹ã€‚

ä¸€æ—¦æŠŠä¸‰ä¸ª monad åˆä½“ï¼Œæ„å‘³ç€å¯ä»¥åœ¨åŒä¸€ä¸ª monad ä½¿ç”¨ä¸‰ä¸ª monad çš„æ–¹æ³•ï¼Œæ¯”å¦‚ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ Reader çš„ ask, State çš„ get, put, å’Œ Writer çš„ tell

#+BEGIN_SRC haskell
  readWriteState = do
    e <- ask
    a <- get
    let res = a + e
    put res
    tell [res]
    return res
  runRWS readWriteState 1 2
  -- (3 3 [3])
#+END_SRC

æ³¨æ„åˆ°è·Ÿ Reader å’Œ State ä¸€æ ·ï¼Œrunçš„æ—¶å€™è¾“å…¥åˆå§‹å€¼

å…¶ä¸­ 1 ä¸º Reader çš„å€¼ï¼Œ2 ä¸º State çš„åˆå§‹çŠ¶æ€.

** Monad Transform

ä½ ä¼šå‘ç° RWS ä¸€èµ·ç”¨æŒºå¥½çš„ï¼Œèƒ½è¯»èƒ½å†™èƒ½æ‰“ logï¼Œä½†æ˜¯å·²ç»å›ºå®šå¥½æ­é…äº†ï¼Œåªèƒ½æ˜¯ RWS ï¼Œå¦‚æœæˆ‘è¿˜æƒ³åŠ å…¥å…¶å®ƒçš„ Monadï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ

è¿™æ—¶å€™ï¼Œç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åŠ ä¸ª Tï¼Œæ¯”å¦‚å¯¹äº Readerï¼Œæˆ‘ä»¬æœ‰ ReaderTï¼ŒRWSï¼Œä¹Ÿæœ‰å¯¹åº”çš„ RWSTã€‚å…¶ä¸­ T ä»£è¡¨ Transformã€‚

*** ReaderT

è®©æˆ‘æ¥é€šè¿‡ç®€å•çš„ ReaderT æ¥è§£é‡Šåˆ°åº•ä»€ä¹ˆæ˜¯ T å§, é¦–å…ˆè·Ÿ Reader ä¸€æ ·æˆ‘ä»¬æœ‰ä¸ª runReaderT

#+BEGIN_SRC haskell
  newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
#+END_SRC

æ¯”è¾ƒä¸€ä¸‹ Reader çš„å®šä¹‰
#+BEGIN_SRC haskell
  newtype Reader e a = Reader { runReader :: (e -> a) }
#+END_SRC

æœ‰æ²¡æœ‰å‘ç°å¤šäº†ä¸€ä¸ª m, ä¹Ÿå°±æ˜¯è¯´, =runReader e= ä¼šè¿”å› a, ä½†æ˜¯ =runReaderT e= åˆ™ä¼šè¿”å› =m a=

[[file:images/p3-ReaderT.png]]

#+BEGIN_SRC haskell
  instance (Monad m) => Monad (ReaderT e m) where
      return   = lift . return
      r >>= k  = ReaderT $ \ e -> do
          a <- runReaderT r e
          runReaderT (k a) e
#+END_SRC

å†çœ‹çœ‹ monad çš„å®ç°, ä¹Ÿæ˜¯ä¸€æ ·çš„, å…ˆ run ä¸€ä¸‹ =r e= å¾—åˆ°ç»“æœ =a=, åº”ç”¨å‡½æ•° =k= åˆ° =a=, å† run ä¸€æŠŠ.


é—®é¢˜æ˜¯, è¿™é‡Œçš„ =return= é‡Œé¢çš„ =lift= æ˜¯å“ªæ¥çš„?

#+BEGIN_SRC haskell
  instance MonadTrans (ReaderT e) where
    lift m = ReaderT (const m)
#+END_SRC

[[file:images/p3-MonadTrans-ReaderT-e-m.png]]

è¿™ä¸ªå‡½æ•° =lift= è¢«å®šä¹‰åœ¨ MonadTrans çš„å®ä¾‹ä¸­, ç®€å•çš„æŠŠ m æ”¾åˆ° ReaderT ç»“æœä¸­.

ä¾‹å¦‚, =lift (Just 1)= ä¼šå¾—åˆ° ReaderT, å…¶ä¸­ e éšæ„, m ä¸º Maybe Num

é‡ç‚¹éœ€è¦ä½“ä¼šçš„æ˜¯, Reader å¯ä»¥è¶Šè¿‡ Maybe ç›´æ¥æ“ä½œåˆ° Num, å®Œäº†å†åŒ…å›æ¥.

æœ‰äº† ReaderT, æ­é… Id Monad å°±å¾ˆå®¹æ˜“åˆ›å»ºå‡ºæ¥ Reader Monad

#+BEGIN_SRC haskell
  type Reader r a= ReaderT r Identity a
#+END_SRC

è¶Šè¿‡ Id read åˆ° Id å†…éƒ¨, å®Œäº†å†ç”¨ Id åŒ…å›æ¥, ä¸å°±æ˜¯ Reader äº†ä¹ˆ

#+BEGIN_SRC haskell
  ReaderT { runReaderT :: r -> Identity a }
  -- Identity a is a
  ReaderT { runReaderT :: r -> a }
#+END_SRC

** Alternative

è¿™ä¸ª typeclass æä¾› =<|>= å‡½æ•°, è¡¨ç¤ºè¦ä¹ˆè®¡ç®—å·¦è¾¹, è¦ä¹ˆè®¡ç®—å³è¾¹

#+BEGIN_SRC haskell
  class Applicative f => Alternative f where
      empty :: f a
      (<|>) :: f a -> f a -> f a
#+END_SRC

[[file:images/p3-Alternative.png]]

å…¶å®å°±æ˜¯ Applicative çš„ =æˆ–=

æ¯”å¦‚:
#+BEGIN_SRC haskell
  Just 1 <|> Just 2 -- Just 1
  Just 1 <|> Nothing -- Just 1
  Nothing <|> Just 1 -- Just 1
  Nothing <|> Nothing -- Nothing
#+END_SRC

** MonadPlus
è¿™è·Ÿ Alternative æ˜¯ä¸€æ¯›ä¸€æ ·çš„, åªæ˜¯é™åˆ¶çš„æ›´ç»†, å¿…é¡»æ˜¯ Monadæ‰è¡Œ

#+BEGIN_SRC haskell
  class (Alternative m, Monad m) => MonadPlus m where
     mzero :: m a
     mzero = empty
     mplus :: m a -> m a -> m a
     mplus = (<|>)
#+END_SRC

çœ‹, å®ç°ä¸­ç›´æ¥å°±è°ƒç”¨äº† Alternative çš„ =empty= å’Œ =<|>=

** ST Monad
ST Monad è·Ÿ State Monad çš„åŠŸèƒ½æœ‰äº›åƒ, ä¸è¿‡æ›´å‰å®³çš„æ˜¯, ä»–ä¸æ˜¯ immutable çš„, è€Œæ˜¯ "immutable" çš„åœ¨åŸåœ°åšä¿®æ”¹. æ”¹å®Œä¹‹å runST åˆç„¶ä»–å›åˆ°äº† immutable çš„ Haskell ä¸–ç•Œ.

#+BEGIN_SRC haskell
  sumST :: Num a => [a] -> a
  sumST xs = runST $ do           -- do åé¢çš„äº‹æƒ…ä¼šæ˜¯ä¸é”™çš„å†…å­˜æ“ä½œ, runST å¯ä»¥æŠŠå®ƒæ‹‰ä¼šçº¯çš„ä¸–ç•Œ
      n <- newSTRef 0             -- åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€å—å¹¶æŒ‡åˆ° STRef
      forM_ xs $ \x -> do         -- è¿™è·Ÿå‘½ä»¤å¼çš„forå¾ªç¯æ”¹å†™å˜é‡æ˜¯ä¸€æ¯›ä¸€æ ·çš„
          modifySTRef n (+x)
      readSTRef n                 -- è¿”å›æ”¹å®Œä¹‹åçš„ n çš„å€¼
#+END_SRC

** Free Monad
ä¸Šä¸€ç« è¯´è¿‡çš„ RWS Monad æ¯•ç«Ÿæ˜¯å›ºå®šæ­é…ï¼Œå½“ä½ çš„ä¸šåŠ¡éœ€è¦æ›´å¤šçš„ Monad æ¥è¡¨ç¤º Effect æ—¶ï¼Œ
æˆ‘ä»¬å°±éœ€è¦æœ‰é‚£ä¹ˆä¸ªå°çŒªæ‰‹å¸®æˆ‘ä»¬å®šä¹‰è‡ªå·±çš„ Monadã€‚

é‚£å°±æ˜¯ Free, Free å¯ä»¥å°†ä»»æ„ datatype lift æˆä¸º Monad

*** Free
å…ˆçœ‹ Free ä»€ä¹ˆå®šä¹‰:

#+BEGIN_SRC haskell
  data Free f a = Roll (f (Free f a)) | Return a
#+END_SRC

å…¶ä¸­ =f= å°±æ˜¯ä½ ä¸šåŠ¡éœ€è¦çš„ effect ç±»å‹, =a= æ˜¯è¿™ä¸ª effect æ‰€äº§ç”Ÿçš„è¿”å›å€¼ç±»å‹ã€‚

å³è¾¹ä¸¤ç§æ„é€ å‡½æ•°ï¼Œå¦‚æœæŠŠ =Role= æ”¹æˆ =Cons=, =Return= æ”¹æˆ =Nil= çš„è¯, æ˜¯ä¸æ˜¯è·Ÿ List å…¶å®æ˜¯  çš„å‘¢? æ‰€ä»¥å¦‚æœæƒ³è±¡æˆ List, é‚£ä¹ˆ =f= åœ¨è¿™é‡Œå°±ç›¸å½“äº List ä¸­çš„ä¸€ä¸ªå…ƒç´ .

åˆ°é‚£æ—¶, ~>>=~ çš„æ“ä½œåˆè·Ÿ List ç•¥æœ‰ä¸åŒ, æˆ‘ä»¬éƒ½çŸ¥é“ ~>>=~ ä¼šæŠŠæ¯ä¸€ä¸ªå…ƒç´  map æˆ List, ç„¶å flatten, ä½† Free å…¶å®æ˜¯ç”¨æ¥æ„å»º
é¡ºåºçš„ effect çš„, æ‰€ä»¥:

#+BEGIN_SRC haskell
  instance Functor f => Monad (Free f) where
    return a        = Return a
    Return a >>= fn = fn a
    Roll ffa >>= fn = Roll $ fmap (>>= fn) ffa
#+END_SRC

ä½ ä¼šå‘ç° ~>>=~ ä¼šé€’å½’çš„ =fmap= åˆ° =Roll= ä¸Š, ç›´åˆ°æœ€åä¸€ä¸ª =Return=.

æ¯”å¦‚, å¦‚æœä½ æœ‰ä¸€ä¸ª program æœ‰ä¸‰ç§å‰¯ä½œç”¨ Eff1, Eff2, Eff3

#+BEGIN_SRC haskell
  data Eff a = Eff1 a | Eff2 a | Eff3 a
  program = do
   a <- liftF $ Eff1 1
   b <- liftF $ Eff2 2
   c <- liftF $ Eff3 3
   return a + b + c
#+END_SRC

å¦‚æœæˆ‘ä»¬æŠŠ program å±•å¼€, æ¯ä¸€æ­¥ ~>>=~ å¤§æ¦‚æ˜¯è¿™æ ·:

#+BEGIN_SRC haskell
  liftF $ Eff1 1
#+END_SRC

å±•å¼€æ—¢æ˜¯:

#+BEGIN_SRC haskell
  Roll (Eff1 (Return 1))
#+END_SRC

ä»£å…¥åˆ° program å³:
#+BEGIN_SRC haskell
  program = Roll (Eff1 (Return 1)) >>= \a -> do
     b <- liftF $ Eff2 2
     c <- liftF $ Eff3 3
     return a + b + c
#+END_SRC

ç”¨ Free çš„ ~>>=~ å…¬å¼ ~Roll ffa >>= fn = Roll $ fmap (>>= fn) ffa~ å»å±•å¼€ä¸Šé¢å°±å¾—åˆ°:

#+BEGIN_SRC haskell
  program = Roll $ Eff1 (Return 1 >>= fn1)) where
    fn1 = \a -> do
     b <- liftF $ Eff2 2
     c <- liftF $ Eff3 3
     return a + b + c
#+END_SRC

~Return 1 >>= fn1~ æˆ‘ä»¬éƒ½çŸ¥é“æ€ä¹ˆå±•å¼€:

#+BEGIN_SRC haskell
  program = Roll $ Eff1 (fn1 1) where
    fn1 = \a -> do
     b <- liftF $ Eff2 2
     c <- liftF $ Eff3 3
     return a + b + c
#+END_SRC

å±•å¼€ =fn1=

#+BEGIN_SRC haskell
  program = Roll $ Eff1 do
     b <- liftF $ Eff2 2
     c <- liftF $ Eff3 3
     return 1 + b + c
#+END_SRC


åŒæ ·çš„æ­¥éª¤å±•å¼€ Eff2
#+BEGIN_SRC haskell
  program = Roll $ Eff1 $ Roll $ Eff2 do
     c <- liftF $ Eff3 3
     return 1 + 2 + c
#+END_SRC

å’Œ Eff3

#+BEGIN_SRC haskell
  program = Roll $ Eff1 $ Roll $ Eff2 $ Roll $ Eff3 do
     return 1 + 2 + 3
#+END_SRC

æœ€åçš„ program æ˜¯ä¸æ˜¯å¾ˆåƒ List çš„ Cons å’Œ Nil å‘¢?

#+BEGIN_SRC haskell
  program = Roll $ Eff1 $ Roll $ Eff2 $ Roll $ Eff3 $ Return 1 + 2 + 3
#+END_SRC


ä½†æ˜¯, ç»†å¿ƒçš„ä½ å¯èƒ½æ—©éƒ½å‘ç°äº† =Eff= è¿™è´§å¿…é¡»æ˜¯ä¸ª =Functor= æ‰è¡Œ. é‚£æˆ‘ä»¬å¦‚ä½•éšä¾¿å®šä¹‰ä¸€ä¸ª =data Eff= ç›´æ¥èƒ½ç”Ÿæˆ =Functor Eff= çš„å®ä¾‹å‘¢?

*** Coyoneda

å¸Œæœ›ä½ è¿˜ä¾ç„¶è®°å¾—ç¬¬ä¸€éƒ¨åˆ†çš„ç±³ç”° +å…±+ å¼•ç†

#+BEGIN_SRC haskell
  data CoYoneda f a = forall b. CoYoneda (b -> a) (f b)
#+END_SRC

[[file:images/p3-CoYoneda.png]]

äº‹å®ä¸Šå¾ˆç®€å•å¯ä»¥æŠŠä»»ä½• =f= å˜æˆ =CoYoneda f=

#+BEGIN_SRC haskell
  phi :: f a -> CoYoneda f a
  phi fa = CoYoneda id fa
#+END_SRC

[[file:images/p3-CoYoneda-phi.png]]

è¯€çªå°±æ˜¯ =id=, ä¹Ÿå°±æ˜¯ä½ æŠŠ =b= å˜æˆ =a=, å†æŠŠ =fa= æ”¾åˆ° =CoYoneda= é‡Œå°±å¥½äº†

å½“ =f= æ˜¯ =Functor= æ—¶, åˆå¯ä»¥æŠŠ =CoYoneda= å˜æˆ =f=

#+BEGIN_SRC haskell
  psi :: Functor f => CoYoneda f a -> f a
  psi (CoYoneda g fa) = fmap g fa
#+END_SRC

[[file:images/p3-CoYoneda-psi.png]]

åè¿‡æ¥çš„è¿™ä¸ªä¸é‡è¦, é‡è¦çš„æ˜¯ =phi=, å› ä¸ºå¦‚æœä½ å¯ä»¥æŠŠä»»ä½• =f= å˜æˆ =CoYoneda f=, è€Œ =CoYoneda f= åˆæ˜¯ =Functor=,
æˆ‘ä»¬ä¸å°±å…è´¹å¾—åˆ°ä¸€ä¸ª =Functor=?

#+BEGIN_SRC haskell
  instance Functor (Coyoneda f) where
    fmap f (Coyoneda g fb) = Coyoneda (f . g) fb
#+END_SRC

*** Free Functor
æ¯”å¦‚æˆ‘ä»¬çš„ =Eff= å°±å¯ä»¥ç›´æ¥é€šè¿‡ =phi= å˜æˆ =CoYoneda Eff=, ä»è€Œå¾—åˆ°å…è´¹çš„ Functor

#+BEGIN_SRC haskell
  data Eff a = Eff1 a | Eff2 a | Eff3 a
  program = Roll (phi (Eff1 (Roll (phi (Eff2 (Return Int))))))
#+END_SRC

[[file:images/p3-Free.png]]

*** Interpreter
æ„é€ å®Œä¸€ä¸ª free program å,æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªåµŒå¥—çš„æ•°æ®ç»“æ„, å½“æˆ‘ä»¬éœ€è¦ run è¿™ä¸ª program æ—¶, æˆ‘ä»¬éœ€è¦ foldMap ä¸€ä¸ª
Interpreter å»ä¸€å±‚å±‚æ‹¨å¼€ è¿™ä¸ª free program.

#+BEGIN_SRC haskell
  foldMap :: Monad m => (forall x . f x -> m x) -> Free f a -> m a
  foldMap _ (Return a)  = return a
  foldMap f (Roll a) = f a >>= foldMap f
#+END_SRC

** Free Monoid
** Eff

** Comonad

* References
- http://dev.stephendiehl.com/hask
- https://en.wikibooks.org/wiki/Haskell/Category_theory
- https://www.youtube.com/watch?v=ZKmodCApZwk
- https://www.youtube.com/watch?v=kiXjcqxVogE&list=PL50ABC4792BD0A086&index=5
- https://wiki.haskell.org/All_About_Monads
